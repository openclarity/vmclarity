// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package util

import (
	"strings"

	"github.com/sirupsen/logrus"

	"github.com/openclarity/vmclarity/pkg/shared/families/malware/common"
)

const (
	// A yara detected malware line should be in the following format: <yara rule name> [<coma,separated,meta data>] <path>.
	scanError      = "error scanning"
	malwareNameKey = "name" // The key defined in the metadata of yara rule
	malwareTypeKey = "type" // The key defined in the metadata of yara rule
)

type ScanResultLine struct {
	RuleName string
	Metadata map[string]string
	Path     string
}

func ParseYaraScanOutput(yaraOutput string, logger *logrus.Entry) []common.DetectedMalware {
	logger.Debugf("Parsing yara output: %s", yaraOutput)
	lines := strings.Split(yaraOutput, "\n")

	malwareInfoList := make([]common.DetectedMalware, 0)
	for i := range lines {
		if strings.Contains(lines[i], scanError) {
			logger.Errorf("Yara scan failed: %s", lines[i])
			continue
		}

		words := separateFields(lines[i])
		// If the line has less than `detectedMalwareLineWordCount` words in it, it can't be a malware detection, so it's skipped
		if words == nil {
			logger.Debugf("omitting invalid yara line: %s", words)
			continue
		}

		detectedMalware := extractDetectedMalware(words)
		malwareInfoList = append(malwareInfoList, *detectedMalware)
	}

	return malwareInfoList
}

func separateFields(line string) *ScanResultLine {
	var scanResultLine ScanResultLine
	ruleName, remainder, found := strings.Cut(line, "[")
	if !found {
		return nil
	}
	metadata, path, found := strings.Cut(remainder, "]")
	if !found {
		return nil
	}
	scanResultLine.RuleName = strings.TrimSpace(ruleName)
	scanResultLine.Metadata = parseYaraRuleMetadata(metadata)
	scanResultLine.Path = strings.TrimSpace(path)

	return &scanResultLine
}

func extractDetectedMalware(line *ScanResultLine) *common.DetectedMalware {
	if line == nil {
		return nil
	}

	// Extract name and type from metadata if they are defined
	var malwareName, malwareTypeStr string
	if _, ok := line.Metadata[malwareNameKey]; ok {
		malwareName = line.Metadata[malwareNameKey]
	}
	if _, ok := line.Metadata[malwareTypeKey]; ok {
		malwareTypeStr = line.Metadata[malwareTypeKey]
	}

	return &common.DetectedMalware{
		MalwareName: malwareName,
		MalwareType: malwareTypeStr,
		Path:        line.Path,
		RuleName:    line.RuleName,
	}
}

func parseYaraRuleMetadata(metadata string) map[string]string {
	m := make(map[string]string)
	if metadata == "" {
		return m
	}
	entries := strings.Split(metadata, ",")
	for _, e := range entries {
		key, value, found := strings.Cut(e, "=")
		if !found {
			continue
		}
		m[key] = strings.Trim(value, "\"")
	}

	return m
}
