// Copyright Â© 2023 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package util

import (
	"strings"

	"github.com/sirupsen/logrus"

	"github.com/openclarity/vmclarity/pkg/shared/families/malware/common"
)

const (
	scanError                    = "error scanning"
	yaraRuleNamePosition         = 0
	yaraRuleMetadataPosition     = 1
	detectedMalwarePathPosition  = 2
	detectedMalwareLineWordCount = 3 // A yara detected malware line should be in the following format: <yara rule name> <[yara rule metadata]> <path>
	malwareNameString            = "name"
	malwareTypeString            = "type"
)

func ParseYaraScanOutput(yaraOutput string, logger *logrus.Entry) []common.DetectedMalware {
	logger.Debugf("Parsing yara output: %s", yaraOutput)
	lines := strings.Split(yaraOutput, "\n")

	malwareInfoList := make([]common.DetectedMalware, 0)
	for i := range lines {
		logger.Debugf("line %d: %s", i, lines[i])
		if strings.Contains(lines[i], scanError) {
			logger.Errorf("Yara scan failed: %s", lines[i])
			continue
		}

		words := strings.Fields(lines[i])
		// If the line has less than `detectedMalwareLineWordCount` words in it, it can't be a malware detection, so it's skipped
		if len(words) < detectedMalwareLineWordCount {
			logger.Debugf("omitting invalid clam line: %s", words)
			continue
		}

		detectedMalware := extractDetectedMalware(words)
		malwareInfoList = append(malwareInfoList, *detectedMalware)
	}

	return malwareInfoList
}

func extractDetectedMalware(words []string) *common.DetectedMalware {
	if len(words) == 0 {
		return nil
	}

	// Extract the Yara rule name from the words
	ruleName := words[yaraRuleNamePosition]

	// Extract the file path from the words
	filePath := words[detectedMalwarePathPosition]

	// Parse the malware metadata
	metadata := parseYaraRuleMetadata(words[yaraRuleMetadataPosition])

	// Extract name and type from metadata if they are defined
	var malwareName, malwareTypeStr string
	if _, ok := metadata[malwareNameString]; ok {
		malwareName = metadata[malwareNameString]
	}
	if _, ok := metadata[malwareTypeString]; ok {
		malwareTypeStr = metadata[malwareTypeString]
	}

	return &common.DetectedMalware{
		MalwareName: malwareName,
		MalwareType: malwareTypeStr,
		Path:        filePath,
		RuleName:    ruleName,
	}
}

func parseYaraRuleMetadata(metadata string) map[string]string {
	m := make(map[string]string)
	if metadata == "[]" {
		return m
	}
	metadata = strings.TrimPrefix(metadata, "[")
	metadata = strings.TrimSuffix(metadata, "]")
	entries := strings.Split(metadata, ",")
	for _, e := range entries {
		parts := strings.Split(e, "=")
		m[parts[0]] = strings.Trim(parts[1], "\"")
	}

	return m
}
