// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Vulnerability vulnerability
//
// swagger:model Vulnerability
type Vulnerability struct {

	// affected project count
	AffectedProjectCount int32 `json:"affectedProjectCount,omitempty"`

	// components
	Components []*Component `json:"components"`

	// created
	Created float64 `json:"created,omitempty"`

	// credits
	Credits string `json:"credits,omitempty"`

	// cvss v2 base score
	CvssV2BaseScore float64 `json:"cvssV2BaseScore,omitempty"`

	// cvss v2 exploitability sub score
	CvssV2ExploitabilitySubScore float64 `json:"cvssV2ExploitabilitySubScore,omitempty"`

	// cvss v2 impact sub score
	CvssV2ImpactSubScore float64 `json:"cvssV2ImpactSubScore,omitempty"`

	// cvss v2 vector
	CvssV2Vector string `json:"cvssV2Vector,omitempty"`

	// cvss v3 base score
	CvssV3BaseScore float64 `json:"cvssV3BaseScore,omitempty"`

	// cvss v3 exploitability sub score
	CvssV3ExploitabilitySubScore float64 `json:"cvssV3ExploitabilitySubScore,omitempty"`

	// cvss v3 impact sub score
	CvssV3ImpactSubScore float64 `json:"cvssV3ImpactSubScore,omitempty"`

	// cvss v3 vector
	CvssV3Vector string `json:"cvssV3Vector,omitempty"`

	// cwe
	Cwe *Cwe `json:"cwe,omitempty"`

	// description
	Description string `json:"description,omitempty"`

	// finding attribution
	FindingAttribution *FindingAttribution `json:"findingAttribution,omitempty"`

	// friendly vuln Id
	// Max Length: 255
	// Min Length: 1
	FriendlyVulnID string `json:"friendlyVulnId,omitempty"`

	// patched versions
	PatchedVersions string `json:"patchedVersions,omitempty"`

	// published
	// Format: date-time
	Published strfmt.DateTime `json:"published,omitempty"`

	// recommendation
	Recommendation string `json:"recommendation,omitempty"`

	// references
	References string `json:"references,omitempty"`

	// service components
	ServiceComponents []*ServiceComponent `json:"serviceComponents"`

	// severity
	// Enum: [CRITICAL HIGH MEDIUM LOW INFO UNASSIGNED]
	Severity string `json:"severity,omitempty"`

	// source
	// Max Length: 255
	// Min Length: 1
	Source string `json:"source,omitempty"`

	// sub title
	SubTitle string `json:"subTitle,omitempty"`

	// title
	Title string `json:"title,omitempty"`

	// updated
	// Format: date-time
	Updated strfmt.DateTime `json:"updated,omitempty"`

	// uuid
	// Required: true
	// Format: uuid
	UUID *strfmt.UUID `json:"uuid"`

	// vuln Id
	// Max Length: 255
	// Min Length: 1
	VulnID string `json:"vulnId,omitempty"`

	// vulnerable software
	VulnerableSoftware []*VulnerableSoftware `json:"vulnerableSoftware"`

	// vulnerable versions
	VulnerableVersions string `json:"vulnerableVersions,omitempty"`
}

// Validate validates this vulnerability
func (m *Vulnerability) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateComponents(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCwe(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFindingAttribution(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFriendlyVulnID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePublished(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateServiceComponents(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSeverity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSource(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdated(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUUID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVulnID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVulnerableSoftware(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Vulnerability) validateComponents(formats strfmt.Registry) error {
	if swag.IsZero(m.Components) { // not required
		return nil
	}

	for i := 0; i < len(m.Components); i++ {
		if swag.IsZero(m.Components[i]) { // not required
			continue
		}

		if m.Components[i] != nil {
			if err := m.Components[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("components" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Vulnerability) validateCwe(formats strfmt.Registry) error {
	if swag.IsZero(m.Cwe) { // not required
		return nil
	}

	if m.Cwe != nil {
		if err := m.Cwe.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cwe")
			}
			return err
		}
	}

	return nil
}

func (m *Vulnerability) validateFindingAttribution(formats strfmt.Registry) error {
	if swag.IsZero(m.FindingAttribution) { // not required
		return nil
	}

	if m.FindingAttribution != nil {
		if err := m.FindingAttribution.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("findingAttribution")
			}
			return err
		}
	}

	return nil
}

func (m *Vulnerability) validateFriendlyVulnID(formats strfmt.Registry) error {
	if swag.IsZero(m.FriendlyVulnID) { // not required
		return nil
	}

	if err := validate.MinLength("friendlyVulnId", "body", m.FriendlyVulnID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("friendlyVulnId", "body", m.FriendlyVulnID, 255); err != nil {
		return err
	}

	return nil
}

func (m *Vulnerability) validatePublished(formats strfmt.Registry) error {
	if swag.IsZero(m.Published) { // not required
		return nil
	}

	if err := validate.FormatOf("published", "body", "date-time", m.Published.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Vulnerability) validateServiceComponents(formats strfmt.Registry) error {
	if swag.IsZero(m.ServiceComponents) { // not required
		return nil
	}

	for i := 0; i < len(m.ServiceComponents); i++ {
		if swag.IsZero(m.ServiceComponents[i]) { // not required
			continue
		}

		if m.ServiceComponents[i] != nil {
			if err := m.ServiceComponents[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("serviceComponents" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var vulnerabilityTypeSeverityPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["CRITICAL","HIGH","MEDIUM","LOW","INFO","UNASSIGNED"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		vulnerabilityTypeSeverityPropEnum = append(vulnerabilityTypeSeverityPropEnum, v)
	}
}

const (

	// VulnerabilitySeverityCRITICAL captures enum value "CRITICAL"
	VulnerabilitySeverityCRITICAL string = "CRITICAL"

	// VulnerabilitySeverityHIGH captures enum value "HIGH"
	VulnerabilitySeverityHIGH string = "HIGH"

	// VulnerabilitySeverityMEDIUM captures enum value "MEDIUM"
	VulnerabilitySeverityMEDIUM string = "MEDIUM"

	// VulnerabilitySeverityLOW captures enum value "LOW"
	VulnerabilitySeverityLOW string = "LOW"

	// VulnerabilitySeverityINFO captures enum value "INFO"
	VulnerabilitySeverityINFO string = "INFO"

	// VulnerabilitySeverityUNASSIGNED captures enum value "UNASSIGNED"
	VulnerabilitySeverityUNASSIGNED string = "UNASSIGNED"
)

// prop value enum
func (m *Vulnerability) validateSeverityEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, vulnerabilityTypeSeverityPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Vulnerability) validateSeverity(formats strfmt.Registry) error {
	if swag.IsZero(m.Severity) { // not required
		return nil
	}

	// value enum
	if err := m.validateSeverityEnum("severity", "body", m.Severity); err != nil {
		return err
	}

	return nil
}

func (m *Vulnerability) validateSource(formats strfmt.Registry) error {
	if swag.IsZero(m.Source) { // not required
		return nil
	}

	if err := validate.MinLength("source", "body", m.Source, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("source", "body", m.Source, 255); err != nil {
		return err
	}

	return nil
}

func (m *Vulnerability) validateUpdated(formats strfmt.Registry) error {
	if swag.IsZero(m.Updated) { // not required
		return nil
	}

	if err := validate.FormatOf("updated", "body", "date-time", m.Updated.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Vulnerability) validateUUID(formats strfmt.Registry) error {

	if err := validate.Required("uuid", "body", m.UUID); err != nil {
		return err
	}

	if err := validate.FormatOf("uuid", "body", "uuid", m.UUID.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Vulnerability) validateVulnID(formats strfmt.Registry) error {
	if swag.IsZero(m.VulnID) { // not required
		return nil
	}

	if err := validate.MinLength("vulnId", "body", m.VulnID, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("vulnId", "body", m.VulnID, 255); err != nil {
		return err
	}

	return nil
}

func (m *Vulnerability) validateVulnerableSoftware(formats strfmt.Registry) error {
	if swag.IsZero(m.VulnerableSoftware) { // not required
		return nil
	}

	for i := 0; i < len(m.VulnerableSoftware); i++ {
		if swag.IsZero(m.VulnerableSoftware[i]) { // not required
			continue
		}

		if m.VulnerableSoftware[i] != nil {
			if err := m.VulnerableSoftware[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vulnerableSoftware" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this vulnerability based on the context it is used
func (m *Vulnerability) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateComponents(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCwe(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateFindingAttribution(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateServiceComponents(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVulnerableSoftware(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Vulnerability) contextValidateComponents(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Components); i++ {

		if m.Components[i] != nil {
			if err := m.Components[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("components" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Vulnerability) contextValidateCwe(ctx context.Context, formats strfmt.Registry) error {

	if m.Cwe != nil {
		if err := m.Cwe.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("cwe")
			}
			return err
		}
	}

	return nil
}

func (m *Vulnerability) contextValidateFindingAttribution(ctx context.Context, formats strfmt.Registry) error {

	if m.FindingAttribution != nil {
		if err := m.FindingAttribution.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("findingAttribution")
			}
			return err
		}
	}

	return nil
}

func (m *Vulnerability) contextValidateServiceComponents(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ServiceComponents); i++ {

		if m.ServiceComponents[i] != nil {
			if err := m.ServiceComponents[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("serviceComponents" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Vulnerability) contextValidateVulnerableSoftware(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.VulnerableSoftware); i++ {

		if m.VulnerableSoftware[i] != nil {
			if err := m.VulnerableSoftware[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("vulnerableSoftware" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Vulnerability) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Vulnerability) UnmarshalBinary(b []byte) error {
	var res Vulnerability
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
