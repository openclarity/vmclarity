// Copyright Â© 2022 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package util

import (
	log "github.com/sirupsen/logrus"
	"strings"

	"github.com/openclarity/vmclarity/api/models"
)

const (
	detectedMalwareClamLineWordCount = 3 // A clam detected malware line should be in the following format: <path> <malware-description> FOUND
	maxClamMalwareDescSections       = 3 // In some cases, the malware description includes the platform (i.e: Win.Trojan.Generic-123)
	clamDetectedMalwarePathPosition  = 0
	clamDetectedMalwareDescPosition  = 1
	longClamAVMalwareTypePosition    = 1
	malwareDetectedIndication        = "FOUND" // When a line in a clam scan includes the word "FOUND", it describes a malware detection
)

func ParseMalwareScanOutput(clamOutput string) *[]models.Malware {
	lines := strings.Split(clamOutput, "\n")

	var malwareInfoList []models.Malware

	for _, line := range lines {
		// Check if the line ends with "FOUND" to identify malware detections
		if !strings.Contains(line, malwareDetectedIndication) {
			continue
		}

		words := strings.Fields(line)

		// If the line has less than 3 words in it, it can't be a malware detection, so it's skipped
		if len(words) < detectedMalwareClamLineWordCount {
			log.Debugf("omitting invalid clam line: %s", words)
			continue
		}

		malwareInfo := extractMalwareInfo(words)

		malwareInfoList = append(malwareInfoList, models.Malware{
			MalwareInfo: malwareInfo,
		})
	}
	return &malwareInfoList
}

func extractMalwareInfo(words []string) *models.MalwareInfo {
	// Extract the file path from the words
	filePath := strings.TrimSuffix(words[clamDetectedMalwarePathPosition], ":")

	// Extract the malware name and type from the words
	malwareDesc := words[clamDetectedMalwareDescPosition]
	splitMalwareDesc := strings.SplitN(malwareDesc, ".", maxClamMalwareDescSections)
	var malwareType models.MalwareType

	malwareTypeIndex := 0
	if len(splitMalwareDesc) == maxClamMalwareDescSections {
		malwareTypeIndex = longClamAVMalwareTypePosition
	}

	malwareTypeStr := strings.ToUpper(splitMalwareDesc[malwareTypeIndex])
	if !IsMalwareTypeValid(malwareTypeStr) {
		log.Debugf("invalid malware type: %s", malwareTypeStr)
		return nil
	}
	malwareType = models.MalwareType(malwareTypeStr)
	malwareName := splitMalwareDesc[len(splitMalwareDesc)-1]

	return &models.MalwareInfo{
		MalwareName: &malwareName,
		MalwareType: &malwareType,
		Path:        &filePath,
	}
}

func IsMalwareTypeValid(malwareType string) bool {
	switch models.MalwareType(malwareType) {
	case models.ADWARE, models.RANSOMWARE, models.BACKDOOR, models.SPYWARE, models.TROJAN,
		models.VIRUS, models.PHISHING, models.WORM:
		return true
	default:
		return false
	}
}
