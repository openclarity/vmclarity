// Package plugin provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.2.0 DO NOT EDIT.
package plugin

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Post config to the scanner plugin and start scanner.
	// (POST /config)
	PostConfig(ctx echo.Context) error
	// Check the scanner plugin's health.
	// (GET /healthz)
	GetHealthz(ctx echo.Context) error
	// Get metadata from the scanner plugin.
	// (GET /metadata)
	GetMetadata(ctx echo.Context) error
	// Get the status of the scanner.
	// (GET /status)
	GetStatus(ctx echo.Context) error
	// Stop the scanner.
	// (POST /stop)
	PostStop(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostConfig converts echo context to params.
func (w *ServerInterfaceWrapper) PostConfig(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostConfig(ctx)
	return err
}

// GetHealthz converts echo context to params.
func (w *ServerInterfaceWrapper) GetHealthz(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetHealthz(ctx)
	return err
}

// GetMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) GetMetadata(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMetadata(ctx)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// PostStop converts echo context to params.
func (w *ServerInterfaceWrapper) PostStop(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostStop(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/config", wrapper.PostConfig)
	router.GET(baseURL+"/healthz", wrapper.GetHealthz)
	router.GET(baseURL+"/metadata", wrapper.GetMetadata)
	router.GET(baseURL+"/status", wrapper.GetStatus)
	router.POST(baseURL+"/stop", wrapper.PostStop)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
