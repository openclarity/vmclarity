// Copyright Â© 2022 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package util

import (
	"strings"

	"github.com/openclarity/vmclarity/api/models"
	"github.com/openclarity/vmclarity/shared/pkg/families/malware"
)

const (
	detectedMalwareClamLineWordCount = 3 // A clam detected malware line should be in the following format: <path> <malware-description> <FOUND/OK>
	maxClamMalwareDescSections       = 3 // In some cases, the malware description includes the platform (i.e: Win.Trojan.Generic-123)
	clamDetectedMalwarePathPosition  = 0
	clamDetectedMalwareDescPosition  = 1
	longClamAVMalwareTypePosition    = 1
	malwareDetectedIndication        = "FOUND" // When a line in a clam scan includes the word "FOUND", it describes a malware detection
)

func ParseMalwareScanOutput(malwareResults *malware.Results) []models.Malware {
	lines := strings.Split(malwareResults.ClamAVOutput, "\n")

	var malwareInfoList []models.Malware

	for _, line := range lines {
		// Check if the line starts with "FOUND" to identify malware detections
		if strings.Contains(line, malwareDetectedIndication) {
			words := strings.Fields(line)

			// If the line has less than 3 words in it, it can't be a malware detection, so we skip it
			if len(words) < detectedMalwareClamLineWordCount {
				continue
			}

			malwareInfo := extractMalwareInfo(words)

			// Add the malware info to malware info list
			malwareInfoList = append(malwareInfoList, models.Malware{
				MalwareInfo: malwareInfo,
			})
		}
	}
	return malwareInfoList
}

func extractMalwareInfo(words []string) *models.MalwareInfo {
	// Extract the file path from the words
	filePath := strings.TrimSuffix(words[clamDetectedMalwarePathPosition], ":")

	// Extract the malware name and type from the words
	malwareDesc := words[clamDetectedMalwareDescPosition]
	splitMalwareDesc := strings.SplitN(malwareDesc, ".", maxClamMalwareDescSections)
	var malwareType models.MalwareType

	malwareTypeIndex := 0
	if len(splitMalwareDesc) == maxClamMalwareDescSections {
		malwareTypeIndex = longClamAVMalwareTypePosition
	}

	malwareType = models.MalwareType(strings.ToUpper(splitMalwareDesc[malwareTypeIndex]))
	malwareName := splitMalwareDesc[len(splitMalwareDesc)-1]

	return &models.MalwareInfo{
		MalwareName: &malwareName,
		MalwareType: &malwareType,
		Path:        &filePath,
	}
}
