// Package models provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.3 DO NOT EDIT.
package models

import (
	"encoding/json"
	"errors"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for CloudProvider.
const (
	AWS CloudProvider = "AWS"
)

// Defines values for MalwareType.
const (
	ADWARE     MalwareType = "ADWARE"
	RANSOMWARE MalwareType = "RANSOMWARE"
	SPYWARE    MalwareType = "SPYWARE"
	TROJAN     MalwareType = "TROJAN"
	VIRUS      MalwareType = "VIRUS"
	WORM       MalwareType = "WORM"
)

// Defines values for RootkitType.
const (
	APPLICATION RootkitType = "APPLICATION"
	FIRMWARE    RootkitType = "FIRMWARE"
	KERNEL      RootkitType = "KERNEL"
	MEMORY      RootkitType = "MEMORY"
)

// Defines values for ScanState.
const (
	ScanStateDiscovered ScanState = "Discovered"
	ScanStateDone       ScanState = "Done"
	ScanStateFailed     ScanState = "Failed"
	ScanStateInProgress ScanState = "InProgress"
	ScanStatePending    ScanState = "Pending"
)

// Defines values for ScanStateReason.
const (
	ScanStateReasonAborted                     ScanStateReason = "Aborted"
	ScanStateReasonDiscoveryFailed             ScanStateReason = "DiscoveryFailed"
	ScanStateReasonNothingToScan               ScanStateReason = "NothingToScan"
	ScanStateReasonOneOrMoreTargetFailedToScan ScanStateReason = "OneOrMoreTargetFailedToScan"
	ScanStateReasonSuccess                     ScanStateReason = "Success"
	ScanStateReasonTimedOut                    ScanStateReason = "TimedOut"
	ScanStateReasonUnexpected                  ScanStateReason = "Unexpected"
)

// Defines values for ScanDataState.
const (
	ScanDataStateDiscovered ScanDataState = "Discovered"
	ScanDataStateDone       ScanDataState = "Done"
	ScanDataStateFailed     ScanDataState = "Failed"
	ScanDataStateInProgress ScanDataState = "InProgress"
	ScanDataStatePending    ScanDataState = "Pending"
)

// Defines values for ScanDataStateReason.
const (
	ScanDataStateReasonAborted                     ScanDataStateReason = "Aborted"
	ScanDataStateReasonDiscoveryFailed             ScanDataStateReason = "DiscoveryFailed"
	ScanDataStateReasonNothingToScan               ScanDataStateReason = "NothingToScan"
	ScanDataStateReasonOneOrMoreTargetFailedToScan ScanDataStateReason = "OneOrMoreTargetFailedToScan"
	ScanDataStateReasonSuccess                     ScanDataStateReason = "Success"
	ScanDataStateReasonTimedOut                    ScanDataStateReason = "TimedOut"
	ScanDataStateReasonUnexpected                  ScanDataStateReason = "Unexpected"
)

// Defines values for ScanType.
const (
	EXPLOIT          ScanType = "EXPLOIT"
	MALWARE          ScanType = "MALWARE"
	MISCONFIGURATION ScanType = "MISCONFIGURATION"
	ROOTKIT          ScanType = "ROOTKIT"
	SBOM             ScanType = "SBOM"
	SECRET           ScanType = "SECRET"
	VULNERABILITY    ScanType = "VULNERABILITY"
)

// Defines values for TargetScanStateState.
const (
	ATTACHED   TargetScanStateState = "ATTACHED"
	DONE       TargetScanStateState = "DONE"
	INIT       TargetScanStateState = "INIT"
	INPROGRESS TargetScanStateState = "IN_PROGRESS"
	NOTSCANNED TargetScanStateState = "NOT_SCANNED"
)

// Defines values for VulnerabilitySeverity.
const (
	CRITICAL   VulnerabilitySeverity = "CRITICAL"
	HIGH       VulnerabilitySeverity = "HIGH"
	LOW        VulnerabilitySeverity = "LOW"
	MEDIUM     VulnerabilitySeverity = "MEDIUM"
	NEGLIGIBLE VulnerabilitySeverity = "NEGLIGIBLE"
)

// ApiResponse An object that is returned in all cases of failures.
type ApiResponse struct {
	Message *string `json:"message,omitempty"`
}

// AwsAccountScope AWS cloud account scope
type AwsAccountScope struct {
	ObjectType string       `json:"objectType"`
	Regions    *[]AwsRegion `json:"regions,omitempty"`
}

// AwsRegion AWS region
type AwsRegion struct {
	Name string    `json:"name"`
	Vpcs *[]AwsVPC `json:"vpcs,omitempty"`
}

// AwsScanScope The scope of a configured scan.
type AwsScanScope struct {
	// AllRegions Scan all regions, if set will override anything set in regions.
	AllRegions *bool `json:"allRegions,omitempty"`

	// InstanceTagExclusion VM instances will not be scanned if they contain all of these tags (even if they match instanceTagSelector). If empty, not taken into account.
	InstanceTagExclusion *[]Tag `json:"instanceTagExclusion,omitempty"`

	// InstanceTagSelector VM instances will be scanned if they contain all of these tags. If empty, not taken into account.
	InstanceTagSelector        *[]Tag       `json:"instanceTagSelector,omitempty"`
	ObjectType                 string       `json:"objectType"`
	Regions                    *[]AwsRegion `json:"regions,omitempty"`
	ShouldScanStoppedInstances *bool        `json:"shouldScanStoppedInstances,omitempty"`
}

// AwsSecurityGroup AWS security group
type AwsSecurityGroup struct {
	Id string `json:"id"`
}

// AwsVPC AWS VPC
type AwsVPC struct {
	Id             string              `json:"id"`
	SecurityGroups *[]AwsSecurityGroup `json:"securityGroups,omitempty"`
}

// ByDaysScheduleScanConfig defines model for ByDaysScheduleScanConfig.
type ByDaysScheduleScanConfig struct {
	DaysInterval *int       `json:"daysInterval,omitempty"`
	ObjectType   string     `json:"objectType"`
	TimeOfDay    *TimeOfDay `json:"timeOfDay,omitempty"`
}

// ByHoursScheduleScanConfig defines model for ByHoursScheduleScanConfig.
type ByHoursScheduleScanConfig struct {
	HoursInterval *int   `json:"hoursInterval,omitempty"`
	ObjectType    string `json:"objectType"`
}

// CloudProvider defines model for CloudProvider.
type CloudProvider string

// DirInfo defines model for DirInfo.
type DirInfo struct {
	DirName    *string `json:"dirName,omitempty"`
	Location   *string `json:"location,omitempty"`
	ObjectType string  `json:"objectType"`
}

// Exploit defines model for Exploit.
type Exploit struct {
	ExploitInfo *ExploitInfo `json:"exploitInfo,omitempty"`
	Id          *string      `json:"id,omitempty"`
}

// ExploitFindingInfo defines model for ExploitFindingInfo.
type ExploitFindingInfo struct {
	CveID       *string   `json:"cveID,omitempty"`
	Description *string   `json:"description,omitempty"`
	Name        *string   `json:"name,omitempty"`
	ObjectType  string    `json:"objectType"`
	SourceDB    *string   `json:"sourceDB,omitempty"`
	Title       *string   `json:"title,omitempty"`
	Urls        *[]string `json:"urls,omitempty"`
}

// ExploitInfo defines model for ExploitInfo.
type ExploitInfo struct {
	CveID       *string   `json:"cveID,omitempty"`
	Description *string   `json:"description,omitempty"`
	Name        *string   `json:"name,omitempty"`
	SourceDB    *string   `json:"sourceDB,omitempty"`
	Title       *string   `json:"title,omitempty"`
	Urls        *[]string `json:"urls,omitempty"`
}

// ExploitScan defines model for ExploitScan.
type ExploitScan struct {
	Exploits *[]Exploit `json:"exploits,omitempty"`
}

// ExploitsConfig defines model for ExploitsConfig.
type ExploitsConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// Finding defines model for Finding.
type Finding struct {
	// Asset Describes a relationship to a target which can be expanded.
	Asset       *TargetRelationship  `json:"asset,omitempty"`
	FindingInfo *Finding_FindingInfo `json:"findingInfo,omitempty"`

	// FoundOn When this finding was discovered by a scan
	FoundOn *time.Time `json:"foundOn,omitempty"`
	Id      *string    `json:"id,omitempty"`

	// InvalidatedOn When this finding was invalidated by a newer scan
	InvalidatedOn *time.Time `json:"invalidatedOn,omitempty"`

	// Scan Describes an expandable relationship to Scan object
	Scan *ScanRelationship `json:"scan,omitempty"`
}

// Finding_FindingInfo defines model for Finding.FindingInfo.
type Finding_FindingInfo struct {
	union json.RawMessage
}

// FindingExists defines model for FindingExists.
type FindingExists struct {
	Finding *Finding `json:"finding,omitempty"`

	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`
}

// Findings defines model for Findings.
type Findings struct {
	// Count Total scans count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of findings according to the given filters
	Items *[]Finding `json:"items,omitempty"`
}

// Malware defines model for Malware.
type Malware struct {
	Id          *string      `json:"id,omitempty"`
	MalwareInfo *MalwareInfo `json:"malwareInfo,omitempty"`
}

// MalwareConfig defines model for MalwareConfig.
type MalwareConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// MalwareFindingInfo defines model for MalwareFindingInfo.
type MalwareFindingInfo struct {
	MalwareName *string      `json:"malwareName,omitempty"`
	MalwareType *MalwareType `json:"malwareType,omitempty"`
	ObjectType  string       `json:"objectType"`

	// Path Path of the file that contains malware
	Path *string `json:"path,omitempty"`
}

// MalwareInfo defines model for MalwareInfo.
type MalwareInfo struct {
	MalwareName *string      `json:"malwareName,omitempty"`
	MalwareType *MalwareType `json:"malwareType,omitempty"`

	// Path Path of the file that contains malware
	Path *string `json:"path,omitempty"`
}

// MalwareScan defines model for MalwareScan.
type MalwareScan struct {
	Malware *[]Malware `json:"malware,omitempty"`
}

// MalwareType defines model for MalwareType.
type MalwareType string

// Misconfiguration defines model for Misconfiguration.
type Misconfiguration struct {
	Id                   *string               `json:"id,omitempty"`
	MisconfigurationInfo *MisconfigurationInfo `json:"misconfigurationInfo,omitempty"`
}

// MisconfigurationFindingInfo defines model for MisconfigurationFindingInfo.
type MisconfigurationFindingInfo struct {
	Description *string `json:"description,omitempty"`
	ObjectType  string  `json:"objectType"`

	// Path Path of the file that contains misconfigurations
	Path *string `json:"path,omitempty"`
}

// MisconfigurationInfo defines model for MisconfigurationInfo.
type MisconfigurationInfo struct {
	Description *string `json:"description,omitempty"`

	// Path Path of the file that contains misconfigurations
	Path *string `json:"path,omitempty"`
}

// MisconfigurationScan defines model for MisconfigurationScan.
type MisconfigurationScan struct {
	Misconfigurations *[]Misconfiguration `json:"misconfigurations,omitempty"`
}

// MisconfigurationsConfig defines model for MisconfigurationsConfig.
type MisconfigurationsConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// Package defines model for Package.
type Package struct {
	Id          *string      `json:"id,omitempty"`
	PackageInfo *PackageInfo `json:"packageInfo,omitempty"`
}

// PackageFindingInfo defines model for PackageFindingInfo.
type PackageFindingInfo struct {
	ObjectType     string  `json:"objectType"`
	PackageName    *string `json:"packageName,omitempty"`
	PackageVersion *string `json:"packageVersion,omitempty"`
}

// PackageInfo defines model for PackageInfo.
type PackageInfo struct {
	PackageName    *string `json:"packageName,omitempty"`
	PackageVersion *string `json:"packageVersion,omitempty"`
}

// PodInfo defines model for PodInfo.
type PodInfo struct {
	Location   *string `json:"location,omitempty"`
	ObjectType string  `json:"objectType"`
	PodName    *string `json:"podName,omitempty"`
}

// Rootkit defines model for Rootkit.
type Rootkit struct {
	Id          *string      `json:"id,omitempty"`
	RootkitInfo *RootkitInfo `json:"rootkitInfo,omitempty"`
}

// RootkitFindingInfo defines model for RootkitFindingInfo.
type RootkitFindingInfo struct {
	ObjectType string `json:"objectType"`

	// Path Path of the file that contains rootkit
	Path        *string      `json:"path,omitempty"`
	RootkitName *string      `json:"rootkitName,omitempty"`
	RootkitType *RootkitType `json:"rootkitType,omitempty"`
}

// RootkitInfo defines model for RootkitInfo.
type RootkitInfo struct {
	// Path Path of the file that contains rootkit
	Path        *string      `json:"path,omitempty"`
	RootkitName *string      `json:"rootkitName,omitempty"`
	RootkitType *RootkitType `json:"rootkitType,omitempty"`
}

// RootkitScan defines model for RootkitScan.
type RootkitScan struct {
	Rootkits *[]Rootkit `json:"rootkits,omitempty"`
}

// RootkitType defines model for RootkitType.
type RootkitType string

// RootkitsConfig defines model for RootkitsConfig.
type RootkitsConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// RuntimeScheduleScanConfigType defines model for RuntimeScheduleScanConfigType.
type RuntimeScheduleScanConfigType struct {
	union json.RawMessage
}

// SBOMConfig defines model for SBOMConfig.
type SBOMConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// SbomScan defines model for SbomScan.
type SbomScan struct {
	Packages *[]Package `json:"packages,omitempty"`
}

// Scan defines model for Scan.
type Scan struct {
	EndTime *time.Time `json:"endTime,omitempty"`
	Id      *string    `json:"id,omitempty"`

	// ScanConfig Describes a relationship to a scan config which can be expanded.
	ScanConfig *ScanConfigRelationship `json:"scanConfig,omitempty"`

	// ScanConfigSnapshot Fields for a ScanConfig so they can be shared between the ScanConfig,
	// ScanConfigRelationship and used for the ScanConfig snapshot in the
	// scan.
	ScanConfigSnapshot *ScanConfigData `json:"scanConfigSnapshot,omitempty"`
	StartTime          *time.Time      `json:"startTime,omitempty"`

	// State The lifecycle state of this scan.
	State *ScanState `json:"state,omitempty"`

	// StateMessage Human-readable message indicating details about the last state transition.
	StateMessage *string `json:"stateMessage,omitempty"`

	// StateReason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
	StateReason *ScanStateReason `json:"stateReason,omitempty"`

	// Summary A summary of the progress of a scan for informational purposes.
	Summary *ScanSummary `json:"summary,omitempty"`

	// TargetIDs List of target IDs that are targeted for scanning as part of this scan
	TargetIDs *[]string `json:"targetIDs,omitempty"`
}

// ScanState The lifecycle state of this scan.
type ScanState string

// ScanStateReason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
type ScanStateReason string

// ScanConfig defines model for ScanConfig.
type ScanConfig struct {
	Id *string `json:"id,omitempty"`

	// MaxParallelScanners The maximum number of scanners that can run in parallel for each scan
	MaxParallelScanners *int   `json:"maxParallelScanners,omitempty"`
	Name                string `json:"name"`

	// ScanFamiliesConfig The configuration of the scanner families within a scan config
	ScanFamiliesConfig *ScanFamiliesConfig            `json:"scanFamiliesConfig,omitempty"`
	Scheduled          *RuntimeScheduleScanConfigType `json:"scheduled,omitempty"`
	Scope              *ScanScopeType                 `json:"scope,omitempty"`
}

// ScanConfigData Fields for a ScanConfig so they can be shared between the ScanConfig,
// ScanConfigRelationship and used for the ScanConfig snapshot in the
// scan.
type ScanConfigData struct {
	// MaxParallelScanners The maximum number of scanners that can run in parallel for each scan
	MaxParallelScanners *int    `json:"maxParallelScanners,omitempty"`
	Name                *string `json:"name,omitempty"`

	// ScanFamiliesConfig The configuration of the scanner families within a scan config
	ScanFamiliesConfig *ScanFamiliesConfig            `json:"scanFamiliesConfig,omitempty"`
	Scheduled          *RuntimeScheduleScanConfigType `json:"scheduled,omitempty"`
	Scope              *ScanScopeType                 `json:"scope,omitempty"`
}

// ScanConfigExists defines model for ScanConfigExists.
type ScanConfigExists struct {
	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`

	// ScanConfig Describes a multi-target scheduled scan config.
	ScanConfig *ScanConfig `json:"scanConfig,omitempty"`
}

// ScanConfigRelationship defines model for ScanConfigRelationship.
type ScanConfigRelationship struct {
	Id                  string       `json:"id"`
	MaxParallelScanners *interface{} `json:"maxParallelScanners,omitempty"`
	Name                *interface{} `json:"name,omitempty"`
	ScanFamiliesConfig  *interface{} `json:"scanFamiliesConfig,omitempty"`
	Scheduled           *interface{} `json:"scheduled,omitempty"`
	Scope               *interface{} `json:"scope,omitempty"`
}

// ScanConfigs defines model for ScanConfigs.
type ScanConfigs struct {
	// Count Total scan config count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of scan configs according to the given filters and page. List length must be lower or equal to pageSize.
	Items *[]ScanConfig `json:"items,omitempty"`
}

// ScanData defines model for ScanData.
type ScanData struct {
	EndTime *time.Time `json:"endTime,omitempty"`

	// ScanConfig Describes a relationship to a scan config which can be expanded.
	ScanConfig *ScanConfigRelationship `json:"scanConfig,omitempty"`

	// ScanConfigSnapshot Fields for a ScanConfig so they can be shared between the ScanConfig,
	// ScanConfigRelationship and used for the ScanConfig snapshot in the
	// scan.
	ScanConfigSnapshot *ScanConfigData `json:"scanConfigSnapshot,omitempty"`
	StartTime          *time.Time      `json:"startTime,omitempty"`

	// State The lifecycle state of this scan.
	State *ScanDataState `json:"state,omitempty"`

	// StateMessage Human-readable message indicating details about the last state transition.
	StateMessage *string `json:"stateMessage,omitempty"`

	// StateReason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
	StateReason *ScanDataStateReason `json:"stateReason,omitempty"`

	// Summary A summary of the progress of a scan for informational purposes.
	Summary *ScanSummary `json:"summary,omitempty"`

	// TargetIDs List of target IDs that are targeted for scanning as part of this scan
	TargetIDs *[]string `json:"targetIDs,omitempty"`
}

// ScanDataState The lifecycle state of this scan.
type ScanDataState string

// ScanDataStateReason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
type ScanDataStateReason string

// ScanExists defines model for ScanExists.
type ScanExists struct {
	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`

	// Scan Describes a multi-target scheduled scan.
	Scan *Scan `json:"scan,omitempty"`
}

// ScanFamiliesConfig The configuration of the scanner families within a scan config
type ScanFamiliesConfig struct {
	Exploits          *ExploitsConfig          `json:"exploits,omitempty"`
	Malware           *MalwareConfig           `json:"malware,omitempty"`
	Misconfigurations *MisconfigurationsConfig `json:"misconfigurations,omitempty"`
	Rootkits          *RootkitsConfig          `json:"rootkits,omitempty"`
	Sbom              *SBOMConfig              `json:"sbom,omitempty"`
	Secrets           *SecretsConfig           `json:"secrets,omitempty"`
	Vulnerabilities   *VulnerabilitiesConfig   `json:"vulnerabilities,omitempty"`
}

// ScanFindingsSummary A summary of the scan findings.
type ScanFindingsSummary struct {
	TotalExploits          *int `json:"totalExploits,omitempty"`
	TotalMalware           *int `json:"totalMalware,omitempty"`
	TotalMisconfigurations *int `json:"totalMisconfigurations,omitempty"`
	TotalPackages          *int `json:"totalPackages,omitempty"`
	TotalRootkits          *int `json:"totalRootkits,omitempty"`
	TotalSecrets           *int `json:"totalSecrets,omitempty"`

	// TotalVulnerabilities A summary of number of vulnerabilities found per severity.
	TotalVulnerabilities *VulnerabilityScanSummary `json:"totalVulnerabilities,omitempty"`
}

// ScanRelationship defines model for ScanRelationship.
type ScanRelationship struct {
	EndTime            *interface{} `json:"endTime,omitempty"`
	Id                 string       `json:"id"`
	ScanConfig         *interface{} `json:"scanConfig,omitempty"`
	ScanConfigSnapshot *interface{} `json:"scanConfigSnapshot,omitempty"`
	StartTime          *interface{} `json:"startTime,omitempty"`
	State              *interface{} `json:"state,omitempty"`
	StateMessage       *interface{} `json:"stateMessage,omitempty"`
	StateReason        *interface{} `json:"stateReason,omitempty"`
	Summary            *interface{} `json:"summary,omitempty"`
	TargetIDs          *interface{} `json:"targetIDs,omitempty"`
}

// ScanScopeType defines model for ScanScopeType.
type ScanScopeType struct {
	union json.RawMessage
}

// ScanSummary defines model for ScanSummary.
type ScanSummary struct {
	JobsCompleted          *int `json:"jobsCompleted,omitempty"`
	JobsLeftToRun          *int `json:"jobsLeftToRun,omitempty"`
	TotalExploits          *int `json:"totalExploits,omitempty"`
	TotalMalware           *int `json:"totalMalware,omitempty"`
	TotalMisconfigurations *int `json:"totalMisconfigurations,omitempty"`
	TotalPackages          *int `json:"totalPackages,omitempty"`
	TotalRootkits          *int `json:"totalRootkits,omitempty"`
	TotalSecrets           *int `json:"totalSecrets,omitempty"`

	// TotalVulnerabilities A summary of number of vulnerabilities found per severity.
	TotalVulnerabilities *VulnerabilityScanSummary `json:"totalVulnerabilities,omitempty"`
}

// ScanType defines model for ScanType.
type ScanType string

// Scans defines model for Scans.
type Scans struct {
	// Count Total scans count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of scans according to the given filters and page. List length must be lower or equal to pageSize.
	Items *[]Scan `json:"items,omitempty"`
}

// ScopeType defines model for ScopeType.
type ScopeType struct {
	union json.RawMessage
}

// Scopes Scopes discovery
type Scopes struct {
	ScopeInfo *ScopeType `json:"scopeInfo,omitempty"`
}

// Secret defines model for Secret.
type Secret struct {
	Id         *string     `json:"id,omitempty"`
	SecretInfo *SecretInfo `json:"secretInfo,omitempty"`
}

// SecretFindingInfo defines model for SecretFindingInfo.
type SecretFindingInfo struct {
	Description *string `json:"description,omitempty"`
	EndLine     *int    `json:"endLine,omitempty"`

	// FilePath Name of the file containing the secret
	FilePath *string `json:"filePath,omitempty"`

	// Fingerprint Unique identification of the SecretInfo
	Fingerprint *string `json:"fingerprint,omitempty"`
	ObjectType  string  `json:"objectType"`
	StartLine   *int    `json:"startLine,omitempty"`
}

// SecretInfo defines model for SecretInfo.
type SecretInfo struct {
	Description *string `json:"description,omitempty"`
	EndLine     *int    `json:"endLine,omitempty"`

	// FilePath Name of the file containing the secret
	FilePath *string `json:"filePath,omitempty"`

	// Fingerprint Unique identification of the SecretInfo
	Fingerprint *string `json:"fingerprint,omitempty"`
	StartLine   *int    `json:"startLine,omitempty"`
}

// SecretScan defines model for SecretScan.
type SecretScan struct {
	Secrets *[]Secret `json:"secrets,omitempty"`
}

// SecretsConfig defines model for SecretsConfig.
type SecretsConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// SingleScheduleScanConfig defines model for SingleScheduleScanConfig.
type SingleScheduleScanConfig struct {
	ObjectType    string    `json:"objectType"`
	OperationTime time.Time `json:"operationTime"`
}

// SuccessResponse An object that is returned in cases of success that returns nothing.
type SuccessResponse struct {
	Message *string `json:"message,omitempty"`
}

// Tag AWS tag
type Tag struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

// Target defines model for Target.
type Target struct {
	Id *string `json:"id,omitempty"`

	// ScansCount Total number of scans that have ever run for this target
	ScansCount *int `json:"scansCount,omitempty"`

	// Summary A summary of the scan findings.
	Summary    *ScanFindingsSummary `json:"summary,omitempty"`
	TargetInfo TargetType           `json:"targetInfo"`
}

// TargetCommon defines model for TargetCommon.
type TargetCommon struct {
	// ScansCount Total number of scans that have ever run for this target
	ScansCount *int `json:"scansCount,omitempty"`

	// Summary A summary of the scan findings.
	Summary    *ScanFindingsSummary `json:"summary,omitempty"`
	TargetInfo *TargetType          `json:"targetInfo,omitempty"`
}

// TargetExists defines model for TargetExists.
type TargetExists struct {
	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`

	// Target Describes a target object.
	Target *Target `json:"target,omitempty"`
}

// TargetRelationship defines model for TargetRelationship.
type TargetRelationship struct {
	Id        string       `json:"id"`
	ScanCount *interface{} `json:"scanCount,omitempty"`

	// ScansCount Total number of scans that have ever run for this target
	ScansCount *int         `json:"scansCount,omitempty"`
	Summary    *interface{} `json:"summary,omitempty"`
	TargetInfo *interface{} `json:"targetInfo,omitempty"`
}

// TargetScanResult defines model for TargetScanResult.
type TargetScanResult struct {
	Exploits          *ExploitScan          `json:"exploits,omitempty"`
	Id                *string               `json:"id,omitempty"`
	Malware           *MalwareScan          `json:"malware,omitempty"`
	Misconfigurations *MisconfigurationScan `json:"misconfigurations,omitempty"`
	Rootkits          *RootkitScan          `json:"rootkits,omitempty"`
	Sboms             *SbomScan             `json:"sboms,omitempty"`

	// Scan Describes an expandable relationship to Scan object
	Scan    ScanRelationship  `json:"scan"`
	Secrets *SecretScan       `json:"secrets,omitempty"`
	Status  *TargetScanStatus `json:"status,omitempty"`

	// Summary A summary of the scan findings.
	Summary *ScanFindingsSummary `json:"summary,omitempty"`

	// Target Describes a relationship to a target which can be expanded.
	Target          TargetRelationship `json:"target"`
	Vulnerabilities *VulnerabilityScan `json:"vulnerabilities,omitempty"`
}

// TargetScanResultExists defines model for TargetScanResultExists.
type TargetScanResultExists struct {
	// Message Describes which unique constraint combination causes the conflict.
	Message          *string           `json:"message,omitempty"`
	TargetScanResult *TargetScanResult `json:"targetScanResult,omitempty"`
}

// TargetScanResults defines model for TargetScanResults.
type TargetScanResults struct {
	// Count Total scan results count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of scan results according to the given filters and page. List length must be lower or equal to pageSize.
	Items *[]TargetScanResult `json:"items,omitempty"`
}

// TargetScanState defines model for TargetScanState.
type TargetScanState struct {
	Errors *[]string             `json:"errors,omitempty"`
	State  *TargetScanStateState `json:"state,omitempty"`
}

// TargetScanStateState defines model for TargetScanState.State.
type TargetScanStateState string

// TargetScanStatus defines model for TargetScanStatus.
type TargetScanStatus struct {
	Exploits          *TargetScanState `json:"exploits,omitempty"`
	General           *TargetScanState `json:"general,omitempty"`
	Malware           *TargetScanState `json:"malware,omitempty"`
	Misconfigurations *TargetScanState `json:"misconfigurations,omitempty"`
	Rootkits          *TargetScanState `json:"rootkits,omitempty"`
	Sbom              *TargetScanState `json:"sbom,omitempty"`
	Secrets           *TargetScanState `json:"secrets,omitempty"`
	Vulnerabilities   *TargetScanState `json:"vulnerabilities,omitempty"`
}

// TargetType defines model for TargetType.
type TargetType struct {
	union json.RawMessage
}

// Targets defines model for Targets.
type Targets struct {
	// Count Total targets count according the given filters
	Count *int `json:"count,omitempty"`

	// Items List of targets in the given filters and page. List length must be lower or equal to pageSize.
	Items *[]Target `json:"items,omitempty"`
}

// TimeOfDay defines model for TimeOfDay.
type TimeOfDay struct {
	Hour   *int `json:"hour,omitempty"`
	Minute *int `json:"minute,omitempty"`
}

// VMInfo defines model for VMInfo.
type VMInfo struct {
	InstanceID       string         `json:"instanceID"`
	InstanceProvider *CloudProvider `json:"instanceProvider,omitempty"`
	Location         string         `json:"location"`
	ObjectType       string         `json:"objectType"`
}

// VulnerabilitiesConfig defines model for VulnerabilitiesConfig.
type VulnerabilitiesConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// Vulnerability defines model for Vulnerability.
type Vulnerability struct {
	Id                *string            `json:"id,omitempty"`
	VulnerabilityInfo *VulnerabilityInfo `json:"vulnerabilityInfo,omitempty"`
}

// VulnerabilityFindingInfo defines model for VulnerabilityFindingInfo.
type VulnerabilityFindingInfo struct {
	Description       *string                `json:"description,omitempty"`
	ObjectType        string                 `json:"objectType"`
	Severity          *VulnerabilitySeverity `json:"severity,omitempty"`
	VulnerabilityName *string                `json:"vulnerabilityName,omitempty"`
}

// VulnerabilityInfo defines model for VulnerabilityInfo.
type VulnerabilityInfo struct {
	Description       *string                `json:"description,omitempty"`
	Severity          *VulnerabilitySeverity `json:"severity,omitempty"`
	VulnerabilityName *string                `json:"vulnerabilityName,omitempty"`
}

// VulnerabilityScan defines model for VulnerabilityScan.
type VulnerabilityScan struct {
	Vulnerabilities *[]Vulnerability `json:"vulnerabilities,omitempty"`
}

// VulnerabilityScanSummary A summary of number of vulnerabilities found per severity.
type VulnerabilityScanSummary struct {
	TotalCriticalVulnerabilities   *int `json:"totalCriticalVulnerabilities,omitempty"`
	TotalHighVulnerabilities       *int `json:"totalHighVulnerabilities,omitempty"`
	TotalLowVulnerabilities        *int `json:"totalLowVulnerabilities,omitempty"`
	TotalMediumVulnerabilities     *int `json:"totalMediumVulnerabilities,omitempty"`
	TotalNegligibleVulnerabilities *int `json:"totalNegligibleVulnerabilities,omitempty"`
}

// VulnerabilitySeverity defines model for VulnerabilitySeverity.
type VulnerabilitySeverity string

// WeeklyScheduleScanConfig defines model for WeeklyScheduleScanConfig.
type WeeklyScheduleScanConfig struct {
	// DayInWeek 1 - 7 which represents sun- sat
	DayInWeek  *int       `json:"dayInWeek,omitempty"`
	ObjectType string     `json:"objectType"`
	TimeOfDay  *TimeOfDay `json:"timeOfDay,omitempty"`
}

// FindingID defines model for findingID.
type FindingID = string

// OdataCount defines model for odataCount.
type OdataCount = bool

// OdataExpand defines model for odataExpand.
type OdataExpand = string

// OdataFilter defines model for odataFilter.
type OdataFilter = string

// OrderBy defines model for odataOrderBy.
type OrderBy = string

// OdataSelect defines model for odataSelect.
type OdataSelect = string

// OdataSkip defines model for odataSkip.
type OdataSkip = int

// OdataTop defines model for odataTop.
type OdataTop = int

// ScanConfigID defines model for scanConfigID.
type ScanConfigID = string

// ScanID defines model for scanID.
type ScanID = string

// ScanResultID defines model for scanResultID.
type ScanResultID = string

// TargetID defines model for targetID.
type TargetID = string

// Success An object that is returned in cases of success that returns nothing.
type Success = SuccessResponse

// UnknownError An object that is returned in all cases of failures.
type UnknownError = ApiResponse

// GetDiscoveryScopesParams defines parameters for GetDiscoveryScopes.
type GetDiscoveryScopesParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetFindingsParams defines parameters for GetFindings.
type GetFindingsParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetFindingsFindingIDParams defines parameters for GetFindingsFindingID.
type GetFindingsFindingIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// GetScanConfigsParams defines parameters for GetScanConfigs.
type GetScanConfigsParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetScanConfigsScanConfigIDParams defines parameters for GetScanConfigsScanConfigID.
type GetScanConfigsScanConfigIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// GetScanResultsParams defines parameters for GetScanResults.
type GetScanResultsParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetScanResultsScanResultIDParams defines parameters for GetScanResultsScanResultID.
type GetScanResultsScanResultIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// GetScansParams defines parameters for GetScans.
type GetScansParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetScansScanIDParams defines parameters for GetScansScanID.
type GetScansScanIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// GetTargetsParams defines parameters for GetTargets.
type GetTargetsParams struct {
	Filter  *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select  *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count   *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top     *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip    *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand  *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
	OrderBy *OrderBy     `form:"$orderby,omitempty" json:"$orderby,omitempty"`
}

// GetTargetsTargetIDParams defines parameters for GetTargetsTargetID.
type GetTargetsTargetIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// PutDiscoveryScopesJSONRequestBody defines body for PutDiscoveryScopes for application/json ContentType.
type PutDiscoveryScopesJSONRequestBody = Scopes

// PostFindingsJSONRequestBody defines body for PostFindings for application/json ContentType.
type PostFindingsJSONRequestBody = Finding

// PatchFindingsFindingIDJSONRequestBody defines body for PatchFindingsFindingID for application/json ContentType.
type PatchFindingsFindingIDJSONRequestBody = Finding

// PutFindingsFindingIDJSONRequestBody defines body for PutFindingsFindingID for application/json ContentType.
type PutFindingsFindingIDJSONRequestBody = Finding

// PostScanConfigsJSONRequestBody defines body for PostScanConfigs for application/json ContentType.
type PostScanConfigsJSONRequestBody = ScanConfig

// PatchScanConfigsScanConfigIDJSONRequestBody defines body for PatchScanConfigsScanConfigID for application/json ContentType.
type PatchScanConfigsScanConfigIDJSONRequestBody = ScanConfig

// PutScanConfigsScanConfigIDJSONRequestBody defines body for PutScanConfigsScanConfigID for application/json ContentType.
type PutScanConfigsScanConfigIDJSONRequestBody = ScanConfig

// PostScanResultsJSONRequestBody defines body for PostScanResults for application/json ContentType.
type PostScanResultsJSONRequestBody = TargetScanResult

// PatchScanResultsScanResultIDJSONRequestBody defines body for PatchScanResultsScanResultID for application/json ContentType.
type PatchScanResultsScanResultIDJSONRequestBody = TargetScanResult

// PutScanResultsScanResultIDJSONRequestBody defines body for PutScanResultsScanResultID for application/json ContentType.
type PutScanResultsScanResultIDJSONRequestBody = TargetScanResult

// PostScansJSONRequestBody defines body for PostScans for application/json ContentType.
type PostScansJSONRequestBody = Scan

// PatchScansScanIDJSONRequestBody defines body for PatchScansScanID for application/json ContentType.
type PatchScansScanIDJSONRequestBody = Scan

// PutScansScanIDJSONRequestBody defines body for PutScansScanID for application/json ContentType.
type PutScansScanIDJSONRequestBody = Scan

// PostTargetsJSONRequestBody defines body for PostTargets for application/json ContentType.
type PostTargetsJSONRequestBody = Target

// PutTargetsTargetIDJSONRequestBody defines body for PutTargetsTargetID for application/json ContentType.
type PutTargetsTargetIDJSONRequestBody = Target

// AsPackageFindingInfo returns the union data inside the Finding_FindingInfo as a PackageFindingInfo
func (t Finding_FindingInfo) AsPackageFindingInfo() (PackageFindingInfo, error) {
	var body PackageFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided PackageFindingInfo
func (t *Finding_FindingInfo) FromPackageFindingInfo(v PackageFindingInfo) error {
	v.ObjectType = "Package"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided PackageFindingInfo
func (t *Finding_FindingInfo) MergePackageFindingInfo(v PackageFindingInfo) error {
	v.ObjectType = "Package"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsVulnerabilityFindingInfo returns the union data inside the Finding_FindingInfo as a VulnerabilityFindingInfo
func (t Finding_FindingInfo) AsVulnerabilityFindingInfo() (VulnerabilityFindingInfo, error) {
	var body VulnerabilityFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnerabilityFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided VulnerabilityFindingInfo
func (t *Finding_FindingInfo) FromVulnerabilityFindingInfo(v VulnerabilityFindingInfo) error {
	v.ObjectType = "Vulnerability"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnerabilityFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided VulnerabilityFindingInfo
func (t *Finding_FindingInfo) MergeVulnerabilityFindingInfo(v VulnerabilityFindingInfo) error {
	v.ObjectType = "Vulnerability"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsMalwareFindingInfo returns the union data inside the Finding_FindingInfo as a MalwareFindingInfo
func (t Finding_FindingInfo) AsMalwareFindingInfo() (MalwareFindingInfo, error) {
	var body MalwareFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMalwareFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided MalwareFindingInfo
func (t *Finding_FindingInfo) FromMalwareFindingInfo(v MalwareFindingInfo) error {
	v.ObjectType = "Malware"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMalwareFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided MalwareFindingInfo
func (t *Finding_FindingInfo) MergeMalwareFindingInfo(v MalwareFindingInfo) error {
	v.ObjectType = "Malware"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsSecretFindingInfo returns the union data inside the Finding_FindingInfo as a SecretFindingInfo
func (t Finding_FindingInfo) AsSecretFindingInfo() (SecretFindingInfo, error) {
	var body SecretFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecretFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided SecretFindingInfo
func (t *Finding_FindingInfo) FromSecretFindingInfo(v SecretFindingInfo) error {
	v.ObjectType = "Secret"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecretFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided SecretFindingInfo
func (t *Finding_FindingInfo) MergeSecretFindingInfo(v SecretFindingInfo) error {
	v.ObjectType = "Secret"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsMisconfigurationFindingInfo returns the union data inside the Finding_FindingInfo as a MisconfigurationFindingInfo
func (t Finding_FindingInfo) AsMisconfigurationFindingInfo() (MisconfigurationFindingInfo, error) {
	var body MisconfigurationFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMisconfigurationFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided MisconfigurationFindingInfo
func (t *Finding_FindingInfo) FromMisconfigurationFindingInfo(v MisconfigurationFindingInfo) error {
	v.ObjectType = "Misconfiguration"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMisconfigurationFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided MisconfigurationFindingInfo
func (t *Finding_FindingInfo) MergeMisconfigurationFindingInfo(v MisconfigurationFindingInfo) error {
	v.ObjectType = "Misconfiguration"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsRootkitFindingInfo returns the union data inside the Finding_FindingInfo as a RootkitFindingInfo
func (t Finding_FindingInfo) AsRootkitFindingInfo() (RootkitFindingInfo, error) {
	var body RootkitFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRootkitFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided RootkitFindingInfo
func (t *Finding_FindingInfo) FromRootkitFindingInfo(v RootkitFindingInfo) error {
	v.ObjectType = "Rootkit"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRootkitFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided RootkitFindingInfo
func (t *Finding_FindingInfo) MergeRootkitFindingInfo(v RootkitFindingInfo) error {
	v.ObjectType = "Rootkit"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsExploitFindingInfo returns the union data inside the Finding_FindingInfo as a ExploitFindingInfo
func (t Finding_FindingInfo) AsExploitFindingInfo() (ExploitFindingInfo, error) {
	var body ExploitFindingInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExploitFindingInfo overwrites any union data inside the Finding_FindingInfo as the provided ExploitFindingInfo
func (t *Finding_FindingInfo) FromExploitFindingInfo(v ExploitFindingInfo) error {
	v.ObjectType = "Exploit"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExploitFindingInfo performs a merge with any union data inside the Finding_FindingInfo, using the provided ExploitFindingInfo
func (t *Finding_FindingInfo) MergeExploitFindingInfo(v ExploitFindingInfo) error {
	v.ObjectType = "Exploit"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Finding_FindingInfo) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"objectType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Finding_FindingInfo) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "Exploit":
		return t.AsExploitFindingInfo()
	case "Malware":
		return t.AsMalwareFindingInfo()
	case "Misconfiguration":
		return t.AsMisconfigurationFindingInfo()
	case "Package":
		return t.AsPackageFindingInfo()
	case "Rootkit":
		return t.AsRootkitFindingInfo()
	case "Secret":
		return t.AsSecretFindingInfo()
	case "Vulnerability":
		return t.AsVulnerabilityFindingInfo()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Finding_FindingInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Finding_FindingInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSingleScheduleScanConfig returns the union data inside the RuntimeScheduleScanConfigType as a SingleScheduleScanConfig
func (t RuntimeScheduleScanConfigType) AsSingleScheduleScanConfig() (SingleScheduleScanConfig, error) {
	var body SingleScheduleScanConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSingleScheduleScanConfig overwrites any union data inside the RuntimeScheduleScanConfigType as the provided SingleScheduleScanConfig
func (t *RuntimeScheduleScanConfigType) FromSingleScheduleScanConfig(v SingleScheduleScanConfig) error {
	v.ObjectType = "SingleScheduleScanConfig"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSingleScheduleScanConfig performs a merge with any union data inside the RuntimeScheduleScanConfigType, using the provided SingleScheduleScanConfig
func (t *RuntimeScheduleScanConfigType) MergeSingleScheduleScanConfig(v SingleScheduleScanConfig) error {
	v.ObjectType = "SingleScheduleScanConfig"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsByHoursScheduleScanConfig returns the union data inside the RuntimeScheduleScanConfigType as a ByHoursScheduleScanConfig
func (t RuntimeScheduleScanConfigType) AsByHoursScheduleScanConfig() (ByHoursScheduleScanConfig, error) {
	var body ByHoursScheduleScanConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromByHoursScheduleScanConfig overwrites any union data inside the RuntimeScheduleScanConfigType as the provided ByHoursScheduleScanConfig
func (t *RuntimeScheduleScanConfigType) FromByHoursScheduleScanConfig(v ByHoursScheduleScanConfig) error {
	v.ObjectType = "ByHoursScheduleScanConfig"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeByHoursScheduleScanConfig performs a merge with any union data inside the RuntimeScheduleScanConfigType, using the provided ByHoursScheduleScanConfig
func (t *RuntimeScheduleScanConfigType) MergeByHoursScheduleScanConfig(v ByHoursScheduleScanConfig) error {
	v.ObjectType = "ByHoursScheduleScanConfig"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsByDaysScheduleScanConfig returns the union data inside the RuntimeScheduleScanConfigType as a ByDaysScheduleScanConfig
func (t RuntimeScheduleScanConfigType) AsByDaysScheduleScanConfig() (ByDaysScheduleScanConfig, error) {
	var body ByDaysScheduleScanConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromByDaysScheduleScanConfig overwrites any union data inside the RuntimeScheduleScanConfigType as the provided ByDaysScheduleScanConfig
func (t *RuntimeScheduleScanConfigType) FromByDaysScheduleScanConfig(v ByDaysScheduleScanConfig) error {
	v.ObjectType = "ByDaysScheduleScanConfig"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeByDaysScheduleScanConfig performs a merge with any union data inside the RuntimeScheduleScanConfigType, using the provided ByDaysScheduleScanConfig
func (t *RuntimeScheduleScanConfigType) MergeByDaysScheduleScanConfig(v ByDaysScheduleScanConfig) error {
	v.ObjectType = "ByDaysScheduleScanConfig"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsWeeklyScheduleScanConfig returns the union data inside the RuntimeScheduleScanConfigType as a WeeklyScheduleScanConfig
func (t RuntimeScheduleScanConfigType) AsWeeklyScheduleScanConfig() (WeeklyScheduleScanConfig, error) {
	var body WeeklyScheduleScanConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWeeklyScheduleScanConfig overwrites any union data inside the RuntimeScheduleScanConfigType as the provided WeeklyScheduleScanConfig
func (t *RuntimeScheduleScanConfigType) FromWeeklyScheduleScanConfig(v WeeklyScheduleScanConfig) error {
	v.ObjectType = "WeeklyScheduleScanConfig"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWeeklyScheduleScanConfig performs a merge with any union data inside the RuntimeScheduleScanConfigType, using the provided WeeklyScheduleScanConfig
func (t *RuntimeScheduleScanConfigType) MergeWeeklyScheduleScanConfig(v WeeklyScheduleScanConfig) error {
	v.ObjectType = "WeeklyScheduleScanConfig"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t RuntimeScheduleScanConfigType) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"objectType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RuntimeScheduleScanConfigType) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ByDaysScheduleScanConfig":
		return t.AsByDaysScheduleScanConfig()
	case "ByHoursScheduleScanConfig":
		return t.AsByHoursScheduleScanConfig()
	case "SingleScheduleScanConfig":
		return t.AsSingleScheduleScanConfig()
	case "WeeklyScheduleScanConfig":
		return t.AsWeeklyScheduleScanConfig()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RuntimeScheduleScanConfigType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RuntimeScheduleScanConfigType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAwsScanScope returns the union data inside the ScanScopeType as a AwsScanScope
func (t ScanScopeType) AsAwsScanScope() (AwsScanScope, error) {
	var body AwsScanScope
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAwsScanScope overwrites any union data inside the ScanScopeType as the provided AwsScanScope
func (t *ScanScopeType) FromAwsScanScope(v AwsScanScope) error {
	v.ObjectType = "AwsScanScope"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAwsScanScope performs a merge with any union data inside the ScanScopeType, using the provided AwsScanScope
func (t *ScanScopeType) MergeAwsScanScope(v AwsScanScope) error {
	v.ObjectType = "AwsScanScope"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ScanScopeType) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"objectType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ScanScopeType) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "AwsScanScope":
		return t.AsAwsScanScope()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ScanScopeType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScanScopeType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAwsAccountScope returns the union data inside the ScopeType as a AwsAccountScope
func (t ScopeType) AsAwsAccountScope() (AwsAccountScope, error) {
	var body AwsAccountScope
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAwsAccountScope overwrites any union data inside the ScopeType as the provided AwsAccountScope
func (t *ScopeType) FromAwsAccountScope(v AwsAccountScope) error {
	v.ObjectType = "AwsAccountScope"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAwsAccountScope performs a merge with any union data inside the ScopeType, using the provided AwsAccountScope
func (t *ScopeType) MergeAwsAccountScope(v AwsAccountScope) error {
	v.ObjectType = "AwsAccountScope"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ScopeType) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"objectType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ScopeType) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "AwsAccountScope":
		return t.AsAwsAccountScope()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ScopeType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScopeType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVMInfo returns the union data inside the TargetType as a VMInfo
func (t TargetType) AsVMInfo() (VMInfo, error) {
	var body VMInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMInfo overwrites any union data inside the TargetType as the provided VMInfo
func (t *TargetType) FromVMInfo(v VMInfo) error {
	v.ObjectType = "VMInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMInfo performs a merge with any union data inside the TargetType, using the provided VMInfo
func (t *TargetType) MergeVMInfo(v VMInfo) error {
	v.ObjectType = "VMInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsPodInfo returns the union data inside the TargetType as a PodInfo
func (t TargetType) AsPodInfo() (PodInfo, error) {
	var body PodInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPodInfo overwrites any union data inside the TargetType as the provided PodInfo
func (t *TargetType) FromPodInfo(v PodInfo) error {
	v.ObjectType = "PodInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePodInfo performs a merge with any union data inside the TargetType, using the provided PodInfo
func (t *TargetType) MergePodInfo(v PodInfo) error {
	v.ObjectType = "PodInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsDirInfo returns the union data inside the TargetType as a DirInfo
func (t TargetType) AsDirInfo() (DirInfo, error) {
	var body DirInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDirInfo overwrites any union data inside the TargetType as the provided DirInfo
func (t *TargetType) FromDirInfo(v DirInfo) error {
	v.ObjectType = "DirInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDirInfo performs a merge with any union data inside the TargetType, using the provided DirInfo
func (t *TargetType) MergeDirInfo(v DirInfo) error {
	v.ObjectType = "DirInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t TargetType) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"objectType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t TargetType) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "DirInfo":
		return t.AsDirInfo()
	case "PodInfo":
		return t.AsPodInfo()
	case "VMInfo":
		return t.AsVMInfo()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t TargetType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TargetType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
