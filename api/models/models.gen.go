// Package models provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.3 DO NOT EDIT.
package models

import (
	"encoding/json"
	"errors"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for CloudProvider.
const (
	AWS CloudProvider = "AWS"
)

// Defines values for MalwareType.
const (
	ADWARE     MalwareType = "ADWARE"
	RANSOMWARE MalwareType = "RANSOMWARE"
	SPYWARE    MalwareType = "SPYWARE"
	TROJAN     MalwareType = "TROJAN"
	VIRUS      MalwareType = "VIRUS"
	WORM       MalwareType = "WORM"
)

// Defines values for RootkitType.
const (
	APPLICATION RootkitType = "APPLICATION"
	FIRMWARE    RootkitType = "FIRMWARE"
	KERNEL      RootkitType = "KERNEL"
	MEMORY      RootkitType = "MEMORY"
)

// Defines values for ScanState.
const (
	Discovered ScanState = "Discovered"
	Done       ScanState = "Done"
	Failed     ScanState = "Failed"
	InProgress ScanState = "InProgress"
	Pending    ScanState = "Pending"
)

// Defines values for ScanStateReason.
const (
	ScanStateReasonAborted                     ScanStateReason = "Aborted"
	ScanStateReasonDiscoveryFailed             ScanStateReason = "DiscoveryFailed"
	ScanStateReasonNothingToScan               ScanStateReason = "NothingToScan"
	ScanStateReasonOneOrMoreTargetFailedToScan ScanStateReason = "OneOrMoreTargetFailedToScan"
	ScanStateReasonSuccess                     ScanStateReason = "Success"
	ScanStateReasonTimedOut                    ScanStateReason = "TimedOut"
	ScanStateReasonUnexpected                  ScanStateReason = "Unexpected"
)

// Defines values for ScanType.
const (
	EXPLOIT          ScanType = "EXPLOIT"
	MALWARE          ScanType = "MALWARE"
	MISCONFIGURATION ScanType = "MISCONFIGURATION"
	ROOTKIT          ScanType = "ROOTKIT"
	SBOM             ScanType = "SBOM"
	SECRET           ScanType = "SECRET"
	VULNERABILITY    ScanType = "VULNERABILITY"
)

// Defines values for TargetScanStateState.
const (
	ATTACHED   TargetScanStateState = "ATTACHED"
	DONE       TargetScanStateState = "DONE"
	INIT       TargetScanStateState = "INIT"
	INPROGRESS TargetScanStateState = "IN_PROGRESS"
	NOTSCANNED TargetScanStateState = "NOT_SCANNED"
)

// Defines values for VulnerabilitySeverity.
const (
	CRITICAL   VulnerabilitySeverity = "CRITICAL"
	HIGH       VulnerabilitySeverity = "HIGH"
	LOW        VulnerabilitySeverity = "LOW"
	MEDIUM     VulnerabilitySeverity = "MEDIUM"
	NEGLIGIBLE VulnerabilitySeverity = "NEGLIGIBLE"
)

// ApiResponse An object that is returned in all cases of failures.
type ApiResponse struct {
	Message *string `json:"message,omitempty"`
}

// AwsRegion AWS region
type AwsRegion struct {
	Id   *string   `json:"id,omitempty"`
	Name *string   `json:"name,omitempty"`
	Vpcs *[]AwsVPC `json:"vpcs,omitempty"`
}

// AwsScanScope The scope of a configured scan.
type AwsScanScope struct {
	All *bool `json:"all,omitempty"`

	// InstanceTagExclusion VM instances will not be scanned if they contain all of these tags (even if they match instanceTagSelector). If empty, not taken into account.
	InstanceTagExclusion *[]Tag `json:"instanceTagExclusion,omitempty"`

	// InstanceTagSelector VM instances will be scanned if they contain all of these tags. If empty, not taken into account.
	InstanceTagSelector        *[]Tag       `json:"instanceTagSelector,omitempty"`
	ObjectType                 string       `json:"objectType"`
	Regions                    *[]AwsRegion `json:"regions,omitempty"`
	ShouldScanStoppedInstances *bool        `json:"shouldScanStoppedInstances,omitempty"`
}

// AwsSecurityGroup AWS security group
type AwsSecurityGroup struct {
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// AwsVPC AWS VPC
type AwsVPC struct {
	Id             *string             `json:"id,omitempty"`
	Name           *string             `json:"name,omitempty"`
	SecurityGroups *[]AwsSecurityGroup `json:"securityGroups,omitempty"`
}

// ByDaysScheduleScanConfig defines model for ByDaysScheduleScanConfig.
type ByDaysScheduleScanConfig struct {
	DaysInterval *int       `json:"daysInterval,omitempty"`
	ObjectType   string     `json:"objectType"`
	TimeOfDay    *TimeOfDay `json:"timeOfDay,omitempty"`
}

// ByHoursScheduleScanConfig defines model for ByHoursScheduleScanConfig.
type ByHoursScheduleScanConfig struct {
	HoursInterval *int   `json:"hoursInterval,omitempty"`
	ObjectType    string `json:"objectType"`
}

// CloudProvider defines model for CloudProvider.
type CloudProvider string

// DirInfo defines model for DirInfo.
type DirInfo struct {
	DirName    *string `json:"dirName,omitempty"`
	Location   *string `json:"location,omitempty"`
	ObjectType string  `json:"objectType"`
}

// Exploit defines model for Exploit.
type Exploit struct {
	ExploitInfo *ExploitInfo `json:"exploitInfo,omitempty"`
	Id          *string      `json:"id,omitempty"`
}

// ExploitInfo defines model for ExploitInfo.
type ExploitInfo struct {
	CveID       *string   `json:"cveID,omitempty"`
	Description *string   `json:"description,omitempty"`
	Name        *string   `json:"name,omitempty"`
	SourceDB    *string   `json:"sourceDB,omitempty"`
	Title       *string   `json:"title,omitempty"`
	Urls        *[]string `json:"urls,omitempty"`
}

// ExploitScan defines model for ExploitScan.
type ExploitScan struct {
	Exploits *[]Exploit `json:"exploits,omitempty"`
}

// ExploitsConfig defines model for ExploitsConfig.
type ExploitsConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// Malware defines model for Malware.
type Malware struct {
	Id          *string      `json:"id,omitempty"`
	MalwareInfo *MalwareInfo `json:"malwareInfo,omitempty"`
}

// MalwareConfig defines model for MalwareConfig.
type MalwareConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// MalwareInfo defines model for MalwareInfo.
type MalwareInfo struct {
	MalwareName *string      `json:"malwareName,omitempty"`
	MalwareType *MalwareType `json:"malwareType,omitempty"`

	// Path Path of the file that contains malware
	Path *string `json:"path,omitempty"`
}

// MalwareScan defines model for MalwareScan.
type MalwareScan struct {
	Malware *[]Malware `json:"malware,omitempty"`
}

// MalwareType defines model for MalwareType.
type MalwareType string

// Misconfiguration defines model for Misconfiguration.
type Misconfiguration struct {
	Id                   *string               `json:"id,omitempty"`
	MisconfigurationInfo *MisconfigurationInfo `json:"misconfigurationInfo,omitempty"`
}

// MisconfigurationInfo defines model for MisconfigurationInfo.
type MisconfigurationInfo struct {
	Description *string `json:"description,omitempty"`

	// Path Path of the file that contains misconfigurations
	Path *string `json:"path,omitempty"`
}

// MisconfigurationScan defines model for MisconfigurationScan.
type MisconfigurationScan struct {
	Misconfigurations *[]Misconfiguration `json:"misconfigurations,omitempty"`
}

// MisconfigurationsConfig defines model for MisconfigurationsConfig.
type MisconfigurationsConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// Package defines model for Package.
type Package struct {
	Id          *string      `json:"id,omitempty"`
	PackageInfo *PackageInfo `json:"packageInfo,omitempty"`
}

// PackageInfo defines model for PackageInfo.
type PackageInfo struct {
	PackageName    *string `json:"packageName,omitempty"`
	PackageVersion *string `json:"packageVersion,omitempty"`
}

// PodInfo defines model for PodInfo.
type PodInfo struct {
	Location   *string `json:"location,omitempty"`
	ObjectType string  `json:"objectType"`
	PodName    *string `json:"podName,omitempty"`
}

// Rootkit defines model for Rootkit.
type Rootkit struct {
	Id          *string      `json:"id,omitempty"`
	RootkitInfo *RootkitInfo `json:"rootkitInfo,omitempty"`
}

// RootkitInfo defines model for RootkitInfo.
type RootkitInfo struct {
	// Path Path of the file that contains rootkit
	Path        *string      `json:"path,omitempty"`
	RootkitName *string      `json:"rootkitName,omitempty"`
	RootkitType *RootkitType `json:"rootkitType,omitempty"`
}

// RootkitScan defines model for RootkitScan.
type RootkitScan struct {
	Rootkits *[]Rootkit `json:"rootkits,omitempty"`
}

// RootkitType defines model for RootkitType.
type RootkitType string

// RootkitsConfig defines model for RootkitsConfig.
type RootkitsConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// RuntimeScheduleScanConfigType defines model for RuntimeScheduleScanConfigType.
type RuntimeScheduleScanConfigType struct {
	union json.RawMessage
}

// SBOMConfig defines model for SBOMConfig.
type SBOMConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// SbomScan defines model for SbomScan.
type SbomScan struct {
	Packages *[]Package `json:"packages,omitempty"`
}

// Scan Describes a multi-target scheduled scan.
type Scan struct {
	EndTime *time.Time `json:"endTime,omitempty"`
	Id      *string    `json:"id,omitempty"`

	// ScanConfig Describes a relationship to a scan config which can be expanded.
	ScanConfig *ScanConfigRelationship `json:"scanConfig,omitempty"`

	// ScanConfigSnapshot Fields for a ScanConfig so they can be shared between the ScanConfig,
	// ScanConfigRelationship and used for the ScanConfig snapshot in the
	// scan.
	ScanConfigSnapshot *ScanConfigData `json:"scanConfigSnapshot,omitempty"`
	StartTime          *time.Time      `json:"startTime,omitempty"`

	// State The lifecycle state of this scan.
	State *ScanState `json:"state,omitempty"`

	// StateMessage Human-readable message indicating details about the last state transition.
	StateMessage *string `json:"stateMessage,omitempty"`

	// StateReason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
	StateReason *ScanStateReason `json:"stateReason,omitempty"`

	// Summary A summary of the progress of a scan for informational purposes.
	Summary *ScanSummary `json:"summary,omitempty"`

	// TargetIDs List of target IDs that are targeted for scanning as part of this scan
	TargetIDs *[]string `json:"targetIDs,omitempty"`
}

// ScanState The lifecycle state of this scan.
type ScanState string

// ScanStateReason Machine-readable, UpperCamelCase text indicating the reason for the condition's last transition.
type ScanStateReason string

// ScanConfig defines model for ScanConfig.
type ScanConfig struct {
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`

	// ScanFamiliesConfig The configuration of the scanner families within a scan config
	ScanFamiliesConfig *ScanFamiliesConfig            `json:"scanFamiliesConfig,omitempty"`
	Scheduled          *RuntimeScheduleScanConfigType `json:"scheduled,omitempty"`
	Scope              *ScanScopeType                 `json:"scope,omitempty"`
}

// ScanConfigData Fields for a ScanConfig so they can be shared between the ScanConfig,
// ScanConfigRelationship and used for the ScanConfig snapshot in the
// scan.
type ScanConfigData struct {
	Name *string `json:"name,omitempty"`

	// ScanFamiliesConfig The configuration of the scanner families within a scan config
	ScanFamiliesConfig *ScanFamiliesConfig            `json:"scanFamiliesConfig,omitempty"`
	Scheduled          *RuntimeScheduleScanConfigType `json:"scheduled,omitempty"`
	Scope              *ScanScopeType                 `json:"scope,omitempty"`
}

// ScanConfigExists defines model for ScanConfigExists.
type ScanConfigExists struct {
	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`

	// ScanConfig Describes a multi-target scheduled scan config.
	ScanConfig *ScanConfig `json:"scanConfig,omitempty"`
}

// ScanConfigRelationship defines model for ScanConfigRelationship.
type ScanConfigRelationship struct {
	Id                 string       `json:"id"`
	Name               *interface{} `json:"name,omitempty"`
	ScanFamiliesConfig *interface{} `json:"scanFamiliesConfig,omitempty"`
	Scheduled          *interface{} `json:"scheduled,omitempty"`
	Scope              *interface{} `json:"scope,omitempty"`
}

// ScanConfigs defines model for ScanConfigs.
type ScanConfigs struct {
	// Count Total scan config count according to the given filters
	Count *int `json:"count,omitempty"`

	// Items List of scan configs according to the given filters and page. List length must be lower or equal to pageSize.
	Items *[]ScanConfig `json:"items,omitempty"`
}

// ScanExists defines model for ScanExists.
type ScanExists struct {
	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`

	// Scan Describes a multi-target scheduled scan.
	Scan *Scan `json:"scan,omitempty"`
}

// ScanFamiliesConfig The configuration of the scanner families within a scan config
type ScanFamiliesConfig struct {
	Exploits          *ExploitsConfig          `json:"exploits,omitempty"`
	Malware           *MalwareConfig           `json:"malware,omitempty"`
	Misconfigurations *MisconfigurationsConfig `json:"misconfigurations,omitempty"`
	Rootkits          *RootkitsConfig          `json:"rootkits,omitempty"`
	Sbom              *SBOMConfig              `json:"sbom,omitempty"`
	Secrets           *SecretsConfig           `json:"secrets,omitempty"`
	Vulnerabilities   *VulnerabilitiesConfig   `json:"vulnerabilities,omitempty"`
}

// ScanScopeType defines model for ScanScopeType.
type ScanScopeType struct {
	union json.RawMessage
}

// ScanSummary A summary of the progress of a scan for informational purposes.
type ScanSummary struct {
	JobsCompleted          *int `json:"jobsCompleted,omitempty"`
	JobsLeftToRun          *int `json:"jobsLeftToRun,omitempty"`
	TotalExploits          *int `json:"totalExploits,omitempty"`
	TotalMalware           *int `json:"totalMalware,omitempty"`
	TotalMisconfigurations *int `json:"totalMisconfigurations,omitempty"`
	TotalPackages          *int `json:"totalPackages,omitempty"`
	TotalRootkits          *int `json:"totalRootkits,omitempty"`
	TotalSecrets           *int `json:"totalSecrets,omitempty"`

	// TotalVulnerabilities A summary of number of vulnerabilities found per severity.
	TotalVulnerabilities *VulnerabilityScanSummary `json:"totalVulnerabilities,omitempty"`
}

// ScanType defines model for ScanType.
type ScanType string

// Scans defines model for Scans.
type Scans struct {
	// Items List of scans according to the given filters and page. List length must be lower or equal to pageSize.
	Items *[]Scan `json:"items,omitempty"`

	// Total Total scans count according to the given filters
	Total *int `json:"total,omitempty"`
}

// Secret defines model for Secret.
type Secret struct {
	Id         *string     `json:"id,omitempty"`
	SecretInfo *SecretInfo `json:"secretInfo,omitempty"`
}

// SecretInfo defines model for SecretInfo.
type SecretInfo struct {
	Description *string `json:"description,omitempty"`
	EndLine     *int    `json:"endLine,omitempty"`

	// FilePath Name of the file containing the secret
	FilePath *string `json:"filePath,omitempty"`

	// Fingerprint Unique identification of the SecretInfo
	Fingerprint *string `json:"fingerprint,omitempty"`
	StartLine   *int    `json:"startLine,omitempty"`
}

// SecretScan defines model for SecretScan.
type SecretScan struct {
	Secrets *[]Secret `json:"secrets,omitempty"`
}

// SecretsConfig defines model for SecretsConfig.
type SecretsConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// SingleScheduleScanConfig defines model for SingleScheduleScanConfig.
type SingleScheduleScanConfig struct {
	ObjectType    string    `json:"objectType"`
	OperationTime time.Time `json:"operationTime"`
}

// SuccessResponse An object that is returned in cases of success that returns nothing.
type SuccessResponse struct {
	Message *string `json:"message,omitempty"`
}

// Tag AWS tag
type Tag struct {
	Key   *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

// Target defines model for Target.
type Target struct {
	Id         *string     `json:"id,omitempty"`
	TargetInfo *TargetType `json:"targetInfo,omitempty"`
}

// TargetExists defines model for TargetExists.
type TargetExists struct {
	// Message Describes which unique constraint combination causes the conflict.
	Message *string `json:"message,omitempty"`
	Target  *Target `json:"target,omitempty"`
}

// TargetScanResult defines model for TargetScanResult.
type TargetScanResult struct {
	Exploits          *ExploitScan          `json:"exploits,omitempty"`
	Id                *string               `json:"id,omitempty"`
	Malware           *MalwareScan          `json:"malware,omitempty"`
	Misconfigurations *MisconfigurationScan `json:"misconfigurations,omitempty"`
	Rootkits          *RootkitScan          `json:"rootkits,omitempty"`
	Sboms             *SbomScan             `json:"sboms,omitempty"`
	ScanId            string                `json:"scanId"`
	Secrets           *SecretScan           `json:"secrets,omitempty"`
	Status            *TargetScanStatus     `json:"status,omitempty"`

	// Summary A summary of target scan result for informational purposes.
	Summary         *TargetScanResultSummary `json:"summary,omitempty"`
	TargetId        string                   `json:"targetId"`
	Vulnerabilities *VulnerabilityScan       `json:"vulnerabilities,omitempty"`
}

// TargetScanResultExists defines model for TargetScanResultExists.
type TargetScanResultExists struct {
	// Message Describes which unique constraint combination causes the conflict.
	Message          *string           `json:"message,omitempty"`
	TargetScanResult *TargetScanResult `json:"targetScanResult,omitempty"`
}

// TargetScanResultSummary A summary of target scan result for informational purposes.
type TargetScanResultSummary struct {
	TotalExploits          *int `json:"totalExploits,omitempty"`
	TotalMalware           *int `json:"totalMalware,omitempty"`
	TotalMisconfigurations *int `json:"totalMisconfigurations,omitempty"`
	TotalPackages          *int `json:"totalPackages,omitempty"`
	TotalRootkits          *int `json:"totalRootkits,omitempty"`
	TotalSecrets           *int `json:"totalSecrets,omitempty"`

	// TotalVulnerabilities A summary of number of vulnerabilities found per severity.
	TotalVulnerabilities *VulnerabilityScanSummary `json:"totalVulnerabilities,omitempty"`
}

// TargetScanResults defines model for TargetScanResults.
type TargetScanResults struct {
	// Items List of scan results according to the given filters and page. List length must be lower or equal to pageSize.
	Items *[]TargetScanResult `json:"items,omitempty"`

	// Total Total scan results count according to the given filters
	Total *int `json:"total,omitempty"`
}

// TargetScanState defines model for TargetScanState.
type TargetScanState struct {
	Errors *[]string             `json:"errors,omitempty"`
	State  *TargetScanStateState `json:"state,omitempty"`
}

// TargetScanStateState defines model for TargetScanState.State.
type TargetScanStateState string

// TargetScanStatus defines model for TargetScanStatus.
type TargetScanStatus struct {
	Exploits          *TargetScanState `json:"exploits,omitempty"`
	General           *TargetScanState `json:"general,omitempty"`
	Malware           *TargetScanState `json:"malware,omitempty"`
	Misconfigurations *TargetScanState `json:"misconfigurations,omitempty"`
	Rootkits          *TargetScanState `json:"rootkits,omitempty"`
	Sbom              *TargetScanState `json:"sbom,omitempty"`
	Secrets           *TargetScanState `json:"secrets,omitempty"`
	Vulnerabilities   *TargetScanState `json:"vulnerabilities,omitempty"`
}

// TargetType defines model for TargetType.
type TargetType struct {
	union json.RawMessage
}

// Targets defines model for Targets.
type Targets struct {
	// Items List of targets in the given filters and page. List length must be lower or equal to pageSize.
	Items *[]Target `json:"items,omitempty"`

	// Total Total targets count according the given filters
	Total *int `json:"total,omitempty"`
}

// TimeOfDay defines model for TimeOfDay.
type TimeOfDay struct {
	Hour   *int `json:"hour,omitempty"`
	Minute *int `json:"minute,omitempty"`
}

// VMInfo defines model for VMInfo.
type VMInfo struct {
	InstanceID       string         `json:"instanceID"`
	InstanceProvider *CloudProvider `json:"instanceProvider,omitempty"`
	Location         string         `json:"location"`
	ObjectType       string         `json:"objectType"`
}

// VulnerabilitiesConfig defines model for VulnerabilitiesConfig.
type VulnerabilitiesConfig struct {
	Enabled *bool `json:"enabled,omitempty"`
}

// Vulnerability defines model for Vulnerability.
type Vulnerability struct {
	Id                *string            `json:"id,omitempty"`
	VulnerabilityInfo *VulnerabilityInfo `json:"vulnerabilityInfo,omitempty"`
}

// VulnerabilityInfo defines model for VulnerabilityInfo.
type VulnerabilityInfo struct {
	Description       *string                `json:"description,omitempty"`
	Severity          *VulnerabilitySeverity `json:"severity,omitempty"`
	VulnerabilityName *string                `json:"vulnerabilityName,omitempty"`
}

// VulnerabilityScan defines model for VulnerabilityScan.
type VulnerabilityScan struct {
	Vulnerabilities *[]Vulnerability `json:"vulnerabilities,omitempty"`
}

// VulnerabilityScanSummary A summary of number of vulnerabilities found per severity.
type VulnerabilityScanSummary struct {
	TotalCriticalVulnerabilities   *int `json:"totalCriticalVulnerabilities,omitempty"`
	TotalHighVulnerabilities       *int `json:"totalHighVulnerabilities,omitempty"`
	TotalLowVulnerabilities        *int `json:"totalLowVulnerabilities,omitempty"`
	TotalMediumVulnerabilities     *int `json:"totalMediumVulnerabilities,omitempty"`
	TotalNegligibleVulnerabilities *int `json:"totalNegligibleVulnerabilities,omitempty"`
}

// VulnerabilitySeverity defines model for VulnerabilitySeverity.
type VulnerabilitySeverity string

// WeeklyScheduleScanConfig defines model for WeeklyScheduleScanConfig.
type WeeklyScheduleScanConfig struct {
	// DayInWeek 1 - 7 which represents sun- sat
	DayInWeek  *int       `json:"dayInWeek,omitempty"`
	ObjectType string     `json:"objectType"`
	TimeOfDay  *TimeOfDay `json:"timeOfDay,omitempty"`
}

// OdataCount defines model for odataCount.
type OdataCount = bool

// OdataExpand defines model for odataExpand.
type OdataExpand = string

// OdataFilter defines model for odataFilter.
type OdataFilter = string

// OdataSelect defines model for odataSelect.
type OdataSelect = string

// OdataSkip defines model for odataSkip.
type OdataSkip = int

// OdataTop defines model for odataTop.
type OdataTop = int

// Page defines model for page.
type Page = int

// PageSize defines model for pageSize.
type PageSize = int

// ScanConfigID defines model for scanConfigID.
type ScanConfigID = string

// ScanID defines model for scanID.
type ScanID = string

// ScanResultID defines model for scanResultID.
type ScanResultID = string

// TargetID defines model for targetID.
type TargetID = string

// Success An object that is returned in cases of success that returns nothing.
type Success = SuccessResponse

// UnknownError An object that is returned in all cases of failures.
type UnknownError = ApiResponse

// GetScanConfigsParams defines parameters for GetScanConfigs.
type GetScanConfigsParams struct {
	Filter *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Count  *OdataCount  `form:"$count,omitempty" json:"$count,omitempty"`
	Top    *OdataTop    `form:"$top,omitempty" json:"$top,omitempty"`
	Skip   *OdataSkip   `form:"$skip,omitempty" json:"$skip,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// GetScanConfigsScanConfigIDParams defines parameters for GetScanConfigsScanConfigID.
type GetScanConfigsScanConfigIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
	Expand *OdataExpand `form:"$expand,omitempty" json:"$expand,omitempty"`
}

// GetScanResultsParams defines parameters for GetScanResults.
type GetScanResultsParams struct {
	Filter *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`

	// Page Page number of the query
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Maximum items to return
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// GetScanResultsScanResultIDParams defines parameters for GetScanResultsScanResultID.
type GetScanResultsScanResultIDParams struct {
	Select *OdataSelect `form:"$select,omitempty" json:"$select,omitempty"`
}

// GetScansParams defines parameters for GetScans.
type GetScansParams struct {
	Filter *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`

	// Page Page number of the query
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Maximum items to return
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// GetTargetsParams defines parameters for GetTargets.
type GetTargetsParams struct {
	Filter *OdataFilter `form:"$filter,omitempty" json:"$filter,omitempty"`

	// Page Page number of the query
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Maximum items to return
	PageSize *PageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// PostScanConfigsJSONRequestBody defines body for PostScanConfigs for application/json ContentType.
type PostScanConfigsJSONRequestBody = ScanConfig

// PatchScanConfigsScanConfigIDJSONRequestBody defines body for PatchScanConfigsScanConfigID for application/json ContentType.
type PatchScanConfigsScanConfigIDJSONRequestBody = ScanConfig

// PutScanConfigsScanConfigIDJSONRequestBody defines body for PutScanConfigsScanConfigID for application/json ContentType.
type PutScanConfigsScanConfigIDJSONRequestBody = ScanConfig

// PostScanResultsJSONRequestBody defines body for PostScanResults for application/json ContentType.
type PostScanResultsJSONRequestBody = TargetScanResult

// PatchScanResultsScanResultIDJSONRequestBody defines body for PatchScanResultsScanResultID for application/json ContentType.
type PatchScanResultsScanResultIDJSONRequestBody = TargetScanResult

// PutScanResultsScanResultIDJSONRequestBody defines body for PutScanResultsScanResultID for application/json ContentType.
type PutScanResultsScanResultIDJSONRequestBody = TargetScanResult

// PostScansJSONRequestBody defines body for PostScans for application/json ContentType.
type PostScansJSONRequestBody = Scan

// PatchScansScanIDJSONRequestBody defines body for PatchScansScanID for application/json ContentType.
type PatchScansScanIDJSONRequestBody = Scan

// PutScansScanIDJSONRequestBody defines body for PutScansScanID for application/json ContentType.
type PutScansScanIDJSONRequestBody = Scan

// PostTargetsJSONRequestBody defines body for PostTargets for application/json ContentType.
type PostTargetsJSONRequestBody = Target

// PutTargetsTargetIDJSONRequestBody defines body for PutTargetsTargetID for application/json ContentType.
type PutTargetsTargetIDJSONRequestBody = Target

// AsSingleScheduleScanConfig returns the union data inside the RuntimeScheduleScanConfigType as a SingleScheduleScanConfig
func (t RuntimeScheduleScanConfigType) AsSingleScheduleScanConfig() (SingleScheduleScanConfig, error) {
	var body SingleScheduleScanConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSingleScheduleScanConfig overwrites any union data inside the RuntimeScheduleScanConfigType as the provided SingleScheduleScanConfig
func (t *RuntimeScheduleScanConfigType) FromSingleScheduleScanConfig(v SingleScheduleScanConfig) error {
	v.ObjectType = "SingleScheduleScanConfig"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSingleScheduleScanConfig performs a merge with any union data inside the RuntimeScheduleScanConfigType, using the provided SingleScheduleScanConfig
func (t *RuntimeScheduleScanConfigType) MergeSingleScheduleScanConfig(v SingleScheduleScanConfig) error {
	v.ObjectType = "SingleScheduleScanConfig"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsByHoursScheduleScanConfig returns the union data inside the RuntimeScheduleScanConfigType as a ByHoursScheduleScanConfig
func (t RuntimeScheduleScanConfigType) AsByHoursScheduleScanConfig() (ByHoursScheduleScanConfig, error) {
	var body ByHoursScheduleScanConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromByHoursScheduleScanConfig overwrites any union data inside the RuntimeScheduleScanConfigType as the provided ByHoursScheduleScanConfig
func (t *RuntimeScheduleScanConfigType) FromByHoursScheduleScanConfig(v ByHoursScheduleScanConfig) error {
	v.ObjectType = "ByHoursScheduleScanConfig"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeByHoursScheduleScanConfig performs a merge with any union data inside the RuntimeScheduleScanConfigType, using the provided ByHoursScheduleScanConfig
func (t *RuntimeScheduleScanConfigType) MergeByHoursScheduleScanConfig(v ByHoursScheduleScanConfig) error {
	v.ObjectType = "ByHoursScheduleScanConfig"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsByDaysScheduleScanConfig returns the union data inside the RuntimeScheduleScanConfigType as a ByDaysScheduleScanConfig
func (t RuntimeScheduleScanConfigType) AsByDaysScheduleScanConfig() (ByDaysScheduleScanConfig, error) {
	var body ByDaysScheduleScanConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromByDaysScheduleScanConfig overwrites any union data inside the RuntimeScheduleScanConfigType as the provided ByDaysScheduleScanConfig
func (t *RuntimeScheduleScanConfigType) FromByDaysScheduleScanConfig(v ByDaysScheduleScanConfig) error {
	v.ObjectType = "ByDaysScheduleScanConfig"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeByDaysScheduleScanConfig performs a merge with any union data inside the RuntimeScheduleScanConfigType, using the provided ByDaysScheduleScanConfig
func (t *RuntimeScheduleScanConfigType) MergeByDaysScheduleScanConfig(v ByDaysScheduleScanConfig) error {
	v.ObjectType = "ByDaysScheduleScanConfig"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsWeeklyScheduleScanConfig returns the union data inside the RuntimeScheduleScanConfigType as a WeeklyScheduleScanConfig
func (t RuntimeScheduleScanConfigType) AsWeeklyScheduleScanConfig() (WeeklyScheduleScanConfig, error) {
	var body WeeklyScheduleScanConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWeeklyScheduleScanConfig overwrites any union data inside the RuntimeScheduleScanConfigType as the provided WeeklyScheduleScanConfig
func (t *RuntimeScheduleScanConfigType) FromWeeklyScheduleScanConfig(v WeeklyScheduleScanConfig) error {
	v.ObjectType = "WeeklyScheduleScanConfig"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWeeklyScheduleScanConfig performs a merge with any union data inside the RuntimeScheduleScanConfigType, using the provided WeeklyScheduleScanConfig
func (t *RuntimeScheduleScanConfigType) MergeWeeklyScheduleScanConfig(v WeeklyScheduleScanConfig) error {
	v.ObjectType = "WeeklyScheduleScanConfig"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t RuntimeScheduleScanConfigType) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"objectType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RuntimeScheduleScanConfigType) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ByDaysScheduleScanConfig":
		return t.AsByDaysScheduleScanConfig()
	case "ByHoursScheduleScanConfig":
		return t.AsByHoursScheduleScanConfig()
	case "SingleScheduleScanConfig":
		return t.AsSingleScheduleScanConfig()
	case "WeeklyScheduleScanConfig":
		return t.AsWeeklyScheduleScanConfig()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RuntimeScheduleScanConfigType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RuntimeScheduleScanConfigType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAwsScanScope returns the union data inside the ScanScopeType as a AwsScanScope
func (t ScanScopeType) AsAwsScanScope() (AwsScanScope, error) {
	var body AwsScanScope
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAwsScanScope overwrites any union data inside the ScanScopeType as the provided AwsScanScope
func (t *ScanScopeType) FromAwsScanScope(v AwsScanScope) error {
	v.ObjectType = "AwsScanScope"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAwsScanScope performs a merge with any union data inside the ScanScopeType, using the provided AwsScanScope
func (t *ScanScopeType) MergeAwsScanScope(v AwsScanScope) error {
	v.ObjectType = "AwsScanScope"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t ScanScopeType) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"objectType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ScanScopeType) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "AwsScanScope":
		return t.AsAwsScanScope()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ScanScopeType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScanScopeType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsVMInfo returns the union data inside the TargetType as a VMInfo
func (t TargetType) AsVMInfo() (VMInfo, error) {
	var body VMInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVMInfo overwrites any union data inside the TargetType as the provided VMInfo
func (t *TargetType) FromVMInfo(v VMInfo) error {
	v.ObjectType = "VMInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVMInfo performs a merge with any union data inside the TargetType, using the provided VMInfo
func (t *TargetType) MergeVMInfo(v VMInfo) error {
	v.ObjectType = "VMInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsPodInfo returns the union data inside the TargetType as a PodInfo
func (t TargetType) AsPodInfo() (PodInfo, error) {
	var body PodInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPodInfo overwrites any union data inside the TargetType as the provided PodInfo
func (t *TargetType) FromPodInfo(v PodInfo) error {
	v.ObjectType = "PodInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePodInfo performs a merge with any union data inside the TargetType, using the provided PodInfo
func (t *TargetType) MergePodInfo(v PodInfo) error {
	v.ObjectType = "PodInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsDirInfo returns the union data inside the TargetType as a DirInfo
func (t TargetType) AsDirInfo() (DirInfo, error) {
	var body DirInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDirInfo overwrites any union data inside the TargetType as the provided DirInfo
func (t *TargetType) FromDirInfo(v DirInfo) error {
	v.ObjectType = "DirInfo"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDirInfo performs a merge with any union data inside the TargetType, using the provided DirInfo
func (t *TargetType) MergeDirInfo(v DirInfo) error {
	v.ObjectType = "DirInfo"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t TargetType) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"objectType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t TargetType) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "DirInfo":
		return t.AsDirInfo()
	case "PodInfo":
		return t.AsPodInfo()
	case "VMInfo":
		return t.AsVMInfo()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t TargetType) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *TargetType) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
