// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.2.0 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	. "github.com/openclarity/vmclarity/api/types"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get all asset findings.
	// (GET /assetFindings)
	GetAssetFindings(ctx echo.Context, params GetAssetFindingsParams) error
	// Create an asset finding
	// (POST /assetFindings)
	PostAssetFindings(ctx echo.Context) error
	// Delete an asset finding.
	// (DELETE /assetFindings/{assetFindingID})
	DeleteAssetFindingsAssetFindingID(ctx echo.Context, assetFindingID AssetFindingID) error
	// Get the details for an asset finding.
	// (GET /assetFindings/{assetFindingID})
	GetAssetFindingsAssetFindingID(ctx echo.Context, assetFindingID AssetFindingID, params GetAssetFindingsAssetFindingIDParams) error
	// Patch an asset finding.
	// (PATCH /assetFindings/{assetFindingID})
	PatchAssetFindingsAssetFindingID(ctx echo.Context, assetFindingID AssetFindingID, params PatchAssetFindingsAssetFindingIDParams) error
	// Update an asset finding.
	// (PUT /assetFindings/{assetFindingID})
	PutAssetFindingsAssetFindingID(ctx echo.Context, assetFindingID AssetFindingID, params PutAssetFindingsAssetFindingIDParams) error
	// Get asset scan estimations according to the given filters
	// (GET /assetScanEstimations)
	GetAssetScanEstimations(ctx echo.Context, params GetAssetScanEstimationsParams) error
	// Create an asset scan estimation for a specified asset
	// (POST /assetScanEstimations)
	PostAssetScanEstimations(ctx echo.Context) error
	// Delete an asset scan estimation.
	// (DELETE /assetScanEstimations/{assetScanEstimationID})
	DeleteAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID) error
	// Get an asset scan estimation.
	// (GET /assetScanEstimations/{assetScanEstimationID})
	GetAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params GetAssetScanEstimationsAssetScanEstimationIDParams) error
	// Patch an asset scan estimation
	// (PATCH /assetScanEstimations/{assetScanEstimationID})
	PatchAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params PatchAssetScanEstimationsAssetScanEstimationIDParams) error
	// Update an asset scan estimation.
	// (PUT /assetScanEstimations/{assetScanEstimationID})
	PutAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params PutAssetScanEstimationsAssetScanEstimationIDParams) error
	// Get asset scans according to the given filters
	// (GET /assetScans)
	GetAssetScans(ctx echo.Context, params GetAssetScansParams) error
	// Create an asset scan for a specified asset
	// (POST /assetScans)
	PostAssetScans(ctx echo.Context) error
	// Get an asset scan.
	// (GET /assetScans/{assetScanID})
	GetAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params GetAssetScansAssetScanIDParams) error
	// Patch an asset scan
	// (PATCH /assetScans/{assetScanID})
	PatchAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params PatchAssetScansAssetScanIDParams) error
	// Update an asset scan.
	// (PUT /assetScans/{assetScanID})
	PutAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params PutAssetScansAssetScanIDParams) error
	// Get assets
	// (GET /assets)
	GetAssets(ctx echo.Context, params GetAssetsParams) error
	// Create asset
	// (POST /assets)
	PostAssets(ctx echo.Context) error
	// Delete asset.
	// (DELETE /assets/{assetID})
	DeleteAssetsAssetID(ctx echo.Context, assetID AssetID) error
	// Get asset.
	// (GET /assets/{assetID})
	GetAssetsAssetID(ctx echo.Context, assetID AssetID, params GetAssetsAssetIDParams) error
	// Update asset.
	// (PATCH /assets/{assetID})
	PatchAssetsAssetID(ctx echo.Context, assetID AssetID, params PatchAssetsAssetIDParams) error
	// Update asset.
	// (PUT /assets/{assetID})
	PutAssetsAssetID(ctx echo.Context, assetID AssetID, params PutAssetsAssetIDParams) error
	// Get all findings.
	// (GET /findings)
	GetFindings(ctx echo.Context, params GetFindingsParams) error
	// Create a finding
	// (POST /findings)
	PostFindings(ctx echo.Context) error
	// Delete a finding.
	// (DELETE /findings/{findingID})
	DeleteFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Get the details for a finding.
	// (GET /findings/{findingID})
	GetFindingsFindingID(ctx echo.Context, findingID FindingID, params GetFindingsFindingIDParams) error
	// Patch a finding.
	// (PATCH /findings/{findingID})
	PatchFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Update a finding.
	// (PUT /findings/{findingID})
	PutFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Get this OpenAPI spec
	// (GET /openapi.json)
	GetOpenAPISpec(ctx echo.Context) error
	// Get providers
	// (GET /providers)
	GetProviders(ctx echo.Context, params GetProvidersParams) error
	// Create provider
	// (POST /providers)
	PostProviders(ctx echo.Context) error
	// Delete provider.
	// (DELETE /providers/{providerID})
	DeleteProvidersProviderID(ctx echo.Context, providerID ProviderID) error
	// Get provider.
	// (GET /providers/{providerID})
	GetProvidersProviderID(ctx echo.Context, providerID ProviderID, params GetProvidersProviderIDParams) error
	// Update provider.
	// (PATCH /providers/{providerID})
	PatchProvidersProviderID(ctx echo.Context, providerID ProviderID, params PatchProvidersProviderIDParams) error
	// Update provider.
	// (PUT /providers/{providerID})
	PutProvidersProviderID(ctx echo.Context, providerID ProviderID, params PutProvidersProviderIDParams) error
	// Get all scan configs.
	// (GET /scanConfigs)
	GetScanConfigs(ctx echo.Context, params GetScanConfigsParams) error
	// Create a scan config
	// (POST /scanConfigs)
	PostScanConfigs(ctx echo.Context) error
	// Delete a scan config.
	// (DELETE /scanConfigs/{scanConfigID})
	DeleteScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID) error
	// Get the details for a scan config.
	// (GET /scanConfigs/{scanConfigID})
	GetScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params GetScanConfigsScanConfigIDParams) error
	// Patch a scan config.
	// (PATCH /scanConfigs/{scanConfigID})
	PatchScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params PatchScanConfigsScanConfigIDParams) error
	// Update a scan config.
	// (PUT /scanConfigs/{scanConfigID})
	PutScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params PutScanConfigsScanConfigIDParams) error
	// Get all scan estimations. Each scan estimation contains details about a multi-asset scan estimation.
	// (GET /scanEstimations)
	GetScanEstimations(ctx echo.Context, params GetScanEstimationsParams) error
	// Create a multi-asset scan estimation
	// (POST /scanEstimations)
	PostScanEstimations(ctx echo.Context) error
	// Delete a scan estimation.
	// (DELETE /scanEstimations/{scanEstimationID})
	DeleteScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID) error
	// Get the details for a given multi-asset scan estimation.
	// (GET /scanEstimations/{scanEstimationID})
	GetScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params GetScanEstimationsScanEstimationIDParams) error
	// Patch a scan estimation.
	// (PATCH /scanEstimations/{scanEstimationID})
	PatchScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params PatchScanEstimationsScanEstimationIDParams) error
	// Update a scan estimation.
	// (PUT /scanEstimations/{scanEstimationID})
	PutScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params PutScanEstimationsScanEstimationIDParams) error
	// Get all scans. Each scan contains details about a multi-asset scheduled scan.
	// (GET /scans)
	GetScans(ctx echo.Context, params GetScansParams) error
	// Create a multi-asset scheduled scan
	// (POST /scans)
	PostScans(ctx echo.Context) error
	// Delete a scan.
	// (DELETE /scans/{scanID})
	DeleteScansScanID(ctx echo.Context, scanID ScanID) error
	// Get the details for a given multi-asset scheduled scan.
	// (GET /scans/{scanID})
	GetScansScanID(ctx echo.Context, scanID ScanID, params GetScansScanIDParams) error
	// Patch a scan.
	// (PATCH /scans/{scanID})
	PatchScansScanID(ctx echo.Context, scanID ScanID, params PatchScansScanIDParams) error
	// Update a scan.
	// (PUT /scans/{scanID})
	PutScansScanID(ctx echo.Context, scanID ScanID, params PutScansScanIDParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAssetFindings converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetFindings(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetFindingsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetFindings(ctx, params)
	return err
}

// PostAssetFindings converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssetFindings(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssetFindings(ctx)
	return err
}

// DeleteAssetFindingsAssetFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetFindingsAssetFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetFindingID" -------------
	var assetFindingID AssetFindingID

	err = runtime.BindStyledParameterWithOptions("simple", "assetFindingID", ctx.Param("assetFindingID"), &assetFindingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetFindingID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAssetFindingsAssetFindingID(ctx, assetFindingID)
	return err
}

// GetAssetFindingsAssetFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetFindingsAssetFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetFindingID" -------------
	var assetFindingID AssetFindingID

	err = runtime.BindStyledParameterWithOptions("simple", "assetFindingID", ctx.Param("assetFindingID"), &assetFindingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetFindingID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetFindingsAssetFindingIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetFindingsAssetFindingID(ctx, assetFindingID, params)
	return err
}

// PatchAssetFindingsAssetFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetFindingsAssetFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetFindingID" -------------
	var assetFindingID AssetFindingID

	err = runtime.BindStyledParameterWithOptions("simple", "assetFindingID", ctx.Param("assetFindingID"), &assetFindingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetFindingID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetFindingsAssetFindingIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetFindingsAssetFindingID(ctx, assetFindingID, params)
	return err
}

// PutAssetFindingsAssetFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetFindingsAssetFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetFindingID" -------------
	var assetFindingID AssetFindingID

	err = runtime.BindStyledParameterWithOptions("simple", "assetFindingID", ctx.Param("assetFindingID"), &assetFindingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetFindingID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetFindingsAssetFindingIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetFindingsAssetFindingID(ctx, assetFindingID, params)
	return err
}

// GetAssetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScanEstimations(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScanEstimationsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScanEstimations(ctx, params)
	return err
}

// PostAssetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssetScanEstimations(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssetScanEstimations(ctx)
	return err
}

// DeleteAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanEstimationID", ctx.Param("assetScanEstimationID"), &assetScanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID)
	return err
}

// GetAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanEstimationID", ctx.Param("assetScanEstimationID"), &assetScanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScanEstimationsAssetScanEstimationIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// PatchAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanEstimationID", ctx.Param("assetScanEstimationID"), &assetScanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetScanEstimationsAssetScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// PutAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanEstimationID", ctx.Param("assetScanEstimationID"), &assetScanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetScanEstimationsAssetScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// GetAssetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScans(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScansParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScans(ctx, params)
	return err
}

// PostAssetScans converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssetScans(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssetScans(ctx)
	return err
}

// GetAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanID", ctx.Param("assetScanID"), &assetScanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScansAssetScanIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// PatchAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanID", ctx.Param("assetScanID"), &assetScanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetScansAssetScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// PutAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanID", ctx.Param("assetScanID"), &assetScanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetScansAssetScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// GetAssets converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssets(ctx, params)
	return err
}

// PostAssets converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssets(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssets(ctx)
	return err
}

// DeleteAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithOptions("simple", "assetID", ctx.Param("assetID"), &assetID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAssetsAssetID(ctx, assetID)
	return err
}

// GetAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithOptions("simple", "assetID", ctx.Param("assetID"), &assetID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsAssetIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetsAssetID(ctx, assetID, params)
	return err
}

// PatchAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithOptions("simple", "assetID", ctx.Param("assetID"), &assetID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetsAssetIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetsAssetID(ctx, assetID, params)
	return err
}

// PutAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithOptions("simple", "assetID", ctx.Param("assetID"), &assetID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetsAssetIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetsAssetID(ctx, assetID, params)
	return err
}

// GetFindings converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindings(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFindings(ctx, params)
	return err
}

// PostFindings converts echo context to params.
func (w *ServerInterfaceWrapper) PostFindings(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFindings(ctx)
	return err
}

// DeleteFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithOptions("simple", "findingID", ctx.Param("findingID"), &findingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteFindingsFindingID(ctx, findingID)
	return err
}

// GetFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithOptions("simple", "findingID", ctx.Param("findingID"), &findingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsFindingIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFindingsFindingID(ctx, findingID, params)
	return err
}

// PatchFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithOptions("simple", "findingID", ctx.Param("findingID"), &findingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchFindingsFindingID(ctx, findingID)
	return err
}

// PutFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PutFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithOptions("simple", "findingID", ctx.Param("findingID"), &findingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutFindingsFindingID(ctx, findingID)
	return err
}

// GetOpenAPISpec converts echo context to params.
func (w *ServerInterfaceWrapper) GetOpenAPISpec(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOpenAPISpec(ctx)
	return err
}

// GetProviders converts echo context to params.
func (w *ServerInterfaceWrapper) GetProviders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProvidersParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProviders(ctx, params)
	return err
}

// PostProviders converts echo context to params.
func (w *ServerInterfaceWrapper) PostProviders(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostProviders(ctx)
	return err
}

// DeleteProvidersProviderID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProvidersProviderID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "providerID" -------------
	var providerID ProviderID

	err = runtime.BindStyledParameterWithOptions("simple", "providerID", ctx.Param("providerID"), &providerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter providerID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteProvidersProviderID(ctx, providerID)
	return err
}

// GetProvidersProviderID converts echo context to params.
func (w *ServerInterfaceWrapper) GetProvidersProviderID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "providerID" -------------
	var providerID ProviderID

	err = runtime.BindStyledParameterWithOptions("simple", "providerID", ctx.Param("providerID"), &providerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter providerID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProvidersProviderIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProvidersProviderID(ctx, providerID, params)
	return err
}

// PatchProvidersProviderID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchProvidersProviderID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "providerID" -------------
	var providerID ProviderID

	err = runtime.BindStyledParameterWithOptions("simple", "providerID", ctx.Param("providerID"), &providerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter providerID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchProvidersProviderIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchProvidersProviderID(ctx, providerID, params)
	return err
}

// PutProvidersProviderID converts echo context to params.
func (w *ServerInterfaceWrapper) PutProvidersProviderID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "providerID" -------------
	var providerID ProviderID

	err = runtime.BindStyledParameterWithOptions("simple", "providerID", ctx.Param("providerID"), &providerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter providerID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutProvidersProviderIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutProvidersProviderID(ctx, providerID, params)
	return err
}

// GetScanConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanConfigs(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanConfigsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanConfigs(ctx, params)
	return err
}

// PostScanConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) PostScanConfigs(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScanConfigs(ctx)
	return err
}

// DeleteScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithOptions("simple", "scanConfigID", ctx.Param("scanConfigID"), &scanConfigID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScanConfigsScanConfigID(ctx, scanConfigID)
	return err
}

// GetScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithOptions("simple", "scanConfigID", ctx.Param("scanConfigID"), &scanConfigID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanConfigsScanConfigIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// PatchScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithOptions("simple", "scanConfigID", ctx.Param("scanConfigID"), &scanConfigID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScanConfigsScanConfigIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// PutScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithOptions("simple", "scanConfigID", ctx.Param("scanConfigID"), &scanConfigID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScanConfigsScanConfigIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// GetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanEstimations(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanEstimationsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanEstimations(ctx, params)
	return err
}

// PostScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) PostScanEstimations(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScanEstimations(ctx)
	return err
}

// DeleteScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "scanEstimationID", ctx.Param("scanEstimationID"), &scanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScanEstimationsScanEstimationID(ctx, scanEstimationID)
	return err
}

// GetScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "scanEstimationID", ctx.Param("scanEstimationID"), &scanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanEstimationsScanEstimationIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// PatchScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "scanEstimationID", ctx.Param("scanEstimationID"), &scanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScanEstimationsScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// PutScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "scanEstimationID", ctx.Param("scanEstimationID"), &scanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScanEstimationsScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// GetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetScans(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScans(ctx, params)
	return err
}

// PostScans converts echo context to params.
func (w *ServerInterfaceWrapper) PostScans(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScans(ctx)
	return err
}

// DeleteScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScansScanID(ctx, scanID)
	return err
}

// GetScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansScanIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScansScanID(ctx, scanID, params)
	return err
}

// PatchScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScansScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScansScanID(ctx, scanID, params)
	return err
}

// PutScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScansScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScansScanID(ctx, scanID, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/assetFindings", wrapper.GetAssetFindings)
	router.POST(baseURL+"/assetFindings", wrapper.PostAssetFindings)
	router.DELETE(baseURL+"/assetFindings/:assetFindingID", wrapper.DeleteAssetFindingsAssetFindingID)
	router.GET(baseURL+"/assetFindings/:assetFindingID", wrapper.GetAssetFindingsAssetFindingID)
	router.PATCH(baseURL+"/assetFindings/:assetFindingID", wrapper.PatchAssetFindingsAssetFindingID)
	router.PUT(baseURL+"/assetFindings/:assetFindingID", wrapper.PutAssetFindingsAssetFindingID)
	router.GET(baseURL+"/assetScanEstimations", wrapper.GetAssetScanEstimations)
	router.POST(baseURL+"/assetScanEstimations", wrapper.PostAssetScanEstimations)
	router.DELETE(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.DeleteAssetScanEstimationsAssetScanEstimationID)
	router.GET(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.GetAssetScanEstimationsAssetScanEstimationID)
	router.PATCH(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.PatchAssetScanEstimationsAssetScanEstimationID)
	router.PUT(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.PutAssetScanEstimationsAssetScanEstimationID)
	router.GET(baseURL+"/assetScans", wrapper.GetAssetScans)
	router.POST(baseURL+"/assetScans", wrapper.PostAssetScans)
	router.GET(baseURL+"/assetScans/:assetScanID", wrapper.GetAssetScansAssetScanID)
	router.PATCH(baseURL+"/assetScans/:assetScanID", wrapper.PatchAssetScansAssetScanID)
	router.PUT(baseURL+"/assetScans/:assetScanID", wrapper.PutAssetScansAssetScanID)
	router.GET(baseURL+"/assets", wrapper.GetAssets)
	router.POST(baseURL+"/assets", wrapper.PostAssets)
	router.DELETE(baseURL+"/assets/:assetID", wrapper.DeleteAssetsAssetID)
	router.GET(baseURL+"/assets/:assetID", wrapper.GetAssetsAssetID)
	router.PATCH(baseURL+"/assets/:assetID", wrapper.PatchAssetsAssetID)
	router.PUT(baseURL+"/assets/:assetID", wrapper.PutAssetsAssetID)
	router.GET(baseURL+"/findings", wrapper.GetFindings)
	router.POST(baseURL+"/findings", wrapper.PostFindings)
	router.DELETE(baseURL+"/findings/:findingID", wrapper.DeleteFindingsFindingID)
	router.GET(baseURL+"/findings/:findingID", wrapper.GetFindingsFindingID)
	router.PATCH(baseURL+"/findings/:findingID", wrapper.PatchFindingsFindingID)
	router.PUT(baseURL+"/findings/:findingID", wrapper.PutFindingsFindingID)
	router.GET(baseURL+"/openapi.json", wrapper.GetOpenAPISpec)
	router.GET(baseURL+"/providers", wrapper.GetProviders)
	router.POST(baseURL+"/providers", wrapper.PostProviders)
	router.DELETE(baseURL+"/providers/:providerID", wrapper.DeleteProvidersProviderID)
	router.GET(baseURL+"/providers/:providerID", wrapper.GetProvidersProviderID)
	router.PATCH(baseURL+"/providers/:providerID", wrapper.PatchProvidersProviderID)
	router.PUT(baseURL+"/providers/:providerID", wrapper.PutProvidersProviderID)
	router.GET(baseURL+"/scanConfigs", wrapper.GetScanConfigs)
	router.POST(baseURL+"/scanConfigs", wrapper.PostScanConfigs)
	router.DELETE(baseURL+"/scanConfigs/:scanConfigID", wrapper.DeleteScanConfigsScanConfigID)
	router.GET(baseURL+"/scanConfigs/:scanConfigID", wrapper.GetScanConfigsScanConfigID)
	router.PATCH(baseURL+"/scanConfigs/:scanConfigID", wrapper.PatchScanConfigsScanConfigID)
	router.PUT(baseURL+"/scanConfigs/:scanConfigID", wrapper.PutScanConfigsScanConfigID)
	router.GET(baseURL+"/scanEstimations", wrapper.GetScanEstimations)
	router.POST(baseURL+"/scanEstimations", wrapper.PostScanEstimations)
	router.DELETE(baseURL+"/scanEstimations/:scanEstimationID", wrapper.DeleteScanEstimationsScanEstimationID)
	router.GET(baseURL+"/scanEstimations/:scanEstimationID", wrapper.GetScanEstimationsScanEstimationID)
	router.PATCH(baseURL+"/scanEstimations/:scanEstimationID", wrapper.PatchScanEstimationsScanEstimationID)
	router.PUT(baseURL+"/scanEstimations/:scanEstimationID", wrapper.PutScanEstimationsScanEstimationID)
	router.GET(baseURL+"/scans", wrapper.GetScans)
	router.POST(baseURL+"/scans", wrapper.PostScans)
	router.DELETE(baseURL+"/scans/:scanID", wrapper.DeleteScansScanID)
	router.GET(baseURL+"/scans/:scanID", wrapper.GetScansScanID)
	router.PATCH(baseURL+"/scans/:scanID", wrapper.PatchScansScanID)
	router.PUT(baseURL+"/scans/:scanID", wrapper.PutScansScanID)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
