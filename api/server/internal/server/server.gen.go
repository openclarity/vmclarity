// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.2.0 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	. "github.com/openclarity/vmclarity/api/types"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get all asset findings.
	// (GET /assetFindings)
	GetAssetFindings(ctx echo.Context, params GetAssetFindingsParams) error
	// Create an asset finding
	// (POST /assetFindings)
	PostAssetFindings(ctx echo.Context) error
	// Delete an asset finding.
	// (DELETE /assetFindings/{assetFindingID})
	DeleteAssetFindingsAssetFindingID(ctx echo.Context, assetFindingID AssetFindingID) error
	// Get the details for an asset finding.
	// (GET /assetFindings/{assetFindingID})
	GetAssetFindingsAssetFindingID(ctx echo.Context, assetFindingID AssetFindingID, params GetAssetFindingsAssetFindingIDParams) error
	// Patch an asset finding.
	// (PATCH /assetFindings/{assetFindingID})
	PatchAssetFindingsAssetFindingID(ctx echo.Context, assetFindingID AssetFindingID, params PatchAssetFindingsAssetFindingIDParams) error
	// Update an asset finding.
	// (PUT /assetFindings/{assetFindingID})
	PutAssetFindingsAssetFindingID(ctx echo.Context, assetFindingID AssetFindingID, params PutAssetFindingsAssetFindingIDParams) error
	// Get asset scan estimations according to the given filters
	// (GET /assetScanEstimations)
	GetAssetScanEstimations(ctx echo.Context, params GetAssetScanEstimationsParams) error
	// Create an asset scan estimation for a specified asset
	// (POST /assetScanEstimations)
	PostAssetScanEstimations(ctx echo.Context) error
	// Delete an asset scan estimation.
	// (DELETE /assetScanEstimations/{assetScanEstimationID})
	DeleteAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID) error
	// Get an asset scan estimation.
	// (GET /assetScanEstimations/{assetScanEstimationID})
	GetAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params GetAssetScanEstimationsAssetScanEstimationIDParams) error
	// Patch an asset scan estimation
	// (PATCH /assetScanEstimations/{assetScanEstimationID})
	PatchAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params PatchAssetScanEstimationsAssetScanEstimationIDParams) error
	// Update an asset scan estimation.
	// (PUT /assetScanEstimations/{assetScanEstimationID})
	PutAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params PutAssetScanEstimationsAssetScanEstimationIDParams) error
	// Get asset scans according to the given filters
	// (GET /assetScans)
	GetAssetScans(ctx echo.Context, params GetAssetScansParams) error
	// Create an asset scan for a specified asset
	// (POST /assetScans)
	PostAssetScans(ctx echo.Context) error
	// Get an asset scan.
	// (GET /assetScans/{assetScanID})
	GetAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params GetAssetScansAssetScanIDParams) error
	// Patch an asset scan
	// (PATCH /assetScans/{assetScanID})
	PatchAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params PatchAssetScansAssetScanIDParams) error
	// Update an asset scan.
	// (PUT /assetScans/{assetScanID})
	PutAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params PutAssetScansAssetScanIDParams) error
	// Get assets
	// (GET /assets)
	GetAssets(ctx echo.Context, params GetAssetsParams) error
	// Create asset
	// (POST /assets)
	PostAssets(ctx echo.Context) error
	// Delete asset.
	// (DELETE /assets/{assetID})
	DeleteAssetsAssetID(ctx echo.Context, assetID AssetID) error
	// Get asset.
	// (GET /assets/{assetID})
	GetAssetsAssetID(ctx echo.Context, assetID AssetID, params GetAssetsAssetIDParams) error
	// Update asset.
	// (PATCH /assets/{assetID})
	PatchAssetsAssetID(ctx echo.Context, assetID AssetID, params PatchAssetsAssetIDParams) error
	// Update asset.
	// (PUT /assets/{assetID})
	PutAssetsAssetID(ctx echo.Context, assetID AssetID, params PutAssetsAssetIDParams) error
	// Get all findings.
	// (GET /findings)
	GetFindings(ctx echo.Context, params GetFindingsParams) error
	// Create a finding
	// (POST /findings)
	PostFindings(ctx echo.Context) error
	// Delete a finding.
	// (DELETE /findings/{findingID})
	DeleteFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Get the details for a finding.
	// (GET /findings/{findingID})
	GetFindingsFindingID(ctx echo.Context, findingID FindingID, params GetFindingsFindingIDParams) error
	// Patch a finding.
	// (PATCH /findings/{findingID})
	PatchFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Update a finding.
	// (PUT /findings/{findingID})
	PutFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Get this OpenAPI spec
	// (GET /openapi.json)
	GetOpenAPISpec(ctx echo.Context) error
	// Get providers
	// (GET /providers)
	GetProviders(ctx echo.Context, params GetProvidersParams) error
	// Create provider
	// (POST /providers)
	PostProviders(ctx echo.Context) error
	// Delete provider.
	// (DELETE /providers/{providerID})
	DeleteProvidersProviderID(ctx echo.Context, providerID ProviderID) error
	// Get provider.
	// (GET /providers/{providerID})
	GetProvidersProviderID(ctx echo.Context, providerID ProviderID, params GetProvidersProviderIDParams) error
	// Update provider.
	// (PATCH /providers/{providerID})
	PatchProvidersProviderID(ctx echo.Context, providerID ProviderID, params PatchProvidersProviderIDParams) error
	// Update provider.
	// (PUT /providers/{providerID})
	PutProvidersProviderID(ctx echo.Context, providerID ProviderID, params PutProvidersProviderIDParams) error
	// Get all scan configs.
	// (GET /scanConfigs)
	GetScanConfigs(ctx echo.Context, params GetScanConfigsParams) error
	// Create a scan config
	// (POST /scanConfigs)
	PostScanConfigs(ctx echo.Context) error
	// Delete a scan config.
	// (DELETE /scanConfigs/{scanConfigID})
	DeleteScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID) error
	// Get the details for a scan config.
	// (GET /scanConfigs/{scanConfigID})
	GetScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params GetScanConfigsScanConfigIDParams) error
	// Patch a scan config.
	// (PATCH /scanConfigs/{scanConfigID})
	PatchScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params PatchScanConfigsScanConfigIDParams) error
	// Update a scan config.
	// (PUT /scanConfigs/{scanConfigID})
	PutScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params PutScanConfigsScanConfigIDParams) error
	// Get all scan estimations. Each scan estimation contains details about a multi-asset scan estimation.
	// (GET /scanEstimations)
	GetScanEstimations(ctx echo.Context, params GetScanEstimationsParams) error
	// Create a multi-asset scan estimation
	// (POST /scanEstimations)
	PostScanEstimations(ctx echo.Context) error
	// Delete a scan estimation.
	// (DELETE /scanEstimations/{scanEstimationID})
	DeleteScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID) error
	// Get the details for a given multi-asset scan estimation.
	// (GET /scanEstimations/{scanEstimationID})
	GetScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params GetScanEstimationsScanEstimationIDParams) error
	// Patch a scan estimation.
	// (PATCH /scanEstimations/{scanEstimationID})
	PatchScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params PatchScanEstimationsScanEstimationIDParams) error
	// Update a scan estimation.
	// (PUT /scanEstimations/{scanEstimationID})
	PutScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params PutScanEstimationsScanEstimationIDParams) error
	// Get all scans. Each scan contains details about a multi-asset scheduled scan.
	// (GET /scans)
	GetScans(ctx echo.Context, params GetScansParams) error
	// Create a multi-asset scheduled scan
	// (POST /scans)
	PostScans(ctx echo.Context) error
	// Delete a scan.
	// (DELETE /scans/{scanID})
	DeleteScansScanID(ctx echo.Context, scanID ScanID) error
	// Get the details for a given multi-asset scheduled scan.
	// (GET /scans/{scanID})
	GetScansScanID(ctx echo.Context, scanID ScanID, params GetScansScanIDParams) error
	// Patch a scan.
	// (PATCH /scans/{scanID})
	PatchScansScanID(ctx echo.Context, scanID ScanID, params PatchScansScanIDParams) error
	// Update a scan.
	// (PUT /scans/{scanID})
	PutScansScanID(ctx echo.Context, scanID ScanID, params PutScansScanIDParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAssetFindings converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetFindings(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetFindingsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetFindings(ctx, params)
	return err
}

// PostAssetFindings converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssetFindings(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssetFindings(ctx)
	return err
}

// DeleteAssetFindingsAssetFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetFindingsAssetFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetFindingID" -------------
	var assetFindingID AssetFindingID

	err = runtime.BindStyledParameterWithOptions("simple", "assetFindingID", ctx.Param("assetFindingID"), &assetFindingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetFindingID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAssetFindingsAssetFindingID(ctx, assetFindingID)
	return err
}

// GetAssetFindingsAssetFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetFindingsAssetFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetFindingID" -------------
	var assetFindingID AssetFindingID

	err = runtime.BindStyledParameterWithOptions("simple", "assetFindingID", ctx.Param("assetFindingID"), &assetFindingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetFindingID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetFindingsAssetFindingIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetFindingsAssetFindingID(ctx, assetFindingID, params)
	return err
}

// PatchAssetFindingsAssetFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetFindingsAssetFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetFindingID" -------------
	var assetFindingID AssetFindingID

	err = runtime.BindStyledParameterWithOptions("simple", "assetFindingID", ctx.Param("assetFindingID"), &assetFindingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetFindingID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetFindingsAssetFindingIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetFindingsAssetFindingID(ctx, assetFindingID, params)
	return err
}

// PutAssetFindingsAssetFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetFindingsAssetFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetFindingID" -------------
	var assetFindingID AssetFindingID

	err = runtime.BindStyledParameterWithOptions("simple", "assetFindingID", ctx.Param("assetFindingID"), &assetFindingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetFindingID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetFindingsAssetFindingIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetFindingsAssetFindingID(ctx, assetFindingID, params)
	return err
}

// GetAssetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScanEstimations(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScanEstimationsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScanEstimations(ctx, params)
	return err
}

// PostAssetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssetScanEstimations(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssetScanEstimations(ctx)
	return err
}

// DeleteAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanEstimationID", ctx.Param("assetScanEstimationID"), &assetScanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID)
	return err
}

// GetAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanEstimationID", ctx.Param("assetScanEstimationID"), &assetScanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScanEstimationsAssetScanEstimationIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// PatchAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanEstimationID", ctx.Param("assetScanEstimationID"), &assetScanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetScanEstimationsAssetScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// PutAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanEstimationID", ctx.Param("assetScanEstimationID"), &assetScanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetScanEstimationsAssetScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// GetAssetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScans(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScansParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScans(ctx, params)
	return err
}

// PostAssetScans converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssetScans(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssetScans(ctx)
	return err
}

// GetAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanID", ctx.Param("assetScanID"), &assetScanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScansAssetScanIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// PatchAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanID", ctx.Param("assetScanID"), &assetScanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetScansAssetScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// PutAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanID", ctx.Param("assetScanID"), &assetScanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetScansAssetScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// GetAssets converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssets(ctx, params)
	return err
}

// PostAssets converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssets(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssets(ctx)
	return err
}

// DeleteAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithOptions("simple", "assetID", ctx.Param("assetID"), &assetID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAssetsAssetID(ctx, assetID)
	return err
}

// GetAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithOptions("simple", "assetID", ctx.Param("assetID"), &assetID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsAssetIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetsAssetID(ctx, assetID, params)
	return err
}

// PatchAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithOptions("simple", "assetID", ctx.Param("assetID"), &assetID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetsAssetIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetsAssetID(ctx, assetID, params)
	return err
}

// PutAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithOptions("simple", "assetID", ctx.Param("assetID"), &assetID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetsAssetIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetsAssetID(ctx, assetID, params)
	return err
}

// GetFindings converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindings(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFindings(ctx, params)
	return err
}

// PostFindings converts echo context to params.
func (w *ServerInterfaceWrapper) PostFindings(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFindings(ctx)
	return err
}

// DeleteFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithOptions("simple", "findingID", ctx.Param("findingID"), &findingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteFindingsFindingID(ctx, findingID)
	return err
}

// GetFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithOptions("simple", "findingID", ctx.Param("findingID"), &findingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsFindingIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFindingsFindingID(ctx, findingID, params)
	return err
}

// PatchFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithOptions("simple", "findingID", ctx.Param("findingID"), &findingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchFindingsFindingID(ctx, findingID)
	return err
}

// PutFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PutFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithOptions("simple", "findingID", ctx.Param("findingID"), &findingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutFindingsFindingID(ctx, findingID)
	return err
}

// GetOpenAPISpec converts echo context to params.
func (w *ServerInterfaceWrapper) GetOpenAPISpec(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOpenAPISpec(ctx)
	return err
}

// GetProviders converts echo context to params.
func (w *ServerInterfaceWrapper) GetProviders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProvidersParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProviders(ctx, params)
	return err
}

// PostProviders converts echo context to params.
func (w *ServerInterfaceWrapper) PostProviders(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostProviders(ctx)
	return err
}

// DeleteProvidersProviderID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProvidersProviderID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "providerID" -------------
	var providerID ProviderID

	err = runtime.BindStyledParameterWithOptions("simple", "providerID", ctx.Param("providerID"), &providerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter providerID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteProvidersProviderID(ctx, providerID)
	return err
}

// GetProvidersProviderID converts echo context to params.
func (w *ServerInterfaceWrapper) GetProvidersProviderID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "providerID" -------------
	var providerID ProviderID

	err = runtime.BindStyledParameterWithOptions("simple", "providerID", ctx.Param("providerID"), &providerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter providerID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProvidersProviderIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProvidersProviderID(ctx, providerID, params)
	return err
}

// PatchProvidersProviderID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchProvidersProviderID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "providerID" -------------
	var providerID ProviderID

	err = runtime.BindStyledParameterWithOptions("simple", "providerID", ctx.Param("providerID"), &providerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter providerID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchProvidersProviderIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchProvidersProviderID(ctx, providerID, params)
	return err
}

// PutProvidersProviderID converts echo context to params.
func (w *ServerInterfaceWrapper) PutProvidersProviderID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "providerID" -------------
	var providerID ProviderID

	err = runtime.BindStyledParameterWithOptions("simple", "providerID", ctx.Param("providerID"), &providerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter providerID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutProvidersProviderIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutProvidersProviderID(ctx, providerID, params)
	return err
}

// GetScanConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanConfigs(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanConfigsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanConfigs(ctx, params)
	return err
}

// PostScanConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) PostScanConfigs(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScanConfigs(ctx)
	return err
}

// DeleteScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithOptions("simple", "scanConfigID", ctx.Param("scanConfigID"), &scanConfigID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScanConfigsScanConfigID(ctx, scanConfigID)
	return err
}

// GetScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithOptions("simple", "scanConfigID", ctx.Param("scanConfigID"), &scanConfigID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanConfigsScanConfigIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// PatchScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithOptions("simple", "scanConfigID", ctx.Param("scanConfigID"), &scanConfigID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScanConfigsScanConfigIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// PutScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithOptions("simple", "scanConfigID", ctx.Param("scanConfigID"), &scanConfigID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScanConfigsScanConfigIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// GetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanEstimations(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanEstimationsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanEstimations(ctx, params)
	return err
}

// PostScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) PostScanEstimations(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScanEstimations(ctx)
	return err
}

// DeleteScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "scanEstimationID", ctx.Param("scanEstimationID"), &scanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScanEstimationsScanEstimationID(ctx, scanEstimationID)
	return err
}

// GetScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "scanEstimationID", ctx.Param("scanEstimationID"), &scanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanEstimationsScanEstimationIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// PatchScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "scanEstimationID", ctx.Param("scanEstimationID"), &scanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScanEstimationsScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// PutScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "scanEstimationID", ctx.Param("scanEstimationID"), &scanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScanEstimationsScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// GetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetScans(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScans(ctx, params)
	return err
}

// PostScans converts echo context to params.
func (w *ServerInterfaceWrapper) PostScans(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScans(ctx)
	return err
}

// DeleteScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScansScanID(ctx, scanID)
	return err
}

// GetScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansScanIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScansScanID(ctx, scanID, params)
	return err
}

// PatchScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScansScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScansScanID(ctx, scanID, params)
	return err
}

// PutScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScansScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScansScanID(ctx, scanID, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/assetFindings", wrapper.GetAssetFindings)
	router.POST(baseURL+"/assetFindings", wrapper.PostAssetFindings)
	router.DELETE(baseURL+"/assetFindings/:assetFindingID", wrapper.DeleteAssetFindingsAssetFindingID)
	router.GET(baseURL+"/assetFindings/:assetFindingID", wrapper.GetAssetFindingsAssetFindingID)
	router.PATCH(baseURL+"/assetFindings/:assetFindingID", wrapper.PatchAssetFindingsAssetFindingID)
	router.PUT(baseURL+"/assetFindings/:assetFindingID", wrapper.PutAssetFindingsAssetFindingID)
	router.GET(baseURL+"/assetScanEstimations", wrapper.GetAssetScanEstimations)
	router.POST(baseURL+"/assetScanEstimations", wrapper.PostAssetScanEstimations)
	router.DELETE(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.DeleteAssetScanEstimationsAssetScanEstimationID)
	router.GET(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.GetAssetScanEstimationsAssetScanEstimationID)
	router.PATCH(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.PatchAssetScanEstimationsAssetScanEstimationID)
	router.PUT(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.PutAssetScanEstimationsAssetScanEstimationID)
	router.GET(baseURL+"/assetScans", wrapper.GetAssetScans)
	router.POST(baseURL+"/assetScans", wrapper.PostAssetScans)
	router.GET(baseURL+"/assetScans/:assetScanID", wrapper.GetAssetScansAssetScanID)
	router.PATCH(baseURL+"/assetScans/:assetScanID", wrapper.PatchAssetScansAssetScanID)
	router.PUT(baseURL+"/assetScans/:assetScanID", wrapper.PutAssetScansAssetScanID)
	router.GET(baseURL+"/assets", wrapper.GetAssets)
	router.POST(baseURL+"/assets", wrapper.PostAssets)
	router.DELETE(baseURL+"/assets/:assetID", wrapper.DeleteAssetsAssetID)
	router.GET(baseURL+"/assets/:assetID", wrapper.GetAssetsAssetID)
	router.PATCH(baseURL+"/assets/:assetID", wrapper.PatchAssetsAssetID)
	router.PUT(baseURL+"/assets/:assetID", wrapper.PutAssetsAssetID)
	router.GET(baseURL+"/findings", wrapper.GetFindings)
	router.POST(baseURL+"/findings", wrapper.PostFindings)
	router.DELETE(baseURL+"/findings/:findingID", wrapper.DeleteFindingsFindingID)
	router.GET(baseURL+"/findings/:findingID", wrapper.GetFindingsFindingID)
	router.PATCH(baseURL+"/findings/:findingID", wrapper.PatchFindingsFindingID)
	router.PUT(baseURL+"/findings/:findingID", wrapper.PutFindingsFindingID)
	router.GET(baseURL+"/openapi.json", wrapper.GetOpenAPISpec)
	router.GET(baseURL+"/providers", wrapper.GetProviders)
	router.POST(baseURL+"/providers", wrapper.PostProviders)
	router.DELETE(baseURL+"/providers/:providerID", wrapper.DeleteProvidersProviderID)
	router.GET(baseURL+"/providers/:providerID", wrapper.GetProvidersProviderID)
	router.PATCH(baseURL+"/providers/:providerID", wrapper.PatchProvidersProviderID)
	router.PUT(baseURL+"/providers/:providerID", wrapper.PutProvidersProviderID)
	router.GET(baseURL+"/scanConfigs", wrapper.GetScanConfigs)
	router.POST(baseURL+"/scanConfigs", wrapper.PostScanConfigs)
	router.DELETE(baseURL+"/scanConfigs/:scanConfigID", wrapper.DeleteScanConfigsScanConfigID)
	router.GET(baseURL+"/scanConfigs/:scanConfigID", wrapper.GetScanConfigsScanConfigID)
	router.PATCH(baseURL+"/scanConfigs/:scanConfigID", wrapper.PatchScanConfigsScanConfigID)
	router.PUT(baseURL+"/scanConfigs/:scanConfigID", wrapper.PutScanConfigsScanConfigID)
	router.GET(baseURL+"/scanEstimations", wrapper.GetScanEstimations)
	router.POST(baseURL+"/scanEstimations", wrapper.PostScanEstimations)
	router.DELETE(baseURL+"/scanEstimations/:scanEstimationID", wrapper.DeleteScanEstimationsScanEstimationID)
	router.GET(baseURL+"/scanEstimations/:scanEstimationID", wrapper.GetScanEstimationsScanEstimationID)
	router.PATCH(baseURL+"/scanEstimations/:scanEstimationID", wrapper.PatchScanEstimationsScanEstimationID)
	router.PUT(baseURL+"/scanEstimations/:scanEstimationID", wrapper.PutScanEstimationsScanEstimationID)
	router.GET(baseURL+"/scans", wrapper.GetScans)
	router.POST(baseURL+"/scans", wrapper.PostScans)
	router.DELETE(baseURL+"/scans/:scanID", wrapper.DeleteScansScanID)
	router.GET(baseURL+"/scans/:scanID", wrapper.GetScansScanID)
	router.PATCH(baseURL+"/scans/:scanID", wrapper.PatchScansScanID)
	router.PUT(baseURL+"/scans/:scanID", wrapper.PutScansScanID)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
