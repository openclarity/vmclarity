// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.2.0 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	. "github.com/openclarity/vmclarity/api/types"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get asset scan estimations according to the given filters
	// (GET /assetScanEstimations)
	GetAssetScanEstimations(ctx echo.Context, params GetAssetScanEstimationsParams) error
	// Create an asset scan estimation for a specified asset
	// (POST /assetScanEstimations)
	PostAssetScanEstimations(ctx echo.Context) error
	// Delete an asset scan estimation.
	// (DELETE /assetScanEstimations/{assetScanEstimationID})
	DeleteAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID) error
	// Get an asset scan estimation.
	// (GET /assetScanEstimations/{assetScanEstimationID})
	GetAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params GetAssetScanEstimationsAssetScanEstimationIDParams) error
	// Patch an asset scan estimation
	// (PATCH /assetScanEstimations/{assetScanEstimationID})
	PatchAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params PatchAssetScanEstimationsAssetScanEstimationIDParams) error
	// Update an asset scan estimation.
	// (PUT /assetScanEstimations/{assetScanEstimationID})
	PutAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params PutAssetScanEstimationsAssetScanEstimationIDParams) error
	// Get asset scans according to the given filters
	// (GET /assetScans)
	GetAssetScans(ctx echo.Context, params GetAssetScansParams) error
	// Create an asset scan for a specified asset
	// (POST /assetScans)
	PostAssetScans(ctx echo.Context) error
	// Get an asset scan.
	// (GET /assetScans/{assetScanID})
	GetAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params GetAssetScansAssetScanIDParams) error
	// Patch an asset scan
	// (PATCH /assetScans/{assetScanID})
	PatchAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params PatchAssetScansAssetScanIDParams) error
	// Update an asset scan.
	// (PUT /assetScans/{assetScanID})
	PutAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params PutAssetScansAssetScanIDParams) error
	// Get assets
	// (GET /assets)
	GetAssets(ctx echo.Context, params GetAssetsParams) error
	// Create asset
	// (POST /assets)
	PostAssets(ctx echo.Context) error
	// Delete asset.
	// (DELETE /assets/{assetID})
	DeleteAssetsAssetID(ctx echo.Context, assetID AssetID) error
	// Get asset.
	// (GET /assets/{assetID})
	GetAssetsAssetID(ctx echo.Context, assetID AssetID, params GetAssetsAssetIDParams) error
	// Update asset.
	// (PATCH /assets/{assetID})
	PatchAssetsAssetID(ctx echo.Context, assetID AssetID, params PatchAssetsAssetIDParams) error
	// Update asset.
	// (PUT /assets/{assetID})
	PutAssetsAssetID(ctx echo.Context, assetID AssetID, params PutAssetsAssetIDParams) error
	// Get all findings.
	// (GET /findings)
	GetFindings(ctx echo.Context, params GetFindingsParams) error
	// Create a finding
	// (POST /findings)
	PostFindings(ctx echo.Context) error
	// Delete a finding.
	// (DELETE /findings/{findingID})
	DeleteFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Get the details for a finding.
	// (GET /findings/{findingID})
	GetFindingsFindingID(ctx echo.Context, findingID FindingID, params GetFindingsFindingIDParams) error
	// Patch a finding.
	// (PATCH /findings/{findingID})
	PatchFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Update a finding.
	// (PUT /findings/{findingID})
	PutFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Get this OpenAPI spec
	// (GET /openapi.json)
	GetOpenAPISpec(ctx echo.Context) error
	// Get providers
	// (GET /providers)
	GetProviders(ctx echo.Context, params GetProvidersParams) error
	// Create provider
	// (POST /providers)
	PostProviders(ctx echo.Context) error
	// Delete provider.
	// (DELETE /providers/{providerID})
	DeleteProvidersProviderID(ctx echo.Context, providerID ProviderID) error
	// Get provider.
	// (GET /providers/{providerID})
	GetProvidersProviderID(ctx echo.Context, providerID ProviderID, params GetProvidersProviderIDParams) error
	// Update provider.
	// (PATCH /providers/{providerID})
	PatchProvidersProviderID(ctx echo.Context, providerID ProviderID, params PatchProvidersProviderIDParams) error
	// Update provider.
	// (PUT /providers/{providerID})
	PutProvidersProviderID(ctx echo.Context, providerID ProviderID, params PutProvidersProviderIDParams) error
	// Get all scan configs.
	// (GET /scanConfigs)
	GetScanConfigs(ctx echo.Context, params GetScanConfigsParams) error
	// Create a scan config
	// (POST /scanConfigs)
	PostScanConfigs(ctx echo.Context) error
	// Delete a scan config.
	// (DELETE /scanConfigs/{scanConfigID})
	DeleteScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID) error
	// Get the details for a scan config.
	// (GET /scanConfigs/{scanConfigID})
	GetScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params GetScanConfigsScanConfigIDParams) error
	// Patch a scan config.
	// (PATCH /scanConfigs/{scanConfigID})
	PatchScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params PatchScanConfigsScanConfigIDParams) error
	// Update a scan config.
	// (PUT /scanConfigs/{scanConfigID})
	PutScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params PutScanConfigsScanConfigIDParams) error
	// Get all scan estimations. Each scan estimation contains details about a multi-asset scan estimation.
	// (GET /scanEstimations)
	GetScanEstimations(ctx echo.Context, params GetScanEstimationsParams) error
	// Create a multi-asset scan estimation
	// (POST /scanEstimations)
	PostScanEstimations(ctx echo.Context) error
	// Delete a scan estimation.
	// (DELETE /scanEstimations/{scanEstimationID})
	DeleteScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID) error
	// Get the details for a given multi-asset scan estimation.
	// (GET /scanEstimations/{scanEstimationID})
	GetScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params GetScanEstimationsScanEstimationIDParams) error
	// Patch a scan estimation.
	// (PATCH /scanEstimations/{scanEstimationID})
	PatchScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params PatchScanEstimationsScanEstimationIDParams) error
	// Update a scan estimation.
	// (PUT /scanEstimations/{scanEstimationID})
	PutScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params PutScanEstimationsScanEstimationIDParams) error
	// Get all scans. Each scan contains details about a multi-asset scheduled scan.
	// (GET /scans)
	GetScans(ctx echo.Context, params GetScansParams) error
	// Create a multi-asset scheduled scan
	// (POST /scans)
	PostScans(ctx echo.Context) error
	// Delete a scan.
	// (DELETE /scans/{scanID})
	DeleteScansScanID(ctx echo.Context, scanID ScanID) error
	// Get the details for a given multi-asset scheduled scan.
	// (GET /scans/{scanID})
	GetScansScanID(ctx echo.Context, scanID ScanID, params GetScansScanIDParams) error
	// Patch a scan.
	// (PATCH /scans/{scanID})
	PatchScansScanID(ctx echo.Context, scanID ScanID, params PatchScansScanIDParams) error
	// Update a scan.
	// (PUT /scans/{scanID})
	PutScansScanID(ctx echo.Context, scanID ScanID, params PutScansScanIDParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAssetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScanEstimations(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScanEstimationsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScanEstimations(ctx, params)
	return err
}

// PostAssetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssetScanEstimations(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssetScanEstimations(ctx)
	return err
}

// DeleteAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanEstimationID", ctx.Param("assetScanEstimationID"), &assetScanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID)
	return err
}

// GetAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanEstimationID", ctx.Param("assetScanEstimationID"), &assetScanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScanEstimationsAssetScanEstimationIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// PatchAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanEstimationID", ctx.Param("assetScanEstimationID"), &assetScanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetScanEstimationsAssetScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// PutAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanEstimationID", ctx.Param("assetScanEstimationID"), &assetScanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetScanEstimationsAssetScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// GetAssetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScans(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScansParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScans(ctx, params)
	return err
}

// PostAssetScans converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssetScans(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssetScans(ctx)
	return err
}

// GetAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanID", ctx.Param("assetScanID"), &assetScanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScansAssetScanIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// PatchAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanID", ctx.Param("assetScanID"), &assetScanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetScansAssetScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// PutAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanID", ctx.Param("assetScanID"), &assetScanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetScansAssetScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// GetAssets converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssets(ctx, params)
	return err
}

// PostAssets converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssets(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssets(ctx)
	return err
}

// DeleteAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithOptions("simple", "assetID", ctx.Param("assetID"), &assetID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAssetsAssetID(ctx, assetID)
	return err
}

// GetAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithOptions("simple", "assetID", ctx.Param("assetID"), &assetID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsAssetIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetsAssetID(ctx, assetID, params)
	return err
}

// PatchAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithOptions("simple", "assetID", ctx.Param("assetID"), &assetID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetsAssetIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetsAssetID(ctx, assetID, params)
	return err
}

// PutAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithOptions("simple", "assetID", ctx.Param("assetID"), &assetID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetsAssetIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetsAssetID(ctx, assetID, params)
	return err
}

// GetFindings converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindings(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFindings(ctx, params)
	return err
}

// PostFindings converts echo context to params.
func (w *ServerInterfaceWrapper) PostFindings(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFindings(ctx)
	return err
}

// DeleteFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithOptions("simple", "findingID", ctx.Param("findingID"), &findingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteFindingsFindingID(ctx, findingID)
	return err
}

// GetFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithOptions("simple", "findingID", ctx.Param("findingID"), &findingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsFindingIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFindingsFindingID(ctx, findingID, params)
	return err
}

// PatchFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithOptions("simple", "findingID", ctx.Param("findingID"), &findingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchFindingsFindingID(ctx, findingID)
	return err
}

// PutFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PutFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithOptions("simple", "findingID", ctx.Param("findingID"), &findingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutFindingsFindingID(ctx, findingID)
	return err
}

// GetOpenAPISpec converts echo context to params.
func (w *ServerInterfaceWrapper) GetOpenAPISpec(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOpenAPISpec(ctx)
	return err
}

// GetProviders converts echo context to params.
func (w *ServerInterfaceWrapper) GetProviders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProvidersParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProviders(ctx, params)
	return err
}

// PostProviders converts echo context to params.
func (w *ServerInterfaceWrapper) PostProviders(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostProviders(ctx)
	return err
}

// DeleteProvidersProviderID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProvidersProviderID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "providerID" -------------
	var providerID ProviderID

	err = runtime.BindStyledParameterWithOptions("simple", "providerID", ctx.Param("providerID"), &providerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter providerID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteProvidersProviderID(ctx, providerID)
	return err
}

// GetProvidersProviderID converts echo context to params.
func (w *ServerInterfaceWrapper) GetProvidersProviderID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "providerID" -------------
	var providerID ProviderID

	err = runtime.BindStyledParameterWithOptions("simple", "providerID", ctx.Param("providerID"), &providerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter providerID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProvidersProviderIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProvidersProviderID(ctx, providerID, params)
	return err
}

// PatchProvidersProviderID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchProvidersProviderID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "providerID" -------------
	var providerID ProviderID

	err = runtime.BindStyledParameterWithOptions("simple", "providerID", ctx.Param("providerID"), &providerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter providerID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchProvidersProviderIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchProvidersProviderID(ctx, providerID, params)
	return err
}

// PutProvidersProviderID converts echo context to params.
func (w *ServerInterfaceWrapper) PutProvidersProviderID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "providerID" -------------
	var providerID ProviderID

	err = runtime.BindStyledParameterWithOptions("simple", "providerID", ctx.Param("providerID"), &providerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter providerID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutProvidersProviderIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutProvidersProviderID(ctx, providerID, params)
	return err
}

// GetScanConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanConfigs(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanConfigsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanConfigs(ctx, params)
	return err
}

// PostScanConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) PostScanConfigs(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScanConfigs(ctx)
	return err
}

// DeleteScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithOptions("simple", "scanConfigID", ctx.Param("scanConfigID"), &scanConfigID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScanConfigsScanConfigID(ctx, scanConfigID)
	return err
}

// GetScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithOptions("simple", "scanConfigID", ctx.Param("scanConfigID"), &scanConfigID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanConfigsScanConfigIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// PatchScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithOptions("simple", "scanConfigID", ctx.Param("scanConfigID"), &scanConfigID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScanConfigsScanConfigIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// PutScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithOptions("simple", "scanConfigID", ctx.Param("scanConfigID"), &scanConfigID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScanConfigsScanConfigIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// GetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanEstimations(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanEstimationsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanEstimations(ctx, params)
	return err
}

// PostScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) PostScanEstimations(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScanEstimations(ctx)
	return err
}

// DeleteScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "scanEstimationID", ctx.Param("scanEstimationID"), &scanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScanEstimationsScanEstimationID(ctx, scanEstimationID)
	return err
}

// GetScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "scanEstimationID", ctx.Param("scanEstimationID"), &scanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanEstimationsScanEstimationIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// PatchScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "scanEstimationID", ctx.Param("scanEstimationID"), &scanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScanEstimationsScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// PutScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "scanEstimationID", ctx.Param("scanEstimationID"), &scanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScanEstimationsScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// GetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetScans(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScans(ctx, params)
	return err
}

// PostScans converts echo context to params.
func (w *ServerInterfaceWrapper) PostScans(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScans(ctx)
	return err
}

// DeleteScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScansScanID(ctx, scanID)
	return err
}

// GetScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansScanIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScansScanID(ctx, scanID, params)
	return err
}

// PatchScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScansScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScansScanID(ctx, scanID, params)
	return err
}

// PutScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScansScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScansScanID(ctx, scanID, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/assetScanEstimations", wrapper.GetAssetScanEstimations)
	router.POST(baseURL+"/assetScanEstimations", wrapper.PostAssetScanEstimations)
	router.DELETE(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.DeleteAssetScanEstimationsAssetScanEstimationID)
	router.GET(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.GetAssetScanEstimationsAssetScanEstimationID)
	router.PATCH(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.PatchAssetScanEstimationsAssetScanEstimationID)
	router.PUT(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.PutAssetScanEstimationsAssetScanEstimationID)
	router.GET(baseURL+"/assetScans", wrapper.GetAssetScans)
	router.POST(baseURL+"/assetScans", wrapper.PostAssetScans)
	router.GET(baseURL+"/assetScans/:assetScanID", wrapper.GetAssetScansAssetScanID)
	router.PATCH(baseURL+"/assetScans/:assetScanID", wrapper.PatchAssetScansAssetScanID)
	router.PUT(baseURL+"/assetScans/:assetScanID", wrapper.PutAssetScansAssetScanID)
	router.GET(baseURL+"/assets", wrapper.GetAssets)
	router.POST(baseURL+"/assets", wrapper.PostAssets)
	router.DELETE(baseURL+"/assets/:assetID", wrapper.DeleteAssetsAssetID)
	router.GET(baseURL+"/assets/:assetID", wrapper.GetAssetsAssetID)
	router.PATCH(baseURL+"/assets/:assetID", wrapper.PatchAssetsAssetID)
	router.PUT(baseURL+"/assets/:assetID", wrapper.PutAssetsAssetID)
	router.GET(baseURL+"/findings", wrapper.GetFindings)
	router.POST(baseURL+"/findings", wrapper.PostFindings)
	router.DELETE(baseURL+"/findings/:findingID", wrapper.DeleteFindingsFindingID)
	router.GET(baseURL+"/findings/:findingID", wrapper.GetFindingsFindingID)
	router.PATCH(baseURL+"/findings/:findingID", wrapper.PatchFindingsFindingID)
	router.PUT(baseURL+"/findings/:findingID", wrapper.PutFindingsFindingID)
	router.GET(baseURL+"/openapi.json", wrapper.GetOpenAPISpec)
	router.GET(baseURL+"/providers", wrapper.GetProviders)
	router.POST(baseURL+"/providers", wrapper.PostProviders)
	router.DELETE(baseURL+"/providers/:providerID", wrapper.DeleteProvidersProviderID)
	router.GET(baseURL+"/providers/:providerID", wrapper.GetProvidersProviderID)
	router.PATCH(baseURL+"/providers/:providerID", wrapper.PatchProvidersProviderID)
	router.PUT(baseURL+"/providers/:providerID", wrapper.PutProvidersProviderID)
	router.GET(baseURL+"/scanConfigs", wrapper.GetScanConfigs)
	router.POST(baseURL+"/scanConfigs", wrapper.PostScanConfigs)
	router.DELETE(baseURL+"/scanConfigs/:scanConfigID", wrapper.DeleteScanConfigsScanConfigID)
	router.GET(baseURL+"/scanConfigs/:scanConfigID", wrapper.GetScanConfigsScanConfigID)
	router.PATCH(baseURL+"/scanConfigs/:scanConfigID", wrapper.PatchScanConfigsScanConfigID)
	router.PUT(baseURL+"/scanConfigs/:scanConfigID", wrapper.PutScanConfigsScanConfigID)
	router.GET(baseURL+"/scanEstimations", wrapper.GetScanEstimations)
	router.POST(baseURL+"/scanEstimations", wrapper.PostScanEstimations)
	router.DELETE(baseURL+"/scanEstimations/:scanEstimationID", wrapper.DeleteScanEstimationsScanEstimationID)
	router.GET(baseURL+"/scanEstimations/:scanEstimationID", wrapper.GetScanEstimationsScanEstimationID)
	router.PATCH(baseURL+"/scanEstimations/:scanEstimationID", wrapper.PatchScanEstimationsScanEstimationID)
	router.PUT(baseURL+"/scanEstimations/:scanEstimationID", wrapper.PutScanEstimationsScanEstimationID)
	router.GET(baseURL+"/scans", wrapper.GetScans)
	router.POST(baseURL+"/scans", wrapper.PostScans)
	router.DELETE(baseURL+"/scans/:scanID", wrapper.DeleteScansScanID)
	router.GET(baseURL+"/scans/:scanID", wrapper.GetScansScanID)
	router.PATCH(baseURL+"/scans/:scanID", wrapper.PatchScansScanID)
	router.PUT(baseURL+"/scans/:scanID", wrapper.PutScansScanID)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
