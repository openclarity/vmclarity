// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.0 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	. "github.com/openclarity/vmclarity/api/models"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get asset scan estimations according to the given filters
	// (GET /assetScanEstimations)
	GetAssetScanEstimations(ctx echo.Context, params GetAssetScanEstimationsParams) error
	// Create an asset scan estimation for a specified asset
	// (POST /assetScanEstimations)
	PostAssetScanEstimations(ctx echo.Context) error
	// Delete an asset scan estimation.
	// (DELETE /assetScanEstimations/{assetScanEstimationID})
	DeleteAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID) error
	// Get an asset scan estimation.
	// (GET /assetScanEstimations/{assetScanEstimationID})
	GetAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params GetAssetScanEstimationsAssetScanEstimationIDParams) error
	// Patch an asset scan estimation
	// (PATCH /assetScanEstimations/{assetScanEstimationID})
	PatchAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params PatchAssetScanEstimationsAssetScanEstimationIDParams) error
	// Update an asset scan estimation.
	// (PUT /assetScanEstimations/{assetScanEstimationID})
	PutAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params PutAssetScanEstimationsAssetScanEstimationIDParams) error
	// Get asset scans according to the given filters
	// (GET /assetScans)
	GetAssetScans(ctx echo.Context, params GetAssetScansParams) error
	// Create an asset scan for a specified asset
	// (POST /assetScans)
	PostAssetScans(ctx echo.Context) error
	// Get an asset scan.
	// (GET /assetScans/{assetScanID})
	GetAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params GetAssetScansAssetScanIDParams) error
	// Patch an asset scan
	// (PATCH /assetScans/{assetScanID})
	PatchAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params PatchAssetScansAssetScanIDParams) error
	// Update an asset scan.
	// (PUT /assetScans/{assetScanID})
	PutAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params PutAssetScansAssetScanIDParams) error
	// Get assets
	// (GET /assets)
	GetAssets(ctx echo.Context, params GetAssetsParams) error
	// Create asset
	// (POST /assets)
	PostAssets(ctx echo.Context) error
	// Delete asset.
	// (DELETE /assets/{assetID})
	DeleteAssetsAssetID(ctx echo.Context, assetID AssetID) error
	// Get asset.
	// (GET /assets/{assetID})
	GetAssetsAssetID(ctx echo.Context, assetID AssetID, params GetAssetsAssetIDParams) error
	// Update asset.
	// (PATCH /assets/{assetID})
	PatchAssetsAssetID(ctx echo.Context, assetID AssetID, params PatchAssetsAssetIDParams) error
	// Update asset.
	// (PUT /assets/{assetID})
	PutAssetsAssetID(ctx echo.Context, assetID AssetID, params PutAssetsAssetIDParams) error
	// Get all findings.
	// (GET /findings)
	GetFindings(ctx echo.Context, params GetFindingsParams) error
	// Create a finding
	// (POST /findings)
	PostFindings(ctx echo.Context) error
	// Delete a finding.
	// (DELETE /findings/{findingID})
	DeleteFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Get the details for a finding.
	// (GET /findings/{findingID})
	GetFindingsFindingID(ctx echo.Context, findingID FindingID, params GetFindingsFindingIDParams) error
	// Patch a finding.
	// (PATCH /findings/{findingID})
	PatchFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Update a finding.
	// (PUT /findings/{findingID})
	PutFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Get this OpenAPI spec
	// (GET /openapi.json)
	GetOpenAPISpec(ctx echo.Context) error
	// Get all scan configs.
	// (GET /scanConfigs)
	GetScanConfigs(ctx echo.Context, params GetScanConfigsParams) error
	// Create a scan config
	// (POST /scanConfigs)
	PostScanConfigs(ctx echo.Context) error
	// Delete a scan config.
	// (DELETE /scanConfigs/{scanConfigID})
	DeleteScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID) error
	// Get the details for a scan config.
	// (GET /scanConfigs/{scanConfigID})
	GetScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params GetScanConfigsScanConfigIDParams) error
	// Patch a scan config.
	// (PATCH /scanConfigs/{scanConfigID})
	PatchScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params PatchScanConfigsScanConfigIDParams) error
	// Update a scan config.
	// (PUT /scanConfigs/{scanConfigID})
	PutScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params PutScanConfigsScanConfigIDParams) error
	// Get all scan estimations. Each scan estimation contains details about a multi-asset scan estimation.
	// (GET /scanEstimations)
	GetScanEstimations(ctx echo.Context, params GetScanEstimationsParams) error
	// Create a multi-asset scan estimation
	// (POST /scanEstimations)
	PostScanEstimations(ctx echo.Context) error
	// Delete a scan estimation.
	// (DELETE /scanEstimations/{scanEstimationID})
	DeleteScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID) error
	// Get the details for a given multi-asset scan estimation.
	// (GET /scanEstimations/{scanEstimationID})
	GetScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params GetScanEstimationsScanEstimationIDParams) error
	// Patch a scan estimation.
	// (PATCH /scanEstimations/{scanEstimationID})
	PatchScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params PatchScanEstimationsScanEstimationIDParams) error
	// Update a scan estimation.
	// (PUT /scanEstimations/{scanEstimationID})
	PutScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params PutScanEstimationsScanEstimationIDParams) error
	// Get all scans. Each scan contains details about a multi-asset scheduled scan.
	// (GET /scans)
	GetScans(ctx echo.Context, params GetScansParams) error
	// Create a multi-asset scheduled scan
	// (POST /scans)
	PostScans(ctx echo.Context) error
	// Delete a scan.
	// (DELETE /scans/{scanID})
	DeleteScansScanID(ctx echo.Context, scanID ScanID) error
	// Get the details for a given multi-asset scheduled scan.
	// (GET /scans/{scanID})
	GetScansScanID(ctx echo.Context, scanID ScanID, params GetScansScanIDParams) error
	// Patch a scan.
	// (PATCH /scans/{scanID})
	PatchScansScanID(ctx echo.Context, scanID ScanID, params PatchScansScanIDParams) error
	// Update a scan.
	// (PUT /scans/{scanID})
	PutScansScanID(ctx echo.Context, scanID ScanID, params PutScansScanIDParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAssetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScanEstimations(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScanEstimationsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScanEstimations(ctx, params)
	return err
}

// PostAssetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssetScanEstimations(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssetScanEstimations(ctx)
	return err
}

// DeleteAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanEstimationID", runtime.ParamLocationPath, ctx.Param("assetScanEstimationID"), &assetScanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID)
	return err
}

// GetAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanEstimationID", runtime.ParamLocationPath, ctx.Param("assetScanEstimationID"), &assetScanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScanEstimationsAssetScanEstimationIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// PatchAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanEstimationID", runtime.ParamLocationPath, ctx.Param("assetScanEstimationID"), &assetScanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetScanEstimationsAssetScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// PutAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanEstimationID", runtime.ParamLocationPath, ctx.Param("assetScanEstimationID"), &assetScanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetScanEstimationsAssetScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// GetAssetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScans(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScansParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScans(ctx, params)
	return err
}

// PostAssetScans converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssetScans(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssetScans(ctx)
	return err
}

// GetAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanID", runtime.ParamLocationPath, ctx.Param("assetScanID"), &assetScanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScansAssetScanIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// PatchAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanID", runtime.ParamLocationPath, ctx.Param("assetScanID"), &assetScanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetScansAssetScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// PutAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanID", runtime.ParamLocationPath, ctx.Param("assetScanID"), &assetScanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetScansAssetScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// GetAssets converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssets(ctx, params)
	return err
}

// PostAssets converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssets(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssets(ctx)
	return err
}

// DeleteAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetID", runtime.ParamLocationPath, ctx.Param("assetID"), &assetID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAssetsAssetID(ctx, assetID)
	return err
}

// GetAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetID", runtime.ParamLocationPath, ctx.Param("assetID"), &assetID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsAssetIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetsAssetID(ctx, assetID, params)
	return err
}

// PatchAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetID", runtime.ParamLocationPath, ctx.Param("assetID"), &assetID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetsAssetIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetsAssetID(ctx, assetID, params)
	return err
}

// PutAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetID", runtime.ParamLocationPath, ctx.Param("assetID"), &assetID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetsAssetIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetsAssetID(ctx, assetID, params)
	return err
}

// GetFindings converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindings(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFindings(ctx, params)
	return err
}

// PostFindings converts echo context to params.
func (w *ServerInterfaceWrapper) PostFindings(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFindings(ctx)
	return err
}

// DeleteFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithLocation("simple", false, "findingID", runtime.ParamLocationPath, ctx.Param("findingID"), &findingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteFindingsFindingID(ctx, findingID)
	return err
}

// GetFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithLocation("simple", false, "findingID", runtime.ParamLocationPath, ctx.Param("findingID"), &findingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsFindingIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFindingsFindingID(ctx, findingID, params)
	return err
}

// PatchFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithLocation("simple", false, "findingID", runtime.ParamLocationPath, ctx.Param("findingID"), &findingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchFindingsFindingID(ctx, findingID)
	return err
}

// PutFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PutFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithLocation("simple", false, "findingID", runtime.ParamLocationPath, ctx.Param("findingID"), &findingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutFindingsFindingID(ctx, findingID)
	return err
}

// GetOpenAPISpec converts echo context to params.
func (w *ServerInterfaceWrapper) GetOpenAPISpec(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOpenAPISpec(ctx)
	return err
}

// GetScanConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanConfigs(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanConfigsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanConfigs(ctx, params)
	return err
}

// PostScanConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) PostScanConfigs(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScanConfigs(ctx)
	return err
}

// DeleteScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanConfigID", runtime.ParamLocationPath, ctx.Param("scanConfigID"), &scanConfigID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScanConfigsScanConfigID(ctx, scanConfigID)
	return err
}

// GetScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanConfigID", runtime.ParamLocationPath, ctx.Param("scanConfigID"), &scanConfigID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanConfigsScanConfigIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// PatchScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanConfigID", runtime.ParamLocationPath, ctx.Param("scanConfigID"), &scanConfigID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScanConfigsScanConfigIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// PutScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanConfigID", runtime.ParamLocationPath, ctx.Param("scanConfigID"), &scanConfigID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScanConfigsScanConfigIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// GetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanEstimations(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanEstimationsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanEstimations(ctx, params)
	return err
}

// PostScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) PostScanEstimations(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScanEstimations(ctx)
	return err
}

// DeleteScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanEstimationID", runtime.ParamLocationPath, ctx.Param("scanEstimationID"), &scanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScanEstimationsScanEstimationID(ctx, scanEstimationID)
	return err
}

// GetScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanEstimationID", runtime.ParamLocationPath, ctx.Param("scanEstimationID"), &scanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanEstimationsScanEstimationIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// PatchScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanEstimationID", runtime.ParamLocationPath, ctx.Param("scanEstimationID"), &scanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScanEstimationsScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// PutScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanEstimationID", runtime.ParamLocationPath, ctx.Param("scanEstimationID"), &scanEstimationID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScanEstimationsScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// GetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetScans(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScans(ctx, params)
	return err
}

// PostScans converts echo context to params.
func (w *ServerInterfaceWrapper) PostScans(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScans(ctx)
	return err
}

// DeleteScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanID", runtime.ParamLocationPath, ctx.Param("scanID"), &scanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScansScanID(ctx, scanID)
	return err
}

// GetScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanID", runtime.ParamLocationPath, ctx.Param("scanID"), &scanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansScanIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScansScanID(ctx, scanID, params)
	return err
}

// PatchScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanID", runtime.ParamLocationPath, ctx.Param("scanID"), &scanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScansScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScansScanID(ctx, scanID, params)
	return err
}

// PutScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanID", runtime.ParamLocationPath, ctx.Param("scanID"), &scanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScansScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScansScanID(ctx, scanID, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/assetScanEstimations", wrapper.GetAssetScanEstimations)
	router.POST(baseURL+"/assetScanEstimations", wrapper.PostAssetScanEstimations)
	router.DELETE(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.DeleteAssetScanEstimationsAssetScanEstimationID)
	router.GET(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.GetAssetScanEstimationsAssetScanEstimationID)
	router.PATCH(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.PatchAssetScanEstimationsAssetScanEstimationID)
	router.PUT(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.PutAssetScanEstimationsAssetScanEstimationID)
	router.GET(baseURL+"/assetScans", wrapper.GetAssetScans)
	router.POST(baseURL+"/assetScans", wrapper.PostAssetScans)
	router.GET(baseURL+"/assetScans/:assetScanID", wrapper.GetAssetScansAssetScanID)
	router.PATCH(baseURL+"/assetScans/:assetScanID", wrapper.PatchAssetScansAssetScanID)
	router.PUT(baseURL+"/assetScans/:assetScanID", wrapper.PutAssetScansAssetScanID)
	router.GET(baseURL+"/assets", wrapper.GetAssets)
	router.POST(baseURL+"/assets", wrapper.PostAssets)
	router.DELETE(baseURL+"/assets/:assetID", wrapper.DeleteAssetsAssetID)
	router.GET(baseURL+"/assets/:assetID", wrapper.GetAssetsAssetID)
	router.PATCH(baseURL+"/assets/:assetID", wrapper.PatchAssetsAssetID)
	router.PUT(baseURL+"/assets/:assetID", wrapper.PutAssetsAssetID)
	router.GET(baseURL+"/findings", wrapper.GetFindings)
	router.POST(baseURL+"/findings", wrapper.PostFindings)
	router.DELETE(baseURL+"/findings/:findingID", wrapper.DeleteFindingsFindingID)
	router.GET(baseURL+"/findings/:findingID", wrapper.GetFindingsFindingID)
	router.PATCH(baseURL+"/findings/:findingID", wrapper.PatchFindingsFindingID)
	router.PUT(baseURL+"/findings/:findingID", wrapper.PutFindingsFindingID)
	router.GET(baseURL+"/openapi.json", wrapper.GetOpenAPISpec)
	router.GET(baseURL+"/scanConfigs", wrapper.GetScanConfigs)
	router.POST(baseURL+"/scanConfigs", wrapper.PostScanConfigs)
	router.DELETE(baseURL+"/scanConfigs/:scanConfigID", wrapper.DeleteScanConfigsScanConfigID)
	router.GET(baseURL+"/scanConfigs/:scanConfigID", wrapper.GetScanConfigsScanConfigID)
	router.PATCH(baseURL+"/scanConfigs/:scanConfigID", wrapper.PatchScanConfigsScanConfigID)
	router.PUT(baseURL+"/scanConfigs/:scanConfigID", wrapper.PutScanConfigsScanConfigID)
	router.GET(baseURL+"/scanEstimations", wrapper.GetScanEstimations)
	router.POST(baseURL+"/scanEstimations", wrapper.PostScanEstimations)
	router.DELETE(baseURL+"/scanEstimations/:scanEstimationID", wrapper.DeleteScanEstimationsScanEstimationID)
	router.GET(baseURL+"/scanEstimations/:scanEstimationID", wrapper.GetScanEstimationsScanEstimationID)
	router.PATCH(baseURL+"/scanEstimations/:scanEstimationID", wrapper.PatchScanEstimationsScanEstimationID)
	router.PUT(baseURL+"/scanEstimations/:scanEstimationID", wrapper.PutScanEstimationsScanEstimationID)
	router.GET(baseURL+"/scans", wrapper.GetScans)
	router.POST(baseURL+"/scans", wrapper.PostScans)
	router.DELETE(baseURL+"/scans/:scanID", wrapper.DeleteScansScanID)
	router.GET(baseURL+"/scans/:scanID", wrapper.GetScansScanID)
	router.PATCH(baseURL+"/scans/:scanID", wrapper.PatchScansScanID)
	router.PUT(baseURL+"/scans/:scanID", wrapper.PutScansScanID)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
