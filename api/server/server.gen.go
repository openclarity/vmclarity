// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	. "github.com/openclarity/vmclarity/api/models"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get asset scans according to the given filters
	// (GET /assetScans)
	GetAssetScans(ctx echo.Context, params GetAssetScansParams) error
	// Create an asset scan for a specified asset
	// (POST /assetScans)
	PostAssetScans(ctx echo.Context) error
	// Get an asset scan.
	// (GET /assetScans/{assetScanID})
	GetAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params GetAssetScansAssetScanIDParams) error
	// Patch an asset scan
	// (PATCH /assetScans/{assetScanID})
	PatchAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params PatchAssetScansAssetScanIDParams) error
	// Update an asset scan.
	// (PUT /assetScans/{assetScanID})
	PutAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params PutAssetScansAssetScanIDParams) error
	// Get assets
	// (GET /assets)
	GetAssets(ctx echo.Context, params GetAssetsParams) error
	// Create asset
	// (POST /assets)
	PostAssets(ctx echo.Context) error
	// Delete asset.
	// (DELETE /assets/{assetID})
	DeleteAssetsAssetID(ctx echo.Context, assetID AssetID) error
	// Get asset.
	// (GET /assets/{assetID})
	GetAssetsAssetID(ctx echo.Context, assetID AssetID, params GetAssetsAssetIDParams) error
	// Update asset.
	// (PATCH /assets/{assetID})
	PatchAssetsAssetID(ctx echo.Context, assetID AssetID, params PatchAssetsAssetIDParams) error
	// Update asset.
	// (PUT /assets/{assetID})
	PutAssetsAssetID(ctx echo.Context, assetID AssetID, params PutAssetsAssetIDParams) error
	// Get all findings.
	// (GET /findings)
	GetFindings(ctx echo.Context, params GetFindingsParams) error
	// Create a finding
	// (POST /findings)
	PostFindings(ctx echo.Context) error
	// Delete a finding.
	// (DELETE /findings/{findingID})
	DeleteFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Get the details for a finding.
	// (GET /findings/{findingID})
	GetFindingsFindingID(ctx echo.Context, findingID FindingID, params GetFindingsFindingIDParams) error
	// Patch a finding.
	// (PATCH /findings/{findingID})
	PatchFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Update a finding.
	// (PUT /findings/{findingID})
	PutFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Get all scan configs.
	// (GET /scanConfigs)
	GetScanConfigs(ctx echo.Context, params GetScanConfigsParams) error
	// Create a scan config
	// (POST /scanConfigs)
	PostScanConfigs(ctx echo.Context) error
	// Delete a scan config.
	// (DELETE /scanConfigs/{scanConfigID})
	DeleteScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID) error
	// Get the details for a scan config.
	// (GET /scanConfigs/{scanConfigID})
	GetScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params GetScanConfigsScanConfigIDParams) error
	// Patch a scan config.
	// (PATCH /scanConfigs/{scanConfigID})
	PatchScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params PatchScanConfigsScanConfigIDParams) error
	// Update a scan config.
	// (PUT /scanConfigs/{scanConfigID})
	PutScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params PutScanConfigsScanConfigIDParams) error
	// Get all scans. Each scan contains details about a multi-asset scheduled scan.
	// (GET /scans)
	GetScans(ctx echo.Context, params GetScansParams) error
	// Create a multi-asset scheduled scan
	// (POST /scans)
	PostScans(ctx echo.Context) error
	// Delete a scan.
	// (DELETE /scans/{scanID})
	DeleteScansScanID(ctx echo.Context, scanID ScanID) error
	// Get the details for a given multi-asset scheduled scan.
	// (GET /scans/{scanID})
	GetScansScanID(ctx echo.Context, scanID ScanID, params GetScansScanIDParams) error
	// Patch a scan.
	// (PATCH /scans/{scanID})
	PatchScansScanID(ctx echo.Context, scanID ScanID, params PatchScansScanIDParams) error
	// Update a scan.
	// (PUT /scans/{scanID})
	PutScansScanID(ctx echo.Context, scanID ScanID, params PutScansScanIDParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAssetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScans(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScansParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetScans(ctx, params)
	return err
}

// PostAssetScans converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssetScans(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostAssetScans(ctx)
	return err
}

// GetAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanID", runtime.ParamLocationPath, ctx.Param("assetScanID"), &assetScanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScansAssetScanIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// PatchAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanID", runtime.ParamLocationPath, ctx.Param("assetScanID"), &assetScanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetScansAssetScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// PutAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanID", runtime.ParamLocationPath, ctx.Param("assetScanID"), &assetScanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetScansAssetScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// GetAssets converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssets(ctx, params)
	return err
}

// PostAssets converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssets(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostAssets(ctx)
	return err
}

// DeleteAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetID", runtime.ParamLocationPath, ctx.Param("assetID"), &assetID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteAssetsAssetID(ctx, assetID)
	return err
}

// GetAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetID", runtime.ParamLocationPath, ctx.Param("assetID"), &assetID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsAssetIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetsAssetID(ctx, assetID, params)
	return err
}

// PatchAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetID", runtime.ParamLocationPath, ctx.Param("assetID"), &assetID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetsAssetIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchAssetsAssetID(ctx, assetID, params)
	return err
}

// PutAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetID", runtime.ParamLocationPath, ctx.Param("assetID"), &assetID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetsAssetIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutAssetsAssetID(ctx, assetID, params)
	return err
}

// GetFindings converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindings(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFindings(ctx, params)
	return err
}

// PostFindings converts echo context to params.
func (w *ServerInterfaceWrapper) PostFindings(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostFindings(ctx)
	return err
}

// DeleteFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithLocation("simple", false, "findingID", runtime.ParamLocationPath, ctx.Param("findingID"), &findingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteFindingsFindingID(ctx, findingID)
	return err
}

// GetFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithLocation("simple", false, "findingID", runtime.ParamLocationPath, ctx.Param("findingID"), &findingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsFindingIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFindingsFindingID(ctx, findingID, params)
	return err
}

// PatchFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithLocation("simple", false, "findingID", runtime.ParamLocationPath, ctx.Param("findingID"), &findingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchFindingsFindingID(ctx, findingID)
	return err
}

// PutFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PutFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithLocation("simple", false, "findingID", runtime.ParamLocationPath, ctx.Param("findingID"), &findingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutFindingsFindingID(ctx, findingID)
	return err
}

// GetScanConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanConfigs(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanConfigsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetScanConfigs(ctx, params)
	return err
}

// PostScanConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) PostScanConfigs(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostScanConfigs(ctx)
	return err
}

// DeleteScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanConfigID", runtime.ParamLocationPath, ctx.Param("scanConfigID"), &scanConfigID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteScanConfigsScanConfigID(ctx, scanConfigID)
	return err
}

// GetScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanConfigID", runtime.ParamLocationPath, ctx.Param("scanConfigID"), &scanConfigID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanConfigsScanConfigIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// PatchScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanConfigID", runtime.ParamLocationPath, ctx.Param("scanConfigID"), &scanConfigID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScanConfigsScanConfigIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// PutScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanConfigID", runtime.ParamLocationPath, ctx.Param("scanConfigID"), &scanConfigID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScanConfigsScanConfigIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// GetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetScans(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetScans(ctx, params)
	return err
}

// PostScans converts echo context to params.
func (w *ServerInterfaceWrapper) PostScans(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostScans(ctx)
	return err
}

// DeleteScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanID", runtime.ParamLocationPath, ctx.Param("scanID"), &scanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteScansScanID(ctx, scanID)
	return err
}

// GetScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanID", runtime.ParamLocationPath, ctx.Param("scanID"), &scanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansScanIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetScansScanID(ctx, scanID, params)
	return err
}

// PatchScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanID", runtime.ParamLocationPath, ctx.Param("scanID"), &scanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScansScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchScansScanID(ctx, scanID, params)
	return err
}

// PutScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanID", runtime.ParamLocationPath, ctx.Param("scanID"), &scanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScansScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutScansScanID(ctx, scanID, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/assetScans", wrapper.GetAssetScans)
	router.POST(baseURL+"/assetScans", wrapper.PostAssetScans)
	router.GET(baseURL+"/assetScans/:assetScanID", wrapper.GetAssetScansAssetScanID)
	router.PATCH(baseURL+"/assetScans/:assetScanID", wrapper.PatchAssetScansAssetScanID)
	router.PUT(baseURL+"/assetScans/:assetScanID", wrapper.PutAssetScansAssetScanID)
	router.GET(baseURL+"/assets", wrapper.GetAssets)
	router.POST(baseURL+"/assets", wrapper.PostAssets)
	router.DELETE(baseURL+"/assets/:assetID", wrapper.DeleteAssetsAssetID)
	router.GET(baseURL+"/assets/:assetID", wrapper.GetAssetsAssetID)
	router.PATCH(baseURL+"/assets/:assetID", wrapper.PatchAssetsAssetID)
	router.PUT(baseURL+"/assets/:assetID", wrapper.PutAssetsAssetID)
	router.GET(baseURL+"/findings", wrapper.GetFindings)
	router.POST(baseURL+"/findings", wrapper.PostFindings)
	router.DELETE(baseURL+"/findings/:findingID", wrapper.DeleteFindingsFindingID)
	router.GET(baseURL+"/findings/:findingID", wrapper.GetFindingsFindingID)
	router.PATCH(baseURL+"/findings/:findingID", wrapper.PatchFindingsFindingID)
	router.PUT(baseURL+"/findings/:findingID", wrapper.PutFindingsFindingID)
	router.GET(baseURL+"/scanConfigs", wrapper.GetScanConfigs)
	router.POST(baseURL+"/scanConfigs", wrapper.PostScanConfigs)
	router.DELETE(baseURL+"/scanConfigs/:scanConfigID", wrapper.DeleteScanConfigsScanConfigID)
	router.GET(baseURL+"/scanConfigs/:scanConfigID", wrapper.GetScanConfigsScanConfigID)
	router.PATCH(baseURL+"/scanConfigs/:scanConfigID", wrapper.PatchScanConfigsScanConfigID)
	router.PUT(baseURL+"/scanConfigs/:scanConfigID", wrapper.PutScanConfigsScanConfigID)
	router.GET(baseURL+"/scans", wrapper.GetScans)
	router.POST(baseURL+"/scans", wrapper.PostScans)
	router.DELETE(baseURL+"/scans/:scanID", wrapper.DeleteScansScanID)
	router.GET(baseURL+"/scans/:scanID", wrapper.GetScansScanID)
	router.PATCH(baseURL+"/scans/:scanID", wrapper.PatchScansScanID)
	router.PUT(baseURL+"/scans/:scanID", wrapper.PutScansScanID)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
