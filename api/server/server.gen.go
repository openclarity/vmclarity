// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	. "github.com/openclarity/vmclarity/api/models"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get asset scans according to the given filters
	// (GET /assetScans)
	GetAssetScans(ctx echo.Context, params GetAssetScansParams) error
	// Create an asset scan for a specified asset
	// (POST /assetScans)
	PostAssetScans(ctx echo.Context) error
	// Get an asset scan.
	// (GET /assetScans/{assetScanID})
	GetAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params GetAssetScansAssetScanIDParams) error
	// Patch an asset scan
	// (PATCH /assetScans/{assetScanID})
	PatchAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params PatchAssetScansAssetScanIDParams) error
	// Update an asset scan.
	// (PUT /assetScans/{assetScanID})
	PutAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params PutAssetScansAssetScanIDParams) error
	// Get assets
	// (GET /assets)
	GetAssets(ctx echo.Context, params GetAssetsParams) error
	// Create asset
	// (POST /assets)
	PostAssets(ctx echo.Context) error
	// Delete asset.
	// (DELETE /assets/{assetID})
	DeleteAssetsAssetID(ctx echo.Context, assetID AssetID) error
	// Get asset.
	// (GET /assets/{assetID})
	GetAssetsAssetID(ctx echo.Context, assetID AssetID, params GetAssetsAssetIDParams) error
	// Update asset.
	// (PATCH /assets/{assetID})
	PatchAssetsAssetID(ctx echo.Context, assetID AssetID, params PatchAssetsAssetIDParams) error
	// Update asset.
	// (PUT /assets/{assetID})
	PutAssetsAssetID(ctx echo.Context, assetID AssetID, params PutAssetsAssetIDParams) error
	// Get all findings.
	// (GET /findings)
	GetFindings(ctx echo.Context, params GetFindingsParams) error
	// Create a finding
	// (POST /findings)
	PostFindings(ctx echo.Context) error
	// Delete a finding.
	// (DELETE /findings/{findingID})
	DeleteFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Get the details for a finding.
	// (GET /findings/{findingID})
	GetFindingsFindingID(ctx echo.Context, findingID FindingID, params GetFindingsFindingIDParams) error
	// Patch a finding.
	// (PATCH /findings/{findingID})
	PatchFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Update a finding.
	// (PUT /findings/{findingID})
	PutFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Get this OpenAPI spec
	// (GET /openapi.json)
	GetOpenAPISpec(ctx echo.Context) error
	// Get all scan configs.
	// (GET /scanConfigs)
	GetScanConfigs(ctx echo.Context, params GetScanConfigsParams) error
	// Create a scan config
	// (POST /scanConfigs)
	PostScanConfigs(ctx echo.Context) error
	// Delete a scan config.
	// (DELETE /scanConfigs/{scanConfigID})
	DeleteScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID) error
	// Get the details for a scan config.
	// (GET /scanConfigs/{scanConfigID})
	GetScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params GetScanConfigsScanConfigIDParams) error
	// Patch a scan config.
	// (PATCH /scanConfigs/{scanConfigID})
	PatchScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params PatchScanConfigsScanConfigIDParams) error
	// Update a scan config.
	// (PUT /scanConfigs/{scanConfigID})
	PutScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params PutScanConfigsScanConfigIDParams) error
	// Get all scans. Each scan contains details about a multi-asset scheduled scan.
	// (GET /scans)
	GetScans(ctx echo.Context, params GetScansParams) error
	// Create a multi-asset scheduled scan
	// (POST /scans)
	PostScans(ctx echo.Context) error
	// Delete a scan.
	// (DELETE /scans/{scanID})
	DeleteScansScanID(ctx echo.Context, scanID ScanID) error
	// Get the details for a given multi-asset scheduled scan.
	// (GET /scans/{scanID})
	GetScansScanID(ctx echo.Context, scanID ScanID, params GetScansScanIDParams) error
	// Patch a scan.
	// (PATCH /scans/{scanID})
	PatchScansScanID(ctx echo.Context, scanID ScanID, params PatchScansScanIDParams) error
	// Update a scan.
	// (PUT /scans/{scanID})
	PutScansScanID(ctx echo.Context, scanID ScanID, params PutScansScanIDParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAssetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScans(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScansParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetScans(ctx, params)
	return err
}

// PostAssetScans converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssetScans(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostAssetScans(ctx)
	return err
}

// GetAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanID", runtime.ParamLocationPath, ctx.Param("assetScanID"), &assetScanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScansAssetScanIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// PatchAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanID", runtime.ParamLocationPath, ctx.Param("assetScanID"), &assetScanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetScansAssetScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// PutAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetScanID", runtime.ParamLocationPath, ctx.Param("assetScanID"), &assetScanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetScansAssetScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// GetAssets converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssets(ctx, params)
	return err
}

// PostAssets converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssets(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostAssets(ctx)
	return err
}

// DeleteAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetID", runtime.ParamLocationPath, ctx.Param("assetID"), &assetID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteAssetsAssetID(ctx, assetID)
	return err
}

// GetAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetID", runtime.ParamLocationPath, ctx.Param("assetID"), &assetID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsAssetIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetsAssetID(ctx, assetID, params)
	return err
}

// PatchAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetID", runtime.ParamLocationPath, ctx.Param("assetID"), &assetID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetsAssetIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchAssetsAssetID(ctx, assetID, params)
	return err
}

// PutAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assetID", runtime.ParamLocationPath, ctx.Param("assetID"), &assetID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetsAssetIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutAssetsAssetID(ctx, assetID, params)
	return err
}

// GetFindings converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindings(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFindings(ctx, params)
	return err
}

// PostFindings converts echo context to params.
func (w *ServerInterfaceWrapper) PostFindings(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostFindings(ctx)
	return err
}

// DeleteFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithLocation("simple", false, "findingID", runtime.ParamLocationPath, ctx.Param("findingID"), &findingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteFindingsFindingID(ctx, findingID)
	return err
}

// GetFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithLocation("simple", false, "findingID", runtime.ParamLocationPath, ctx.Param("findingID"), &findingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsFindingIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFindingsFindingID(ctx, findingID, params)
	return err
}

// PatchFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithLocation("simple", false, "findingID", runtime.ParamLocationPath, ctx.Param("findingID"), &findingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchFindingsFindingID(ctx, findingID)
	return err
}

// PutFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PutFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithLocation("simple", false, "findingID", runtime.ParamLocationPath, ctx.Param("findingID"), &findingID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutFindingsFindingID(ctx, findingID)
	return err
}

// GetOpenAPISpec converts echo context to params.
func (w *ServerInterfaceWrapper) GetOpenAPISpec(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetOpenAPISpec(ctx)
	return err
}

// GetScanConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanConfigs(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanConfigsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetScanConfigs(ctx, params)
	return err
}

// PostScanConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) PostScanConfigs(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostScanConfigs(ctx)
	return err
}

// DeleteScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanConfigID", runtime.ParamLocationPath, ctx.Param("scanConfigID"), &scanConfigID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteScanConfigsScanConfigID(ctx, scanConfigID)
	return err
}

// GetScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanConfigID", runtime.ParamLocationPath, ctx.Param("scanConfigID"), &scanConfigID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanConfigsScanConfigIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// PatchScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanConfigID", runtime.ParamLocationPath, ctx.Param("scanConfigID"), &scanConfigID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScanConfigsScanConfigIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// PutScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanConfigID", runtime.ParamLocationPath, ctx.Param("scanConfigID"), &scanConfigID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScanConfigsScanConfigIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// GetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetScans(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetScans(ctx, params)
	return err
}

// PostScans converts echo context to params.
func (w *ServerInterfaceWrapper) PostScans(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PostScans(ctx)
	return err
}

// DeleteScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanID", runtime.ParamLocationPath, ctx.Param("scanID"), &scanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteScansScanID(ctx, scanID)
	return err
}

// GetScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanID", runtime.ParamLocationPath, ctx.Param("scanID"), &scanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansScanIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetScansScanID(ctx, scanID, params)
	return err
}

// PatchScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanID", runtime.ParamLocationPath, ctx.Param("scanID"), &scanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScansScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PatchScansScanID(ctx, scanID, params)
	return err
}

// PutScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithLocation("simple", false, "scanID", runtime.ParamLocationPath, ctx.Param("scanID"), &scanID)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScansScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.PutScansScanID(ctx, scanID, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/assetScans", wrapper.GetAssetScans)
	router.POST(baseURL+"/assetScans", wrapper.PostAssetScans)
	router.GET(baseURL+"/assetScans/:assetScanID", wrapper.GetAssetScansAssetScanID)
	router.PATCH(baseURL+"/assetScans/:assetScanID", wrapper.PatchAssetScansAssetScanID)
	router.PUT(baseURL+"/assetScans/:assetScanID", wrapper.PutAssetScansAssetScanID)
	router.GET(baseURL+"/assets", wrapper.GetAssets)
	router.POST(baseURL+"/assets", wrapper.PostAssets)
	router.DELETE(baseURL+"/assets/:assetID", wrapper.DeleteAssetsAssetID)
	router.GET(baseURL+"/assets/:assetID", wrapper.GetAssetsAssetID)
	router.PATCH(baseURL+"/assets/:assetID", wrapper.PatchAssetsAssetID)
	router.PUT(baseURL+"/assets/:assetID", wrapper.PutAssetsAssetID)
	router.GET(baseURL+"/findings", wrapper.GetFindings)
	router.POST(baseURL+"/findings", wrapper.PostFindings)
	router.DELETE(baseURL+"/findings/:findingID", wrapper.DeleteFindingsFindingID)
	router.GET(baseURL+"/findings/:findingID", wrapper.GetFindingsFindingID)
	router.PATCH(baseURL+"/findings/:findingID", wrapper.PatchFindingsFindingID)
	router.PUT(baseURL+"/findings/:findingID", wrapper.PutFindingsFindingID)
	router.GET(baseURL+"/openapi.json", wrapper.GetOpenAPISpec)
	router.GET(baseURL+"/scanConfigs", wrapper.GetScanConfigs)
	router.POST(baseURL+"/scanConfigs", wrapper.PostScanConfigs)
	router.DELETE(baseURL+"/scanConfigs/:scanConfigID", wrapper.DeleteScanConfigsScanConfigID)
	router.GET(baseURL+"/scanConfigs/:scanConfigID", wrapper.GetScanConfigsScanConfigID)
	router.PATCH(baseURL+"/scanConfigs/:scanConfigID", wrapper.PatchScanConfigsScanConfigID)
	router.PUT(baseURL+"/scanConfigs/:scanConfigID", wrapper.PutScanConfigsScanConfigID)
	router.GET(baseURL+"/scans", wrapper.GetScans)
	router.POST(baseURL+"/scans", wrapper.PostScans)
	router.DELETE(baseURL+"/scans/:scanID", wrapper.DeleteScansScanID)
	router.GET(baseURL+"/scans/:scanID", wrapper.GetScansScanID)
	router.PATCH(baseURL+"/scans/:scanID", wrapper.PatchScansScanID)
	router.PUT(baseURL+"/scans/:scanID", wrapper.PutScansScanID)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"5k52jYPRAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
