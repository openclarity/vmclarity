// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	. "github.com/openclarity/vmclarity/api/models"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get asset scan estimations according to the given filters
	// (GET /assetScanEstimations)
	GetAssetScanEstimations(ctx echo.Context, params GetAssetScanEstimationsParams) error
	// Create an asset scan estimation for a specified asset
	// (POST /assetScanEstimations)
	PostAssetScanEstimations(ctx echo.Context) error
	// Delete an asset scan estimation.
	// (DELETE /assetScanEstimations/{assetScanEstimationID})
	DeleteAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID) error
	// Get an asset scan estimation.
	// (GET /assetScanEstimations/{assetScanEstimationID})
	GetAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params GetAssetScanEstimationsAssetScanEstimationIDParams) error
	// Patch an asset scan estimation
	// (PATCH /assetScanEstimations/{assetScanEstimationID})
	PatchAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params PatchAssetScanEstimationsAssetScanEstimationIDParams) error
	// Update an asset scan estimation.
	// (PUT /assetScanEstimations/{assetScanEstimationID})
	PutAssetScanEstimationsAssetScanEstimationID(ctx echo.Context, assetScanEstimationID AssetScanEstimationID, params PutAssetScanEstimationsAssetScanEstimationIDParams) error
	// Get asset scans according to the given filters
	// (GET /assetScans)
	GetAssetScans(ctx echo.Context, params GetAssetScansParams) error
	// Create an asset scan for a specified asset
	// (POST /assetScans)
	PostAssetScans(ctx echo.Context) error
	// Get an asset scan.
	// (GET /assetScans/{assetScanID})
	GetAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params GetAssetScansAssetScanIDParams) error
	// Patch an asset scan
	// (PATCH /assetScans/{assetScanID})
	PatchAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params PatchAssetScansAssetScanIDParams) error
	// Update an asset scan.
	// (PUT /assetScans/{assetScanID})
	PutAssetScansAssetScanID(ctx echo.Context, assetScanID AssetScanID, params PutAssetScansAssetScanIDParams) error
	// Get assets
	// (GET /assets)
	GetAssets(ctx echo.Context, params GetAssetsParams) error
	// Create asset
	// (POST /assets)
	PostAssets(ctx echo.Context) error
	// Delete asset.
	// (DELETE /assets/{assetID})
	DeleteAssetsAssetID(ctx echo.Context, assetID AssetID) error
	// Get asset.
	// (GET /assets/{assetID})
	GetAssetsAssetID(ctx echo.Context, assetID AssetID, params GetAssetsAssetIDParams) error
	// Update asset.
	// (PATCH /assets/{assetID})
	PatchAssetsAssetID(ctx echo.Context, assetID AssetID, params PatchAssetsAssetIDParams) error
	// Update asset.
	// (PUT /assets/{assetID})
	PutAssetsAssetID(ctx echo.Context, assetID AssetID, params PutAssetsAssetIDParams) error
	// Get all findings.
	// (GET /findings)
	GetFindings(ctx echo.Context, params GetFindingsParams) error
	// Create a finding
	// (POST /findings)
	PostFindings(ctx echo.Context) error
	// Delete a finding.
	// (DELETE /findings/{findingID})
	DeleteFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Get the details for a finding.
	// (GET /findings/{findingID})
	GetFindingsFindingID(ctx echo.Context, findingID FindingID, params GetFindingsFindingIDParams) error
	// Patch a finding.
	// (PATCH /findings/{findingID})
	PatchFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Update a finding.
	// (PUT /findings/{findingID})
	PutFindingsFindingID(ctx echo.Context, findingID FindingID) error
	// Get this OpenAPI spec
	// (GET /openapi.json)
	GetOpenAPISpec(ctx echo.Context) error
	// Get providers
	// (GET /providers)
	GetProviders(ctx echo.Context, params GetProvidersParams) error
	// Create provider
	// (POST /providers)
	PostProviders(ctx echo.Context) error
	// Delete provider.
	// (DELETE /providers/{providerID})
	DeleteProvidersProviderID(ctx echo.Context, providerID ProviderID) error
	// Get provider.
	// (GET /providers/{providerID})
	GetProvidersProviderID(ctx echo.Context, providerID ProviderID, params GetProvidersProviderIDParams) error
	// Update provider.
	// (PATCH /providers/{providerID})
	PatchProvidersProviderID(ctx echo.Context, providerID ProviderID, params PatchProvidersProviderIDParams) error
	// Update provider.
	// (PUT /providers/{providerID})
	PutProvidersProviderID(ctx echo.Context, providerID ProviderID, params PutProvidersProviderIDParams) error
	// Get all scan configs.
	// (GET /scanConfigs)
	GetScanConfigs(ctx echo.Context, params GetScanConfigsParams) error
	// Create a scan config
	// (POST /scanConfigs)
	PostScanConfigs(ctx echo.Context) error
	// Delete a scan config.
	// (DELETE /scanConfigs/{scanConfigID})
	DeleteScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID) error
	// Get the details for a scan config.
	// (GET /scanConfigs/{scanConfigID})
	GetScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params GetScanConfigsScanConfigIDParams) error
	// Patch a scan config.
	// (PATCH /scanConfigs/{scanConfigID})
	PatchScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params PatchScanConfigsScanConfigIDParams) error
	// Update a scan config.
	// (PUT /scanConfigs/{scanConfigID})
	PutScanConfigsScanConfigID(ctx echo.Context, scanConfigID ScanConfigID, params PutScanConfigsScanConfigIDParams) error
	// Get all scan estimations. Each scan estimation contains details about a multi-asset scan estimation.
	// (GET /scanEstimations)
	GetScanEstimations(ctx echo.Context, params GetScanEstimationsParams) error
	// Create a multi-asset scan estimation
	// (POST /scanEstimations)
	PostScanEstimations(ctx echo.Context) error
	// Delete a scan estimation.
	// (DELETE /scanEstimations/{scanEstimationID})
	DeleteScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID) error
	// Get the details for a given multi-asset scan estimation.
	// (GET /scanEstimations/{scanEstimationID})
	GetScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params GetScanEstimationsScanEstimationIDParams) error
	// Patch a scan estimation.
	// (PATCH /scanEstimations/{scanEstimationID})
	PatchScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params PatchScanEstimationsScanEstimationIDParams) error
	// Update a scan estimation.
	// (PUT /scanEstimations/{scanEstimationID})
	PutScanEstimationsScanEstimationID(ctx echo.Context, scanEstimationID ScanEstimationID, params PutScanEstimationsScanEstimationIDParams) error
	// Get all scans. Each scan contains details about a multi-asset scheduled scan.
	// (GET /scans)
	GetScans(ctx echo.Context, params GetScansParams) error
	// Create a multi-asset scheduled scan
	// (POST /scans)
	PostScans(ctx echo.Context) error
	// Delete a scan.
	// (DELETE /scans/{scanID})
	DeleteScansScanID(ctx echo.Context, scanID ScanID) error
	// Get the details for a given multi-asset scheduled scan.
	// (GET /scans/{scanID})
	GetScansScanID(ctx echo.Context, scanID ScanID, params GetScansScanIDParams) error
	// Patch a scan.
	// (PATCH /scans/{scanID})
	PatchScansScanID(ctx echo.Context, scanID ScanID, params PatchScansScanIDParams) error
	// Update a scan.
	// (PUT /scans/{scanID})
	PutScansScanID(ctx echo.Context, scanID ScanID, params PutScansScanIDParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetAssetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScanEstimations(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScanEstimationsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScanEstimations(ctx, params)
	return err
}

// PostAssetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssetScanEstimations(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssetScanEstimations(ctx)
	return err
}

// DeleteAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanEstimationID", ctx.Param("assetScanEstimationID"), &assetScanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID)
	return err
}

// GetAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanEstimationID", ctx.Param("assetScanEstimationID"), &assetScanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScanEstimationsAssetScanEstimationIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// PatchAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanEstimationID", ctx.Param("assetScanEstimationID"), &assetScanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetScanEstimationsAssetScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// PutAssetScanEstimationsAssetScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetScanEstimationsAssetScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanEstimationID" -------------
	var assetScanEstimationID AssetScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanEstimationID", ctx.Param("assetScanEstimationID"), &assetScanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetScanEstimationsAssetScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetScanEstimationsAssetScanEstimationID(ctx, assetScanEstimationID, params)
	return err
}

// GetAssetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScans(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScansParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScans(ctx, params)
	return err
}

// PostAssetScans converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssetScans(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssetScans(ctx)
	return err
}

// GetAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanID", ctx.Param("assetScanID"), &assetScanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetScansAssetScanIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// PatchAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanID", ctx.Param("assetScanID"), &assetScanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetScansAssetScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// PutAssetScansAssetScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetScansAssetScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetScanID" -------------
	var assetScanID AssetScanID

	err = runtime.BindStyledParameterWithOptions("simple", "assetScanID", ctx.Param("assetScanID"), &assetScanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetScanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetScansAssetScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetScansAssetScanID(ctx, assetScanID, params)
	return err
}

// GetAssets converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssets(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssets(ctx, params)
	return err
}

// PostAssets converts echo context to params.
func (w *ServerInterfaceWrapper) PostAssets(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostAssets(ctx)
	return err
}

// DeleteAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithOptions("simple", "assetID", ctx.Param("assetID"), &assetID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteAssetsAssetID(ctx, assetID)
	return err
}

// GetAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithOptions("simple", "assetID", ctx.Param("assetID"), &assetID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAssetsAssetIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetsAssetID(ctx, assetID, params)
	return err
}

// PatchAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithOptions("simple", "assetID", ctx.Param("assetID"), &assetID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchAssetsAssetIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchAssetsAssetID(ctx, assetID, params)
	return err
}

// PutAssetsAssetID converts echo context to params.
func (w *ServerInterfaceWrapper) PutAssetsAssetID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assetID" -------------
	var assetID AssetID

	err = runtime.BindStyledParameterWithOptions("simple", "assetID", ctx.Param("assetID"), &assetID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assetID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutAssetsAssetIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutAssetsAssetID(ctx, assetID, params)
	return err
}

// GetFindings converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindings(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFindings(ctx, params)
	return err
}

// PostFindings converts echo context to params.
func (w *ServerInterfaceWrapper) PostFindings(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFindings(ctx)
	return err
}

// DeleteFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithOptions("simple", "findingID", ctx.Param("findingID"), &findingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteFindingsFindingID(ctx, findingID)
	return err
}

// GetFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithOptions("simple", "findingID", ctx.Param("findingID"), &findingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsFindingIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFindingsFindingID(ctx, findingID, params)
	return err
}

// PatchFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithOptions("simple", "findingID", ctx.Param("findingID"), &findingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchFindingsFindingID(ctx, findingID)
	return err
}

// PutFindingsFindingID converts echo context to params.
func (w *ServerInterfaceWrapper) PutFindingsFindingID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "findingID" -------------
	var findingID FindingID

	err = runtime.BindStyledParameterWithOptions("simple", "findingID", ctx.Param("findingID"), &findingID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter findingID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutFindingsFindingID(ctx, findingID)
	return err
}

// GetOpenAPISpec converts echo context to params.
func (w *ServerInterfaceWrapper) GetOpenAPISpec(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOpenAPISpec(ctx)
	return err
}

// GetProviders converts echo context to params.
func (w *ServerInterfaceWrapper) GetProviders(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProvidersParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProviders(ctx, params)
	return err
}

// PostProviders converts echo context to params.
func (w *ServerInterfaceWrapper) PostProviders(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostProviders(ctx)
	return err
}

// DeleteProvidersProviderID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteProvidersProviderID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "providerID" -------------
	var providerID ProviderID

	err = runtime.BindStyledParameterWithOptions("simple", "providerID", ctx.Param("providerID"), &providerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter providerID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteProvidersProviderID(ctx, providerID)
	return err
}

// GetProvidersProviderID converts echo context to params.
func (w *ServerInterfaceWrapper) GetProvidersProviderID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "providerID" -------------
	var providerID ProviderID

	err = runtime.BindStyledParameterWithOptions("simple", "providerID", ctx.Param("providerID"), &providerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter providerID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetProvidersProviderIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProvidersProviderID(ctx, providerID, params)
	return err
}

// PatchProvidersProviderID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchProvidersProviderID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "providerID" -------------
	var providerID ProviderID

	err = runtime.BindStyledParameterWithOptions("simple", "providerID", ctx.Param("providerID"), &providerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter providerID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchProvidersProviderIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchProvidersProviderID(ctx, providerID, params)
	return err
}

// PutProvidersProviderID converts echo context to params.
func (w *ServerInterfaceWrapper) PutProvidersProviderID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "providerID" -------------
	var providerID ProviderID

	err = runtime.BindStyledParameterWithOptions("simple", "providerID", ctx.Param("providerID"), &providerID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter providerID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutProvidersProviderIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutProvidersProviderID(ctx, providerID, params)
	return err
}

// GetScanConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanConfigs(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanConfigsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanConfigs(ctx, params)
	return err
}

// PostScanConfigs converts echo context to params.
func (w *ServerInterfaceWrapper) PostScanConfigs(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScanConfigs(ctx)
	return err
}

// DeleteScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithOptions("simple", "scanConfigID", ctx.Param("scanConfigID"), &scanConfigID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScanConfigsScanConfigID(ctx, scanConfigID)
	return err
}

// GetScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithOptions("simple", "scanConfigID", ctx.Param("scanConfigID"), &scanConfigID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanConfigsScanConfigIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// PatchScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithOptions("simple", "scanConfigID", ctx.Param("scanConfigID"), &scanConfigID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScanConfigsScanConfigIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// PutScanConfigsScanConfigID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScanConfigsScanConfigID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanConfigID" -------------
	var scanConfigID ScanConfigID

	err = runtime.BindStyledParameterWithOptions("simple", "scanConfigID", ctx.Param("scanConfigID"), &scanConfigID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanConfigID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScanConfigsScanConfigIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScanConfigsScanConfigID(ctx, scanConfigID, params)
	return err
}

// GetScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanEstimations(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanEstimationsParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanEstimations(ctx, params)
	return err
}

// PostScanEstimations converts echo context to params.
func (w *ServerInterfaceWrapper) PostScanEstimations(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScanEstimations(ctx)
	return err
}

// DeleteScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "scanEstimationID", ctx.Param("scanEstimationID"), &scanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScanEstimationsScanEstimationID(ctx, scanEstimationID)
	return err
}

// GetScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "scanEstimationID", ctx.Param("scanEstimationID"), &scanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScanEstimationsScanEstimationIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// PatchScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "scanEstimationID", ctx.Param("scanEstimationID"), &scanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScanEstimationsScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// PutScanEstimationsScanEstimationID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScanEstimationsScanEstimationID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanEstimationID" -------------
	var scanEstimationID ScanEstimationID

	err = runtime.BindStyledParameterWithOptions("simple", "scanEstimationID", ctx.Param("scanEstimationID"), &scanEstimationID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanEstimationID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScanEstimationsScanEstimationIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScanEstimationsScanEstimationID(ctx, scanEstimationID, params)
	return err
}

// GetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetScans(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansParams
	// ------------- Optional query parameter "$filter" -------------

	err = runtime.BindQueryParameter("form", true, false, "$filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $filter: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$count" -------------

	err = runtime.BindQueryParameter("form", true, false, "$count", ctx.QueryParams(), &params.Count)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $count: %s", err))
	}

	// ------------- Optional query parameter "$top" -------------

	err = runtime.BindQueryParameter("form", true, false, "$top", ctx.QueryParams(), &params.Top)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $top: %s", err))
	}

	// ------------- Optional query parameter "$skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "$skip", ctx.QueryParams(), &params.Skip)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $skip: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// ------------- Optional query parameter "$orderby" -------------

	err = runtime.BindQueryParameter("form", true, false, "$orderby", ctx.QueryParams(), &params.OrderBy)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $orderby: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScans(ctx, params)
	return err
}

// PostScans converts echo context to params.
func (w *ServerInterfaceWrapper) PostScans(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostScans(ctx)
	return err
}

// DeleteScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScansScanID(ctx, scanID)
	return err
}

// GetScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) GetScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansScanIDParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", true, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// ------------- Optional query parameter "$expand" -------------

	err = runtime.BindQueryParameter("form", true, false, "$expand", ctx.QueryParams(), &params.Expand)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $expand: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScansScanID(ctx, scanID, params)
	return err
}

// PatchScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PatchScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchScansScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchScansScanID(ctx, scanID, params)
	return err
}

// PutScansScanID converts echo context to params.
func (w *ServerInterfaceWrapper) PutScansScanID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutScansScanIDParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch Ifmatch
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "If-Match", valueList[0], &IfMatch, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PutScansScanID(ctx, scanID, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/assetScanEstimations", wrapper.GetAssetScanEstimations)
	router.POST(baseURL+"/assetScanEstimations", wrapper.PostAssetScanEstimations)
	router.DELETE(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.DeleteAssetScanEstimationsAssetScanEstimationID)
	router.GET(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.GetAssetScanEstimationsAssetScanEstimationID)
	router.PATCH(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.PatchAssetScanEstimationsAssetScanEstimationID)
	router.PUT(baseURL+"/assetScanEstimations/:assetScanEstimationID", wrapper.PutAssetScanEstimationsAssetScanEstimationID)
	router.GET(baseURL+"/assetScans", wrapper.GetAssetScans)
	router.POST(baseURL+"/assetScans", wrapper.PostAssetScans)
	router.GET(baseURL+"/assetScans/:assetScanID", wrapper.GetAssetScansAssetScanID)
	router.PATCH(baseURL+"/assetScans/:assetScanID", wrapper.PatchAssetScansAssetScanID)
	router.PUT(baseURL+"/assetScans/:assetScanID", wrapper.PutAssetScansAssetScanID)
	router.GET(baseURL+"/assets", wrapper.GetAssets)
	router.POST(baseURL+"/assets", wrapper.PostAssets)
	router.DELETE(baseURL+"/assets/:assetID", wrapper.DeleteAssetsAssetID)
	router.GET(baseURL+"/assets/:assetID", wrapper.GetAssetsAssetID)
	router.PATCH(baseURL+"/assets/:assetID", wrapper.PatchAssetsAssetID)
	router.PUT(baseURL+"/assets/:assetID", wrapper.PutAssetsAssetID)
	router.GET(baseURL+"/findings", wrapper.GetFindings)
	router.POST(baseURL+"/findings", wrapper.PostFindings)
	router.DELETE(baseURL+"/findings/:findingID", wrapper.DeleteFindingsFindingID)
	router.GET(baseURL+"/findings/:findingID", wrapper.GetFindingsFindingID)
	router.PATCH(baseURL+"/findings/:findingID", wrapper.PatchFindingsFindingID)
	router.PUT(baseURL+"/findings/:findingID", wrapper.PutFindingsFindingID)
	router.GET(baseURL+"/openapi.json", wrapper.GetOpenAPISpec)
	router.GET(baseURL+"/providers", wrapper.GetProviders)
	router.POST(baseURL+"/providers", wrapper.PostProviders)
	router.DELETE(baseURL+"/providers/:providerID", wrapper.DeleteProvidersProviderID)
	router.GET(baseURL+"/providers/:providerID", wrapper.GetProvidersProviderID)
	router.PATCH(baseURL+"/providers/:providerID", wrapper.PatchProvidersProviderID)
	router.PUT(baseURL+"/providers/:providerID", wrapper.PutProvidersProviderID)
	router.GET(baseURL+"/scanConfigs", wrapper.GetScanConfigs)
	router.POST(baseURL+"/scanConfigs", wrapper.PostScanConfigs)
	router.DELETE(baseURL+"/scanConfigs/:scanConfigID", wrapper.DeleteScanConfigsScanConfigID)
	router.GET(baseURL+"/scanConfigs/:scanConfigID", wrapper.GetScanConfigsScanConfigID)
	router.PATCH(baseURL+"/scanConfigs/:scanConfigID", wrapper.PatchScanConfigsScanConfigID)
	router.PUT(baseURL+"/scanConfigs/:scanConfigID", wrapper.PutScanConfigsScanConfigID)
	router.GET(baseURL+"/scanEstimations", wrapper.GetScanEstimations)
	router.POST(baseURL+"/scanEstimations", wrapper.PostScanEstimations)
	router.DELETE(baseURL+"/scanEstimations/:scanEstimationID", wrapper.DeleteScanEstimationsScanEstimationID)
	router.GET(baseURL+"/scanEstimations/:scanEstimationID", wrapper.GetScanEstimationsScanEstimationID)
	router.PATCH(baseURL+"/scanEstimations/:scanEstimationID", wrapper.PatchScanEstimationsScanEstimationID)
	router.PUT(baseURL+"/scanEstimations/:scanEstimationID", wrapper.PutScanEstimationsScanEstimationID)
	router.GET(baseURL+"/scans", wrapper.GetScans)
	router.POST(baseURL+"/scans", wrapper.PostScans)
	router.DELETE(baseURL+"/scans/:scanID", wrapper.DeleteScansScanID)
	router.GET(baseURL+"/scans/:scanID", wrapper.GetScansScanID)
	router.PATCH(baseURL+"/scans/:scanID", wrapper.PatchScansScanID)
	router.PUT(baseURL+"/scans/:scanID", wrapper.PutScansScanID)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/wEAAP//cWegAhlgAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
