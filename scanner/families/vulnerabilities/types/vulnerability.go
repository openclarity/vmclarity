// Copyright Â© 2022 Cisco Systems, Inc. and its affiliates.
// All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package types

import (
	"encoding/json"
	"fmt"
	"sort"

	"github.com/google/uuid"
	log "github.com/sirupsen/logrus"
	"github.com/yudai/gojsondiff"
	"github.com/yudai/gojsondiff/formatter"
)

type Vulnerability struct {
	ID          string   `json:"id"`
	Description string   `json:"description,omitempty"`
	Links       []string `json:"links"`
	Distro      Distro   `json:"distro"`
	CVSS        []CVSS   `json:"cvss"`
	Fix         Fix      `json:"fix"`
	Severity    string   `json:"severity,omitempty"`
	Package     Package  `json:"package"`
	LayerID     string   `json:"layerID"`
	Path        string   `json:"path"`
}

func (v Vulnerability) sorted() Vulnerability {
	sort.Slice(v.CVSS, func(i, j int) bool {
		return v.CVSS[i].Version < v.CVSS[j].Version
	})
	sort.Strings(v.Links)
	sort.Strings(v.Fix.Versions)
	sort.Strings(v.Package.CPEs)
	sort.Strings(v.Package.Licenses)
	return v
}

type CVSS struct {
	Source         string      `json:"source,omitempty"`
	Type           string      `json:"type,omitempty"`
	Version        string      `json:"version"`
	Vector         string      `json:"vector"`
	Metrics        CvssMetrics `json:"metrics"`
	VendorMetadata interface{} `json:"vendorMetadata"`
}

type CvssMetrics struct {
	BaseScore           float64  `json:"baseScore"`
	ExploitabilityScore *float64 `json:"exploitabilityScore,omitempty"`
	ImpactScore         *float64 `json:"impactScore,omitempty"`
}

type Fix struct {
	Versions []string `json:"versions"`
	State    string   `json:"state"`
}

type Package struct {
	Name     string   `json:"name"`
	Version  string   `json:"version"`
	Type     string   `json:"type"`     // apk, gem, deb, ...
	Language string   `json:"language"` // java, python, go, ...
	Licenses []string `json:"licenses"`
	CPEs     []string `json:"cpes"`
	PURL     string   `json:"purl"`
}

// Distro provides information about a detected Linux distribution.
type Distro struct {
	Name    string   `json:"name"`    // Name of the Linux distribution
	Version string   `json:"version"` // Version of the Linux distribution (major or major.minor version)
	IDLike  []string `json:"idLike"`  // the ID_LIKE field found within the /etc/os-release file
}

type VulnerabilityKey string // Unique identification of a vulnerability ID per package (name and version)

func NewVulnerabilityKey(vulnerability Vulnerability) VulnerabilityKey {
	return VulnerabilityKey(fmt.Sprintf("%s.%s.%s", vulnerability.ID, vulnerability.Package.Name, vulnerability.Package.Version))
}

type VulnerabilityDiff struct {
	CompareToID string                 `json:"compareToID"`
	JSONDiff    map[string]interface{} `json:"jsonDiff"`
	ASCIIDiff   string                 `json:"asciiDiff"`
}

type MergedVulnerability struct {
	ID            string              `json:"id"` // Merged vulnerability ID used in DiffInfo - THIS IS NOT THE CVE ID
	Vulnerability Vulnerability       `json:"vulnerability"`
	Diffs         []VulnerabilityDiff `json:"diffs"`
	ScannersInfo  []ScannerInfo       `json:"scanners"`
}

func (mv *MergedVulnerability) AppendScannerInfo(info ScannerInfo) *MergedVulnerability {
	mv.ScannersInfo = append(mv.ScannersInfo, info)
	return mv
}

func (mv *MergedVulnerability) AppendDiffInfo(diff VulnerabilityDiff) *MergedVulnerability {
	mv.Diffs = append(mv.Diffs, diff)
	return mv
}

func NewMergedVulnerability(vulnerability Vulnerability, info ScannerInfo) *MergedVulnerability {
	return &MergedVulnerability{
		ID:            uuid.New().String(),
		Vulnerability: vulnerability,
		ScannersInfo:  []ScannerInfo{info},
	}
}

// handleVulnerabilityWithExistingKey will look for an identical vulnerability for the given otherVulnerability in the mergedVulnerabilities list,
// if identical vulnerability was found, the new scanner info (otherScannerInfo) will be added
// if no identical vulnerability was found, a new MergedVulnerability (with all the differences that was found) will be added.
func handleVulnerabilityWithExistingKey(mergedVulnerabilities []MergedVulnerability, otherVulnerability Vulnerability, otherScannerInfo ScannerInfo) []MergedVulnerability {
	shouldAppendMergedVulnerabilityCandidate := true
	mergedVulnerabilityCandidate := NewMergedVulnerability(otherVulnerability, otherScannerInfo)

	for i := range mergedVulnerabilities {
		diff, err := getDiff(otherVulnerability, mergedVulnerabilities[i].Vulnerability, mergedVulnerabilities[i].ID)
		if err != nil {
			log.Warnf("Failed to calculate diff - keeping both vulnerabilities: %v", err)
		} else if diff != nil {
			// diff found - need to append diff info
			log.Debugf("Vulnerability results from %v is different from %v. diff=%+v", mergedVulnerabilities[i].ScannersInfo, otherScannerInfo, diff)
			mergedVulnerabilityCandidate = mergedVulnerabilityCandidate.AppendDiffInfo(*diff)
		} else {
			// no diff - need to append scanner info
			log.Debugf("Vulnerability results from %v is equal to %v", mergedVulnerabilities[i].ScannersInfo, otherScannerInfo)
			mergedVulnerabilities[i].AppendScannerInfo(otherScannerInfo)
			shouldAppendMergedVulnerabilityCandidate = false
			break
		}
	}

	if shouldAppendMergedVulnerabilityCandidate {
		mergedVulnerabilities = append(mergedVulnerabilities, *mergedVulnerabilityCandidate)
	}

	return mergedVulnerabilities
}

func getDiff(vulnerability, compareToVulnerability Vulnerability, compareToID string) (*VulnerabilityDiff, error) {
	compareToVulnerabilityB, err := json.Marshal(compareToVulnerability.sorted())
	if err != nil {
		return nil, fmt.Errorf("failed to Marshal. compareToVulnerability=%+v: %w", compareToVulnerability, err)
	}

	vulnerabilityB, err := json.Marshal(vulnerability.sorted())
	if err != nil {
		return nil, fmt.Errorf("failed to Marshal. vulnerability=%+v: %w", vulnerability, err)
	}

	differ := gojsondiff.New()
	diff, err := differ.Compare(compareToVulnerabilityB, vulnerabilityB)
	if err != nil {
		return nil, fmt.Errorf("failed to compare vulnerabilities: %w", err)
	}

	// nolint:nilnil
	if !diff.Modified() {
		return nil, nil
	}

	var templateJSON map[string]interface{}
	err = json.Unmarshal(compareToVulnerabilityB, &templateJSON)
	if err != nil {
		return nil, fmt.Errorf("failed to Unmarshal. compareToVulnerabilityB=%s: %w", string(compareToVulnerabilityB), err)
	}

	asciiDiff, err := getASCIIFormatDiff(compareToVulnerabilityB, diff)
	if err != nil {
		return nil, fmt.Errorf("failed to get ascii format diff: %w", err)
	}

	jsonDiff, err := formatter.NewDeltaFormatter().FormatAsJson(diff)
	if err != nil {
		return nil, fmt.Errorf("failed to format delta diff: %w", err)
	}

	// TODO: do we want to ignore some fields in the diff calculation, links for example?

	return &VulnerabilityDiff{
		JSONDiff:    jsonDiff,
		ASCIIDiff:   asciiDiff,
		CompareToID: compareToID,
	}, nil
}

func getASCIIFormatDiff(compareToVulnerabilityB []byte, diff gojsondiff.Diff) (string, error) {
	config := formatter.AsciiFormatterConfig{
		ShowArrayIndex: true,
	}

	var compareToVulnerabilityJSON map[string]interface{}
	_ = json.Unmarshal(compareToVulnerabilityB, &compareToVulnerabilityJSON)
	asciiDiff, err := formatter.NewAsciiFormatter(compareToVulnerabilityJSON, config).Format(diff)
	if err != nil {
		return "", fmt.Errorf("failed to format ascii diff: %w", err)
	}

	return asciiDiff, nil
}

func toVulnerabilityByKey(vulnerabilities []Vulnerability) map[VulnerabilityKey]Vulnerability {
	ret := make(map[VulnerabilityKey]Vulnerability, len(vulnerabilities))
	for _, vulnerability := range vulnerabilities {
		key := NewVulnerabilityKey(vulnerability)
		if log.IsLevelEnabled(log.DebugLevel) {
			if vul, ok := ret[key]; ok {
				diff, err := getDiff(vul, vulnerability, "")
				if err != nil {
					// nolint:errchkjson
					vulB, _ := json.Marshal(vul)
					// nolint:errchkjson
					newVulB, _ := json.Marshal(vulnerability)
					log.Debugf("Existing vul with the same key %q. vul=%s, newVul=%s", key, vulB, newVulB)
				} else if diff != nil {
					log.Debugf("Existing vul with the same key %q. diff.JSONDiff=%+v", key, diff.JSONDiff)
				} else {
					log.Debugf("Existing vul with the same key %q - no diff", key)
				}
			}
		}
		ret[key] = vulnerability
	}
	return ret
}
