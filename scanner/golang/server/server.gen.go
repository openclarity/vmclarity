// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	. "github.com/openclarity/vmclarity/scanner/types"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Check if the API is alive and responsive.
	// (GET /livez)
	IsAlive(ctx echo.Context) error
	// Check if the API is ready to receive traffic.
	// (GET /readyz)
	IsReady(ctx echo.Context) error
	// Delete a scan.
	// (DELETE /scan/{scanID})
	DeleteScan(ctx echo.Context, scanID ScanID) error
	// Get scan details.
	// (GET /scan/{scanID})
	GetScan(ctx echo.Context, scanID ScanID) error
	// Get scan result
	// (GET /scan/{scanID}/result)
	GetScanResult(ctx echo.Context, scanID ScanID) error
	// Stop currently running scan.
	// (POST /scan/{scanID}/stop)
	StopScan(ctx echo.Context, scanID ScanID) error
	// Fetches runtime scanner details.
	// (GET /scanner)
	GetScannerInfo(ctx echo.Context) error
	// Get all scans.
	// (GET /scans)
	GetScans(ctx echo.Context, params GetScansParams) error
	// Create a new scan.
	// (POST /scans)
	CreateScan(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// IsAlive converts echo context to params.
func (w *ServerInterfaceWrapper) IsAlive(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.IsAlive(ctx)
	return err
}

// IsReady converts echo context to params.
func (w *ServerInterfaceWrapper) IsReady(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.IsReady(ctx)
	return err
}

// DeleteScan converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteScan(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteScan(ctx, scanID)
	return err
}

// GetScan converts echo context to params.
func (w *ServerInterfaceWrapper) GetScan(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScan(ctx, scanID)
	return err
}

// GetScanResult converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanResult(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanResult(ctx, scanID)
	return err
}

// StopScan converts echo context to params.
func (w *ServerInterfaceWrapper) StopScan(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.StopScan(ctx, scanID)
	return err
}

// GetScannerInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetScannerInfo(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScannerInfo(ctx)
	return err
}

// GetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetScans(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansParams
	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", ctx.QueryParams(), &params.State)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScans(ctx, params)
	return err
}

// CreateScan converts echo context to params.
func (w *ServerInterfaceWrapper) CreateScan(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateScan(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/livez", wrapper.IsAlive)
	router.GET(baseURL+"/readyz", wrapper.IsReady)
	router.DELETE(baseURL+"/scan/:scanID", wrapper.DeleteScan)
	router.GET(baseURL+"/scan/:scanID", wrapper.GetScan)
	router.GET(baseURL+"/scan/:scanID/result", wrapper.GetScanResult)
	router.POST(baseURL+"/scan/:scanID/stop", wrapper.StopScan)
	router.GET(baseURL+"/scanner", wrapper.GetScannerInfo)
	router.GET(baseURL+"/scans", wrapper.GetScans)
	router.POST(baseURL+"/scans", wrapper.CreateScan)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"iz3/O2B8Rjrv/xUAAP//bJrI/Ms8AAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
