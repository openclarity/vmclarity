// Package types provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package types

import (
	"encoding/json"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for AssetScanInputType.
const (
	AssetScanInputDir           AssetScanInputType = "DIR"
	AssetScanInputDockerArchive AssetScanInputType = "DOCKERARCHIVE"
	AssetScanInputFile          AssetScanInputType = "FILE"
	AssetScanInputImage         AssetScanInputType = "IMAGE"
	AssetScanInputOCIArchive    AssetScanInputType = "OCIARCHIVE"
	AssetScanInputOCIDir        AssetScanInputType = "OCIDIR"
	AssetScanInputRootFS        AssetScanInputType = "ROOTFS"
	AssetScanInputSBOM          AssetScanInputType = "SBOM"
)

// Defines values for InfoType.
const (
	InfoTypeSSHAuthorizedKeyFingerprint InfoType = "SSHAuthorizedKeyFingerprint"
	InfoTypeSSHDaemonKeyFingerprint     InfoType = "SSHDaemonKeyFingerprint"
	InfoTypeSSHKnownHostFingerprint     InfoType = "SSHKnownHostFingerprint"
	InfoTypeSSHPrivateKeyFingerprint    InfoType = "SSHPrivateKeyFingerprint"
	InfoTypeUNKNOWN                     InfoType = "UNKNOWN"
)

// Defines values for MisconfigurationSeverity.
const (
	MisconfigurationHighSeverity   MisconfigurationSeverity = "MisconfigurationHighSeverity"
	MisconfigurationLowSeverity    MisconfigurationSeverity = "MisconfigurationLowSeverity"
	MisconfigurationMediumSeverity MisconfigurationSeverity = "MisconfigurationMediumSeverity"
)

// Defines values for RootkitType.
const (
	RootkitTypeAPPLICATION RootkitType = "APPLICATION"
	RootkitTypeFIRMWARE    RootkitType = "FIRMWARE"
	RootkitTypeKERNEL      RootkitType = "KERNEL"
	RootkitTypeMEMORY      RootkitType = "MEMORY"
	RootkitTypeUNKNOWN     RootkitType = "UNKNOWN"
)

// Defines values for VulnerabilitySeverity.
const (
	CRITICAL   VulnerabilitySeverity = "CRITICAL"
	HIGH       VulnerabilitySeverity = "HIGH"
	LOW        VulnerabilitySeverity = "LOW"
	MEDIUM     VulnerabilitySeverity = "MEDIUM"
	NEGLIGIBLE VulnerabilitySeverity = "NEGLIGIBLE"
)

// AssetScanInput Input data of an asset to scan.
type AssetScanInput struct {
	// Path The input path (/mnt/snapshot for ex.)
	Path string `json:"path"`

	// Type The input type (ROOTFS, DIR, IMAGE etc.)
	Type AssetScanInputType `json:"type"`
}

// AssetScanInputType The input type (ROOTFS, DIR, IMAGE etc.)
type AssetScanInputType string

// ErrorResponse An object that is returned for a failed API request.
type ErrorResponse struct {
	Message *string `json:"message,omitempty"`
}

// Exploit defines model for Exploit.
type Exploit struct {
	CveID       *string   `json:"cveID,omitempty"`
	Description *string   `json:"description,omitempty"`
	Name        *string   `json:"name,omitempty"`
	SourceDB    *string   `json:"sourceDB,omitempty"`
	Title       *string   `json:"title,omitempty"`
	Urls        *[]string `json:"urls"`
}

// Finding defines model for Finding.
type Finding struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *[]struct {
		Key   *string `json:"key,omitempty"`
		Value *string `json:"value,omitempty"`
	} `json:"annotations,omitempty"`
	FindingInfo *Finding_FindingInfo `json:"findingInfo,omitempty"`

	// Input Input data of an asset to scan.
	Input *AssetScanInput `json:"input,omitempty"`
}

// Finding_FindingInfo defines model for Finding.FindingInfo.
type Finding_FindingInfo struct {
	union json.RawMessage
}

// InfoFinder defines model for InfoFinder.
type InfoFinder struct {
	// Data The data found by the scanner in the specific path for a specific type. See example for SSHKnownHostFingerprint info type
	Data *string `json:"data,omitempty"`

	// Path File path containing the info
	Path        *string   `json:"path,omitempty"`
	ScannerName *string   `json:"scannerName,omitempty"`
	Type        *InfoType `json:"type,omitempty"`
}

// InfoType defines model for InfoType.
type InfoType string

// Malware defines model for Malware.
type Malware struct {
	MalwareName *string      `json:"malwareName,omitempty"`
	MalwareType *MalwareType `json:"malwareType,omitempty"`

	// Path Path of the file that contains malware
	Path     *string `json:"path,omitempty"`
	RuleName *string `json:"ruleName,omitempty"`
}

// MalwareType defines model for MalwareType.
type MalwareType = string

// Metadata defines model for Metadata.
type Metadata struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *[]struct {
		Key   *string `json:"key,omitempty"`
		Value *string `json:"value,omitempty"`
	} `json:"annotations,omitempty"`
}

// Misconfiguration defines model for Misconfiguration.
type Misconfiguration struct {
	// Category Specifies misconfiguration impact category
	Category *string `json:"category,omitempty"`

	// Description Additional context such as the potential impact
	Description *string `json:"description,omitempty"`

	// Id Check or test ID, if applicable (e.g. Lynis TestID, CIS Docker Benchmark checkpoint code, etc)
	Id *string `json:"id,omitempty"`

	// Location Location within the asset where the misconfiguration was recorded (e.g. filesystem path)
	Location *string `json:"location,omitempty"`

	// Message Short info about the misconfiguration
	Message *string `json:"message,omitempty"`

	// Remediation Possible fix for the misconfiguration
	Remediation *string                   `json:"remediation,omitempty"`
	ScannerName *string                   `json:"scannerName,omitempty"`
	Severity    *MisconfigurationSeverity `json:"severity,omitempty"`
}

// MisconfigurationSeverity defines model for MisconfigurationSeverity.
type MisconfigurationSeverity string

// Package defines model for Package.
type Package struct {
	Cpes     *[]string `json:"cpes"`
	Language *string   `json:"language,omitempty"`
	Licenses *[]string `json:"licenses"`
	Name     *string   `json:"name,omitempty"`
	Purl     *string   `json:"purl,omitempty"`
	Type     *string   `json:"type,omitempty"`
	Version  *string   `json:"version,omitempty"`
}

// Rootkit defines model for Rootkit.
type Rootkit struct {
	Message     *string      `json:"message,omitempty"`
	RootkitName *string      `json:"rootkitName,omitempty"`
	RootkitType *RootkitType `json:"rootkitType,omitempty"`
}

// RootkitType defines model for RootkitType.
type RootkitType string

// Scan defines model for Scan.
type Scan struct {
	// Annotations Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
	Annotations *[]struct {
		Key   *string `json:"key,omitempty"`
		Value *string `json:"value,omitempty"`
	} `json:"annotations,omitempty"`
	EndTime       *time.Time    `json:"endTime,omitempty"`
	JobsCompleted *int          `json:"jobsCompleted,omitempty"`
	JobsLeftToRun *int          `json:"jobsLeftToRun,omitempty"`
	StartTime     *time.Time    `json:"startTime,omitempty"`
	Template      *ScanTemplate `json:"template,omitempty"`
}

// ScanResult defines model for ScanResult.
type ScanResult struct {
	Findings *[]Finding `json:"findings,omitempty"`

	// Scan Describes a multi-asset scan.
	Scan *Scan `json:"scan,omitempty"`
}

// ScanTemplate defines model for ScanTemplate.
type ScanTemplate struct {
	// AssetScanInputs List of assets to scan.
	AssetScanInputs []AssetScanInput `json:"assetScanInputs"`

	// TimeoutSeconds The maximum time in seconds that a scan should
	// run for before being automatically aborted.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

// Secret defines model for Secret.
type Secret struct {
	Description *string `json:"description,omitempty"`
	EndColumn   *int    `json:"endColumn,omitempty"`
	EndLine     *int    `json:"endLine,omitempty"`

	// FilePath Name of the file containing the secret
	FilePath *string `json:"filePath,omitempty"`

	// Fingerprint Note: this is not unique
	Fingerprint *string `json:"fingerprint,omitempty"`
	StartColumn *int    `json:"startColumn,omitempty"`
	StartLine   *int    `json:"startLine,omitempty"`
}

// SuccessResponse An object that is returned for a successful API request that returns nothing.
type SuccessResponse struct {
	Message *string `json:"message,omitempty"`
}

// Vulnerability defines model for Vulnerability.
type Vulnerability struct {
	Cvss        *[]VulnerabilityCvss `json:"cvss"`
	Description *string              `json:"description,omitempty"`

	// Distro Distro provides information about a detected OS distribution.
	Distro            *VulnerabilityDistro   `json:"distro,omitempty"`
	Fix               *VulnerabilityFix      `json:"fix,omitempty"`
	LayerId           *string                `json:"layerId,omitempty"`
	Links             *[]string              `json:"links"`
	Package           *Package               `json:"package,omitempty"`
	Path              *string                `json:"path,omitempty"`
	Severity          *VulnerabilitySeverity `json:"severity,omitempty"`
	VulnerabilityName *string                `json:"vulnerabilityName,omitempty"`
}

// VulnerabilityCvss defines model for VulnerabilityCvss.
type VulnerabilityCvss struct {
	Metrics *VulnerabilityCvssMetrics `json:"metrics,omitempty"`
	Vector  *string                   `json:"vector,omitempty"`
	Version *string                   `json:"version,omitempty"`
}

// VulnerabilityCvssMetrics defines model for VulnerabilityCvssMetrics.
type VulnerabilityCvssMetrics struct {
	BaseScore           *float32 `json:"baseScore,omitempty"`
	ExploitabilityScore *float32 `json:"exploitabilityScore,omitempty"`
	ImpactScore         *float32 `json:"impactScore,omitempty"`
}

// VulnerabilityDistro Distro provides information about a detected OS distribution.
type VulnerabilityDistro struct {
	// IDLike the ID_LIKE field found within Linux OS /etc/os-release file
	IDLike *[]string `json:"IDLike"`

	// Name Name of the OS distribution
	Name *string `json:"name,omitempty"`

	// Version Version of the OS distribution (major or major.minor version)
	Version *string `json:"version,omitempty"`
}

// VulnerabilityFix defines model for VulnerabilityFix.
type VulnerabilityFix struct {
	State    *string   `json:"state,omitempty"`
	Versions *[]string `json:"versions"`
}

// VulnerabilitySeverity defines model for VulnerabilitySeverity.
type VulnerabilitySeverity string

// Force defines model for force.
type Force = bool

// UnknownError An object that is returned for a failed API request.
type UnknownError = ErrorResponse

// StopScanParams defines parameters for StopScan.
type StopScanParams struct {
	Force *Force `form:"force,omitempty" json:"force,omitempty"`
}

// StartScanJSONRequestBody defines body for StartScan for application/json ContentType.
type StartScanJSONRequestBody = ScanTemplate

// AsPackage returns the union data inside the Finding_FindingInfo as a Package
func (t Finding_FindingInfo) AsPackage() (Package, error) {
	var body Package
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackage overwrites any union data inside the Finding_FindingInfo as the provided Package
func (t *Finding_FindingInfo) FromPackage(v Package) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackage performs a merge with any union data inside the Finding_FindingInfo, using the provided Package
func (t *Finding_FindingInfo) MergePackage(v Package) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVulnerability returns the union data inside the Finding_FindingInfo as a Vulnerability
func (t Finding_FindingInfo) AsVulnerability() (Vulnerability, error) {
	var body Vulnerability
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnerability overwrites any union data inside the Finding_FindingInfo as the provided Vulnerability
func (t *Finding_FindingInfo) FromVulnerability(v Vulnerability) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnerability performs a merge with any union data inside the Finding_FindingInfo, using the provided Vulnerability
func (t *Finding_FindingInfo) MergeVulnerability(v Vulnerability) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMalware returns the union data inside the Finding_FindingInfo as a Malware
func (t Finding_FindingInfo) AsMalware() (Malware, error) {
	var body Malware
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMalware overwrites any union data inside the Finding_FindingInfo as the provided Malware
func (t *Finding_FindingInfo) FromMalware(v Malware) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMalware performs a merge with any union data inside the Finding_FindingInfo, using the provided Malware
func (t *Finding_FindingInfo) MergeMalware(v Malware) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecret returns the union data inside the Finding_FindingInfo as a Secret
func (t Finding_FindingInfo) AsSecret() (Secret, error) {
	var body Secret
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecret overwrites any union data inside the Finding_FindingInfo as the provided Secret
func (t *Finding_FindingInfo) FromSecret(v Secret) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecret performs a merge with any union data inside the Finding_FindingInfo, using the provided Secret
func (t *Finding_FindingInfo) MergeSecret(v Secret) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMisconfiguration returns the union data inside the Finding_FindingInfo as a Misconfiguration
func (t Finding_FindingInfo) AsMisconfiguration() (Misconfiguration, error) {
	var body Misconfiguration
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMisconfiguration overwrites any union data inside the Finding_FindingInfo as the provided Misconfiguration
func (t *Finding_FindingInfo) FromMisconfiguration(v Misconfiguration) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMisconfiguration performs a merge with any union data inside the Finding_FindingInfo, using the provided Misconfiguration
func (t *Finding_FindingInfo) MergeMisconfiguration(v Misconfiguration) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRootkit returns the union data inside the Finding_FindingInfo as a Rootkit
func (t Finding_FindingInfo) AsRootkit() (Rootkit, error) {
	var body Rootkit
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRootkit overwrites any union data inside the Finding_FindingInfo as the provided Rootkit
func (t *Finding_FindingInfo) FromRootkit(v Rootkit) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRootkit performs a merge with any union data inside the Finding_FindingInfo, using the provided Rootkit
func (t *Finding_FindingInfo) MergeRootkit(v Rootkit) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsExploit returns the union data inside the Finding_FindingInfo as a Exploit
func (t Finding_FindingInfo) AsExploit() (Exploit, error) {
	var body Exploit
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExploit overwrites any union data inside the Finding_FindingInfo as the provided Exploit
func (t *Finding_FindingInfo) FromExploit(v Exploit) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExploit performs a merge with any union data inside the Finding_FindingInfo, using the provided Exploit
func (t *Finding_FindingInfo) MergeExploit(v Exploit) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsInfoFinder returns the union data inside the Finding_FindingInfo as a InfoFinder
func (t Finding_FindingInfo) AsInfoFinder() (InfoFinder, error) {
	var body InfoFinder
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInfoFinder overwrites any union data inside the Finding_FindingInfo as the provided InfoFinder
func (t *Finding_FindingInfo) FromInfoFinder(v InfoFinder) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInfoFinder performs a merge with any union data inside the Finding_FindingInfo, using the provided InfoFinder
func (t *Finding_FindingInfo) MergeInfoFinder(v InfoFinder) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Finding_FindingInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Finding_FindingInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
