// Package server provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package server

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	. "github.com/openclarity/vmclarity/scanner/types"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get all available findings.
	// (GET /findings)
	GetFindings(ctx echo.Context, params GetFindingsParams) error
	// Get all findings for a given scan.
	// (GET /findings/{scanID})
	GetScanFindingsForScan(ctx echo.Context, scanID ScanID) error
	// Check if the API is alive and responsive.
	// (GET /livez)
	IsAlive(ctx echo.Context) error
	// Check if the API is ready to receive traffic.
	// (GET /readyz)
	IsReady(ctx echo.Context) error
	// Get scan.
	// (GET /scan/{scanID})
	GetScan(ctx echo.Context, scanID ScanID) error
	// Submit a scan event.
	// (POST /scan/{scanID}/event)
	SubmitScanEvent(ctx echo.Context, scanID ScanID) error
	// Mark scan as aborted.
	// (POST /scan/{scanID}/stop)
	MarkScanAborted(ctx echo.Context, scanID ScanID) error
	// Get all scans.
	// (GET /scans)
	GetScans(ctx echo.Context, params GetScansParams) error
	// Create a new scan.
	// (POST /scans)
	CreateScan(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetFindings converts echo context to params.
func (w *ServerInterfaceWrapper) GetFindings(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFindingsParams
	// ------------- Optional query parameter "metaSelectors" -------------

	err = runtime.BindQueryParameter("form", true, false, "metaSelectors", ctx.QueryParams(), &params.MetaSelectors)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter metaSelectors: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFindings(ctx, params)
	return err
}

// GetScanFindingsForScan converts echo context to params.
func (w *ServerInterfaceWrapper) GetScanFindingsForScan(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScanFindingsForScan(ctx, scanID)
	return err
}

// IsAlive converts echo context to params.
func (w *ServerInterfaceWrapper) IsAlive(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.IsAlive(ctx)
	return err
}

// IsReady converts echo context to params.
func (w *ServerInterfaceWrapper) IsReady(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.IsReady(ctx)
	return err
}

// GetScan converts echo context to params.
func (w *ServerInterfaceWrapper) GetScan(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScan(ctx, scanID)
	return err
}

// SubmitScanEvent converts echo context to params.
func (w *ServerInterfaceWrapper) SubmitScanEvent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SubmitScanEvent(ctx, scanID)
	return err
}

// MarkScanAborted converts echo context to params.
func (w *ServerInterfaceWrapper) MarkScanAborted(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "scanID" -------------
	var scanID ScanID

	err = runtime.BindStyledParameterWithOptions("simple", "scanID", ctx.Param("scanID"), &scanID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scanID: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MarkScanAborted(ctx, scanID)
	return err
}

// GetScans converts echo context to params.
func (w *ServerInterfaceWrapper) GetScans(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params GetScansParams
	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", true, false, "state", ctx.QueryParams(), &params.State)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter state: %s", err))
	}

	// ------------- Optional query parameter "metaSelectors" -------------

	err = runtime.BindQueryParameter("form", true, false, "metaSelectors", ctx.QueryParams(), &params.MetaSelectors)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter metaSelectors: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetScans(ctx, params)
	return err
}

// CreateScan converts echo context to params.
func (w *ServerInterfaceWrapper) CreateScan(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateScan(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/findings", wrapper.GetFindings)
	router.GET(baseURL+"/findings/:scanID", wrapper.GetScanFindingsForScan)
	router.GET(baseURL+"/livez", wrapper.IsAlive)
	router.GET(baseURL+"/readyz", wrapper.IsReady)
	router.GET(baseURL+"/scan/:scanID", wrapper.GetScan)
	router.POST(baseURL+"/scan/:scanID/event", wrapper.SubmitScanEvent)
	router.POST(baseURL+"/scan/:scanID/stop", wrapper.MarkScanAborted)
	router.GET(baseURL+"/scans", wrapper.GetScans)
	router.POST(baseURL+"/scans", wrapper.CreateScan)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
