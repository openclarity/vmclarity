/* tslint:disable */
/* eslint-disable */
/**
 * VMClarity APIs
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AnnotationsInner
 */
export interface AnnotationsInner {
    /**
     * 
     * @type {string}
     * @memberof AnnotationsInner
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationsInner
     */
    'value'?: string;
}
/**
 * An object that is returned in all cases of failures.
 * @export
 * @interface ApiResponse
 */
export interface ApiResponse {
    /**
     * 
     * @type {string}
     * @memberof ApiResponse
     */
    'message'?: string;
}
/**
 * Describes an asset object.
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof Asset
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Asset
     */
    'revision'?: number;
    /**
     * 
     * @type {AssetType}
     * @memberof Asset
     */
    'assetInfo'?: AssetType;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'firstSeen'?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'terminatedOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof Asset
     */
    'lastSeen'?: string;
    /**
     * Total number of scans that have ever run for this asset
     * @type {number}
     * @memberof Asset
     */
    'scansCount'?: number;
    /**
     * 
     * @type {ScanFindingsSummary}
     * @memberof Asset
     */
    'summary'?: ScanFindingsSummary;
    /**
     * List of providers which discover the asset.
     * @type {Array<ProviderRelationship>}
     * @memberof Asset
     */
    'providers'?: Array<ProviderRelationship>;
}
/**
 * 
 * @export
 * @interface AssetExists
 */
export interface AssetExists {
    /**
     * Describes which unique constraint combination causes the conflict.
     * @type {string}
     * @memberof AssetExists
     */
    'message'?: string;
    /**
     * 
     * @type {Asset}
     * @memberof AssetExists
     */
    'asset'?: Asset;
}
/**
 * 
 * @export
 * @interface AssetFinding
 */
export interface AssetFinding {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof AssetFinding
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {string}
     * @memberof AssetFinding
     */
    'id'?: string;
    /**
     * 
     * @type {AssetRelationship}
     * @memberof AssetFinding
     */
    'asset'?: AssetRelationship;
    /**
     * 
     * @type {FindingRelationship}
     * @memberof AssetFinding
     */
    'finding'?: FindingRelationship;
    /**
     * When this asset finding was first discovered by a scan
     * @type {string}
     * @memberof AssetFinding
     */
    'firstSeen'?: string;
    /**
     * When this asset finding was last discovered by a scan
     * @type {string}
     * @memberof AssetFinding
     */
    'lastSeen'?: string;
    /**
     * When this asset finding was invalidated by a newer scan
     * @type {string}
     * @memberof AssetFinding
     */
    'invalidatedOn'?: string;
    /**
     * 
     * @type {number}
     * @memberof AssetFinding
     */
    'revision'?: number;
}
/**
 * 
 * @export
 * @interface AssetFindingExists
 */
export interface AssetFindingExists {
    /**
     * Describes which unique constraint combination causes the conflict.
     * @type {string}
     * @memberof AssetFindingExists
     */
    'message'?: string;
    /**
     * 
     * @type {AssetFinding}
     * @memberof AssetFindingExists
     */
    'finding'?: AssetFinding;
}
/**
 * 
 * @export
 * @interface AssetFindings
 */
export interface AssetFindings {
    /**
     * Total asset findings count according to the given filters
     * @type {number}
     * @memberof AssetFindings
     */
    'count'?: number;
    /**
     * List of asset findings according to the given filters
     * @type {Array<AssetFinding>}
     * @memberof AssetFindings
     */
    'items'?: Array<AssetFinding>;
}
/**
 * Describes a relationship to an asset which can be expanded.
 * @export
 * @interface AssetRelationship
 */
export interface AssetRelationship {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof AssetRelationship
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {string}
     * @memberof AssetRelationship
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof AssetRelationship
     */
    'revision'?: number;
    /**
     * 
     * @type {AssetType}
     * @memberof AssetRelationship
     */
    'assetInfo'?: AssetType;
    /**
     * Total number of scans that have ever run for this asset
     * @type {number}
     * @memberof AssetRelationship
     */
    'scansCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof AssetRelationship
     */
    'firstSeen'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetRelationship
     */
    'terminatedOn'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetRelationship
     */
    'lastSeen'?: string;
    /**
     * 
     * @type {ScanFindingsSummary}
     * @memberof AssetRelationship
     */
    'summary'?: ScanFindingsSummary;
    /**
     * List of providers which discover the asset.
     * @type {Array<ProviderRelationship>}
     * @memberof AssetRelationship
     */
    'providers'?: Array<ProviderRelationship>;
}
/**
 * 
 * @export
 * @interface AssetScan
 */
export interface AssetScan {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof AssetScan
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {ScanFamiliesConfig}
     * @memberof AssetScan
     */
    'scanFamiliesConfig'?: ScanFamiliesConfig;
    /**
     * 
     * @type {ScannerInstanceCreationConfig}
     * @memberof AssetScan
     */
    'scannerInstanceCreationConfig'?: ScannerInstanceCreationConfig;
    /**
     * 
     * @type {string}
     * @memberof AssetScan
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof AssetScan
     */
    'revision'?: number;
    /**
     * 
     * @type {AssetRelationship}
     * @memberof AssetScan
     */
    'asset'?: AssetRelationship;
    /**
     * 
     * @type {ScanRelationship}
     * @memberof AssetScan
     */
    'scan'?: ScanRelationship;
    /**
     * 
     * @type {AssetScanStatus}
     * @memberof AssetScan
     */
    'status'?: AssetScanStatus;
    /**
     * 
     * @type {SbomScan}
     * @memberof AssetScan
     */
    'sbom'?: SbomScan;
    /**
     * 
     * @type {VulnerabilityScan}
     * @memberof AssetScan
     */
    'vulnerabilities'?: VulnerabilityScan;
    /**
     * 
     * @type {MalwareScan}
     * @memberof AssetScan
     */
    'malware'?: MalwareScan;
    /**
     * 
     * @type {RootkitScan}
     * @memberof AssetScan
     */
    'rootkits'?: RootkitScan;
    /**
     * 
     * @type {SecretScan}
     * @memberof AssetScan
     */
    'secrets'?: SecretScan;
    /**
     * 
     * @type {MisconfigurationScan}
     * @memberof AssetScan
     */
    'misconfigurations'?: MisconfigurationScan;
    /**
     * 
     * @type {ExploitScan}
     * @memberof AssetScan
     */
    'exploits'?: ExploitScan;
    /**
     * 
     * @type {InfoFinderScan}
     * @memberof AssetScan
     */
    'infoFinder'?: InfoFinderScan;
    /**
     * 
     * @type {PluginScan}
     * @memberof AssetScan
     */
    'plugins'?: PluginScan;
    /**
     * 
     * @type {boolean}
     * @memberof AssetScan
     */
    'findingsProcessed'?: boolean;
    /**
     * 
     * @type {ResourceCleanupStatus}
     * @memberof AssetScan
     */
    'resourceCleanupStatus'?: ResourceCleanupStatus;
    /**
     * 
     * @type {AssetScanStats}
     * @memberof AssetScan
     */
    'stats'?: AssetScanStats;
    /**
     * 
     * @type {ScanFindingsSummary}
     * @memberof AssetScan
     */
    'summary'?: ScanFindingsSummary;
    /**
     * 
     * @type {ProviderRelationship}
     * @memberof AssetScan
     */
    'provider'?: ProviderRelationship;
}
/**
 * 
 * @export
 * @interface AssetScanEstimation
 */
export interface AssetScanEstimation {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof AssetScanEstimation
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {string}
     * @memberof AssetScanEstimation
     */
    'id'?: string;
    /**
     * 
     * @type {AssetRelationship}
     * @memberof AssetScanEstimation
     */
    'asset'?: AssetRelationship;
    /**
     * 
     * @type {ScanEstimationRelationship}
     * @memberof AssetScanEstimation
     */
    'scanEstimation'?: ScanEstimationRelationship;
    /**
     * 
     * @type {AssetScanEstimationStatus}
     * @memberof AssetScanEstimation
     */
    'status'?: AssetScanEstimationStatus;
    /**
     * 
     * @type {Estimation}
     * @memberof AssetScanEstimation
     */
    'estimation'?: Estimation;
    /**
     * 
     * @type {AssetScanTemplate}
     * @memberof AssetScanEstimation
     */
    'assetScanTemplate'?: AssetScanTemplate;
    /**
     * 
     * @type {number}
     * @memberof AssetScanEstimation
     */
    'revision'?: number;
    /**
     * 
     * @type {string}
     * @memberof AssetScanEstimation
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetScanEstimation
     */
    'endTime'?: string;
    /**
     * The duration in seconds this resource should last until it is deleted.
     * @type {number}
     * @memberof AssetScanEstimation
     */
    'ttlSecondsAfterFinished'?: number;
    /**
     * The time this resource should be deleted. This value is calculated by endTime + ttlSecondsAfterFinished. This should not be set by the user, but use ttlSecondsAfterFinished instead.
     * @type {string}
     * @memberof AssetScanEstimation
     */
    'deleteAfter'?: string;
}
/**
 * 
 * @export
 * @interface AssetScanEstimationExists
 */
export interface AssetScanEstimationExists {
    /**
     * Describes which unique constraint combination causes the conflict.
     * @type {string}
     * @memberof AssetScanEstimationExists
     */
    'message'?: string;
    /**
     * 
     * @type {AssetScanEstimation}
     * @memberof AssetScanEstimationExists
     */
    'assetScanEstimation'?: AssetScanEstimation;
}
/**
 * 
 * @export
 * @interface AssetScanEstimationRelationship
 */
export interface AssetScanEstimationRelationship {
    /**
     * 
     * @type {string}
     * @memberof AssetScanEstimationRelationship
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface AssetScanEstimationStatus
 */
export interface AssetScanEstimationStatus {
    /**
     * Describes the state of asset scan estimation.  | State   | Description                                   | | ------- | --------------------------------------------- | | Pending | Initial state for AssetScanEstimation         | | Aborted | AssetScanEstimation has been aborted          | | Failed  | AssetScanEstimation has been failed           | | Done    | AssetScanEstimation has finished successfully | 
     * @type {string}
     * @memberof AssetScanEstimationStatus
     */
    'state': AssetScanEstimationStatusStateEnum;
    /**
     * Machine readable reason for state transition.  | State   | Reason       | Description                                                      | | ------- | ------------ | ---------------------------------------------------------------- | | Pending | Created      | AssetScanEstimation is pending as it has been newly created      | | Aborted | Cancellation | AssetScanEstimation has been aborted due to cancellation request | | Failed  | Aborted      | AssetScanEstimation has failed due to abort                      | | Failed  | Error        | AssetScanEstimation has failed due to an error                   | | Done    | Success      | AssetScanEstimation has finished successfully                    | 
     * @type {string}
     * @memberof AssetScanEstimationStatus
     */
    'reason': AssetScanEstimationStatusReasonEnum;
    /**
     * Human readable message.
     * @type {string}
     * @memberof AssetScanEstimationStatus
     */
    'message'?: string;
    /**
     * Last date time when the status has changed.
     * @type {string}
     * @memberof AssetScanEstimationStatus
     */
    'lastTransitionTime': string;
}

export const AssetScanEstimationStatusStateEnum = {
    Pending: 'Pending',
    Aborted: 'Aborted',
    Failed: 'Failed',
    Done: 'Done'
} as const;

export type AssetScanEstimationStatusStateEnum = typeof AssetScanEstimationStatusStateEnum[keyof typeof AssetScanEstimationStatusStateEnum];
export const AssetScanEstimationStatusReasonEnum = {
    AssetScanEstimationStatusReasonCreated: 'Created',
    AssetScanEstimationStatusReasonCancellation: 'Cancellation',
    AssetScanEstimationStatusReasonAborted: 'Aborted',
    AssetScanEstimationStatusReasonError: 'Error',
    AssetScanEstimationStatusReasonSuccess: 'Success'
} as const;

export type AssetScanEstimationStatusReasonEnum = typeof AssetScanEstimationStatusReasonEnum[keyof typeof AssetScanEstimationStatusReasonEnum];

/**
 * 
 * @export
 * @interface AssetScanEstimations
 */
export interface AssetScanEstimations {
    /**
     * Total AssetScanEstimations count according to the given filters
     * @type {number}
     * @memberof AssetScanEstimations
     */
    'count'?: number;
    /**
     * List of AssetScanEstimations according to the given filters
     * @type {Array<AssetScanEstimation>}
     * @memberof AssetScanEstimations
     */
    'items'?: Array<AssetScanEstimation>;
}
/**
 * 
 * @export
 * @interface AssetScanExists
 */
export interface AssetScanExists {
    /**
     * Describes which unique constraint combination causes the conflict.
     * @type {string}
     * @memberof AssetScanExists
     */
    'message'?: string;
    /**
     * 
     * @type {AssetScan}
     * @memberof AssetScanExists
     */
    'assetScan'?: AssetScan;
}
/**
 * Global statistics for asset scan of all families.
 * @export
 * @interface AssetScanGeneralStats
 */
export interface AssetScanGeneralStats {
    /**
     * 
     * @type {AssetScanScanTime}
     * @memberof AssetScanGeneralStats
     */
    'scanTime'?: AssetScanScanTime;
}
/**
 * Statistics per asset scan input.
 * @export
 * @interface AssetScanInputScanStats
 */
export interface AssetScanInputScanStats {
    /**
     * The input type (ROOTFS, DIR, IMAGE etc.)
     * @type {string}
     * @memberof AssetScanInputScanStats
     */
    'type'?: string;
    /**
     * The input path (/mnt/snapshot for ex.)
     * @type {string}
     * @memberof AssetScanInputScanStats
     */
    'path'?: string;
    /**
     * The input size in MB.
     * @type {number}
     * @memberof AssetScanInputScanStats
     */
    'size'?: number;
    /**
     * 
     * @type {AssetScanScanTime}
     * @memberof AssetScanInputScanStats
     */
    'scanTime'?: AssetScanScanTime;
}
/**
 * 
 * @export
 * @interface AssetScanRelationship
 */
export interface AssetScanRelationship {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof AssetScanRelationship
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {ScanFamiliesConfig}
     * @memberof AssetScanRelationship
     */
    'scanFamiliesConfig'?: ScanFamiliesConfig;
    /**
     * 
     * @type {ScannerInstanceCreationConfig}
     * @memberof AssetScanRelationship
     */
    'scannerInstanceCreationConfig'?: ScannerInstanceCreationConfig;
    /**
     * 
     * @type {string}
     * @memberof AssetScanRelationship
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof AssetScanRelationship
     */
    'revision'?: number;
    /**
     * 
     * @type {AssetRelationship}
     * @memberof AssetScanRelationship
     */
    'asset'?: AssetRelationship;
    /**
     * 
     * @type {ScanRelationship}
     * @memberof AssetScanRelationship
     */
    'scan'?: ScanRelationship;
    /**
     * 
     * @type {AssetScanStatus}
     * @memberof AssetScanRelationship
     */
    'status'?: AssetScanStatus;
    /**
     * 
     * @type {SbomScan}
     * @memberof AssetScanRelationship
     */
    'sbom'?: SbomScan;
    /**
     * 
     * @type {VulnerabilityScan}
     * @memberof AssetScanRelationship
     */
    'vulnerabilities'?: VulnerabilityScan;
    /**
     * 
     * @type {MalwareScan}
     * @memberof AssetScanRelationship
     */
    'malware'?: MalwareScan;
    /**
     * 
     * @type {RootkitScan}
     * @memberof AssetScanRelationship
     */
    'rootkits'?: RootkitScan;
    /**
     * 
     * @type {SecretScan}
     * @memberof AssetScanRelationship
     */
    'secrets'?: SecretScan;
    /**
     * 
     * @type {MisconfigurationScan}
     * @memberof AssetScanRelationship
     */
    'misconfigurations'?: MisconfigurationScan;
    /**
     * 
     * @type {ExploitScan}
     * @memberof AssetScanRelationship
     */
    'exploits'?: ExploitScan;
    /**
     * 
     * @type {InfoFinderScan}
     * @memberof AssetScanRelationship
     */
    'infoFinder'?: InfoFinderScan;
    /**
     * 
     * @type {boolean}
     * @memberof AssetScanRelationship
     */
    'findingsProcessed'?: boolean;
    /**
     * 
     * @type {ResourceCleanupStatus}
     * @memberof AssetScanRelationship
     */
    'resourceCleanupStatus'?: ResourceCleanupStatus;
    /**
     * 
     * @type {AssetScanStats}
     * @memberof AssetScanRelationship
     */
    'stats'?: AssetScanStats;
    /**
     * 
     * @type {ScanFindingsSummary}
     * @memberof AssetScanRelationship
     */
    'summary'?: ScanFindingsSummary;
}
/**
 * 
 * @export
 * @interface AssetScanScanTime
 */
export interface AssetScanScanTime {
    /**
     * 
     * @type {string}
     * @memberof AssetScanScanTime
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetScanScanTime
     */
    'endTime'?: string;
}
/**
 * 
 * @export
 * @interface AssetScanStats
 */
export interface AssetScanStats {
    /**
     * 
     * @type {AssetScanGeneralStats}
     * @memberof AssetScanStats
     */
    'general'?: AssetScanGeneralStats;
    /**
     * 
     * @type {Array<AssetScanInputScanStats>}
     * @memberof AssetScanStats
     */
    'sbom'?: Array<AssetScanInputScanStats>;
    /**
     * 
     * @type {Array<AssetScanInputScanStats>}
     * @memberof AssetScanStats
     */
    'vulnerabilities'?: Array<AssetScanInputScanStats>;
    /**
     * 
     * @type {Array<AssetScanInputScanStats>}
     * @memberof AssetScanStats
     */
    'malware'?: Array<AssetScanInputScanStats>;
    /**
     * 
     * @type {Array<AssetScanInputScanStats>}
     * @memberof AssetScanStats
     */
    'rootkits'?: Array<AssetScanInputScanStats>;
    /**
     * 
     * @type {Array<AssetScanInputScanStats>}
     * @memberof AssetScanStats
     */
    'secrets'?: Array<AssetScanInputScanStats>;
    /**
     * 
     * @type {Array<AssetScanInputScanStats>}
     * @memberof AssetScanStats
     */
    'misconfigurations'?: Array<AssetScanInputScanStats>;
    /**
     * 
     * @type {Array<AssetScanInputScanStats>}
     * @memberof AssetScanStats
     */
    'exploits'?: Array<AssetScanInputScanStats>;
    /**
     * 
     * @type {Array<AssetScanInputScanStats>}
     * @memberof AssetScanStats
     */
    'infoFinder'?: Array<AssetScanInputScanStats>;
    /**
     * 
     * @type {Array<AssetScanInputScanStats>}
     * @memberof AssetScanStats
     */
    'plugins'?: Array<AssetScanInputScanStats>;
}
/**
 * 
 * @export
 * @interface AssetScanStatus
 */
export interface AssetScanStatus {
    /**
     * Describes the state of scan result.  | State       | Description                                                                                      | | ----------- | ------------------------------------------------------------------------------------------------ | | Pending     | Initial state for AssetScan waiting for being scheduled                                          | | Scheduled   | AssetScan which has been scheduled on Provider                                                   | | ReadyToScan | Provider acknowledged that scanners for AssetScan is ready to run                                | | InProgress  | Scanners are running on the Target                                                               | | Aborted     | AssetScan has been aborted and all running Scanners need to be cancelled and shutdown gracefully | | Failed      | Running Scanners on Target has failed, check *reason* and *message* fields for the details       | | Done        | Running Scanners on Target has finished with no errors                                           | 
     * @type {string}
     * @memberof AssetScanStatus
     */
    'state': AssetScanStatusStateEnum;
    /**
     * Machine readable reason for state transition.  | State       | Reason           | Description                                                                                | | ----------- | ---------------- | ------------------------------------------------------------------------------------------ | | Pending     | Created          | Scan is pending as it has been newly created                                               | | Scheduled   | Provisioning     | Scan is scheduled as Asset resources are being provisioned                                 | | ReadyToScan | UnSupervised     | Scan is created manually without the involvement of the Orchestrator (e.g. CI/CD scenario) | | ReadyToScan | ResourcesReady   | Scan is ready to scan as Asset resources have been provisioned                             | | InProgress  | ScannerIsRunning | Scan is in progress as Scanner is still performing scanning on Asset resources             | | Aborted     | Cancellation     | Scan has been aborted due to cancellation request                                          | | Aborted     | Timeout          | Scan has been aborted due to timeout                                                       | | Failed      | Error            | Scan has failed to one or more errors reported by the Scanner                              | | Failed      | AbortTimeout     | Scan has failed due to being in Aborted state for too long                                 | | Done        | Success          | Scan has finished successfully                                                             | 
     * @type {string}
     * @memberof AssetScanStatus
     */
    'reason': AssetScanStatusReasonEnum;
    /**
     * Human readable message.
     * @type {string}
     * @memberof AssetScanStatus
     */
    'message'?: string;
    /**
     * Last date time when the status has changed.
     * @type {string}
     * @memberof AssetScanStatus
     */
    'lastTransitionTime': string;
}

export const AssetScanStatusStateEnum = {
    Pending: 'Pending',
    Scheduled: 'Scheduled',
    ReadyToScan: 'ReadyToScan',
    InProgress: 'InProgress',
    Aborted: 'Aborted',
    Failed: 'Failed',
    Done: 'Done'
} as const;

export type AssetScanStatusStateEnum = typeof AssetScanStatusStateEnum[keyof typeof AssetScanStatusStateEnum];
export const AssetScanStatusReasonEnum = {
    AssetScanStatusReasonCreated: 'Created',
    AssetScanStatusReasonProvisioning: 'Provisioning',
    AssetScanStatusReasonUnSupervised: 'UnSupervised',
    AssetScanStatusReasonResourcesReady: 'ResourcesReady',
    AssetScanStatusReasonScannerIsRunning: 'ScannerIsRunning',
    AssetScanStatusReasonCancellation: 'Cancellation',
    AssetScanStatusReasonTimeout: 'Timeout',
    AssetScanStatusReasonError: 'Error',
    AssetScanStatusReasonAbortTimeout: 'AbortTimedOut',
    AssetScanStatusReasonSuccess: 'Success'
} as const;

export type AssetScanStatusReasonEnum = typeof AssetScanStatusReasonEnum[keyof typeof AssetScanStatusReasonEnum];

/**
 * 
 * @export
 * @interface AssetScanTemplate
 */
export interface AssetScanTemplate {
    /**
     * 
     * @type {ScanFamiliesConfig}
     * @memberof AssetScanTemplate
     */
    'scanFamiliesConfig'?: ScanFamiliesConfig;
    /**
     * 
     * @type {ScannerInstanceCreationConfig}
     * @memberof AssetScanTemplate
     */
    'scannerInstanceCreationConfig'?: ScannerInstanceCreationConfig;
}
/**
 * 
 * @export
 * @interface AssetScanTemplateReadOnly
 */
export interface AssetScanTemplateReadOnly {
    /**
     * 
     * @type {ScanFamiliesConfig}
     * @memberof AssetScanTemplateReadOnly
     */
    'scanFamiliesConfig'?: ScanFamiliesConfig;
    /**
     * 
     * @type {ScannerInstanceCreationConfig}
     * @memberof AssetScanTemplateReadOnly
     */
    'scannerInstanceCreationConfig'?: ScannerInstanceCreationConfig;
}
/**
 * 
 * @export
 * @interface AssetScans
 */
export interface AssetScans {
    /**
     * Total asset scans count according to the given filters
     * @type {number}
     * @memberof AssetScans
     */
    'count'?: number;
    /**
     * List of asset scans according to the given filters and page. List length must be lower or equal to pageSize.
     * @type {Array<AssetScan>}
     * @memberof AssetScans
     */
    'items'?: Array<AssetScan>;
}
/**
 * 
 * @export
 * @interface AssetType
 */
export interface AssetType {
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'objectType': string;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'instanceID': string;
    /**
     * 
     * @type {CloudProvider}
     * @memberof AssetType
     */
    'instanceProvider'?: CloudProvider;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'location': string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof AssetType
     */
    'tags'?: Array<Tag> | null;
    /**
     * 
     * @type {Array<SecurityGroup>}
     * @memberof AssetType
     */
    'securityGroups'?: Array<SecurityGroup> | null;
    /**
     * 
     * @type {ContainerImageInfo}
     * @memberof AssetType
     */
    'image': ContainerImageInfo;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'instanceType': string;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'platform': string;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'launchTime': string;
    /**
     * 
     * @type {RootVolume}
     * @memberof AssetType
     */
    'rootVolume': RootVolume;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'podName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'dirName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'imageID': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AssetType
     */
    'repoTags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AssetType
     */
    'repoDigests'?: Array<string>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof AssetType
     */
    'labels'?: Array<Tag> | null;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'architecture'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'os'?: string;
    /**
     * 
     * @type {number}
     * @memberof AssetType
     */
    'size'?: number;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'containerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'containerID': string;
    /**
     * 
     * @type {string}
     * @memberof AssetType
     */
    'createdAt'?: string;
}


/**
 * 
 * @export
 * @interface Assets
 */
export interface Assets {
    /**
     * Total assets count according the given filters
     * @type {number}
     * @memberof Assets
     */
    'count'?: number;
    /**
     * List of assets in the given filters and page. List length must be lower or equal to pageSize.
     * @type {Array<Asset>}
     * @memberof Assets
     */
    'items'?: Array<Asset>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CloudProvider = {
    Aws: 'AWS',
    Azure: 'Azure',
    Gcp: 'GCP',
    Docker: 'Docker',
    External: 'External',
    Kubernetes: 'Kubernetes'
} as const;

export type CloudProvider = typeof CloudProvider[keyof typeof CloudProvider];


/**
 * 
 * @export
 * @interface ContainerImageInfo
 */
export interface ContainerImageInfo {
    /**
     * 
     * @type {string}
     * @memberof ContainerImageInfo
     */
    'objectType': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImageInfo
     */
    'imageID': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContainerImageInfo
     */
    'repoTags'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ContainerImageInfo
     */
    'repoDigests'?: Array<string>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof ContainerImageInfo
     */
    'labels'?: Array<Tag> | null;
    /**
     * 
     * @type {string}
     * @memberof ContainerImageInfo
     */
    'architecture'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImageInfo
     */
    'os'?: string;
    /**
     * 
     * @type {number}
     * @memberof ContainerImageInfo
     */
    'size'?: number;
}
/**
 * 
 * @export
 * @interface ContainerInfo
 */
export interface ContainerInfo {
    /**
     * 
     * @type {string}
     * @memberof ContainerInfo
     */
    'objectType': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerInfo
     */
    'containerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerInfo
     */
    'location'?: string;
    /**
     * 
     * @type {ContainerImageInfo}
     * @memberof ContainerInfo
     */
    'image'?: ContainerImageInfo;
    /**
     * 
     * @type {string}
     * @memberof ContainerInfo
     */
    'containerID': string;
    /**
     * 
     * @type {string}
     * @memberof ContainerInfo
     */
    'createdAt'?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof ContainerInfo
     */
    'labels'?: Array<Tag> | null;
}
/**
 * 
 * @export
 * @interface CostBreakdownComponent
 */
export interface CostBreakdownComponent {
    /**
     * 
     * @type {string}
     * @memberof CostBreakdownComponent
     */
    'operation': string;
    /**
     * 
     * @type {number}
     * @memberof CostBreakdownComponent
     */
    'cost': number;
}
/**
 * 
 * @export
 * @interface DirInfo
 */
export interface DirInfo {
    /**
     * 
     * @type {string}
     * @memberof DirInfo
     */
    'objectType': string;
    /**
     * 
     * @type {string}
     * @memberof DirInfo
     */
    'dirName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DirInfo
     */
    'location'?: string;
}
/**
 * 
 * @export
 * @interface Estimation
 */
export interface Estimation {
    /**
     * The estimated scan duration (seconds)
     * @type {number}
     * @memberof Estimation
     */
    'duration'?: number;
    /**
     * The estimated scan size (GB)
     * @type {number}
     * @memberof Estimation
     */
    'size'?: number;
    /**
     * The estimated scan cost ($)
     * @type {number}
     * @memberof Estimation
     */
    'cost'?: number;
    /**
     * 
     * @type {Array<CostBreakdownComponent>}
     * @memberof Estimation
     */
    'costBreakdown'?: Array<CostBreakdownComponent>;
}
/**
 * 
 * @export
 * @interface Exploit
 */
export interface Exploit {
    /**
     * 
     * @type {string}
     * @memberof Exploit
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exploit
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exploit
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exploit
     */
    'cveID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Exploit
     */
    'sourceDB'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Exploit
     */
    'urls'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface ExploitFindingInfo
 */
export interface ExploitFindingInfo {
    /**
     * 
     * @type {string}
     * @memberof ExploitFindingInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitFindingInfo
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitFindingInfo
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitFindingInfo
     */
    'cveID'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExploitFindingInfo
     */
    'sourceDB'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExploitFindingInfo
     */
    'urls'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ExploitFindingInfo
     */
    'objectType': string;
}
/**
 * 
 * @export
 * @interface ExploitScan
 */
export interface ExploitScan {
    /**
     * 
     * @type {ScannerStatus}
     * @memberof ExploitScan
     */
    'status'?: ScannerStatus;
    /**
     * 
     * @type {Array<Exploit>}
     * @memberof ExploitScan
     */
    'exploits'?: Array<Exploit> | null;
}
/**
 * 
 * @export
 * @interface ExploitsConfig
 */
export interface ExploitsConfig {
    /**
     * 
     * @type {boolean}
     * @memberof ExploitsConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExploitsConfig
     */
    'scanners'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Finding
 */
export interface Finding {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof Finding
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {string}
     * @memberof Finding
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Finding
     */
    'revision'?: number;
    /**
     * When this finding was first discovered by a scan
     * @type {string}
     * @memberof Finding
     */
    'firstSeen'?: string;
    /**
     * When this finding was last discovered by a scan
     * @type {string}
     * @memberof Finding
     */
    'lastSeen'?: string;
    /**
     * 
     * @type {AssetScanRelationship}
     * @memberof Finding
     */
    'lastSeenBy'?: AssetScanRelationship;
    /**
     * 
     * @type {FindingInfo}
     * @memberof Finding
     */
    'findingInfo'?: FindingInfo;
}
/**
 * 
 * @export
 * @interface FindingExists
 */
export interface FindingExists {
    /**
     * Describes which unique constraint combination causes the conflict.
     * @type {string}
     * @memberof FindingExists
     */
    'message'?: string;
    /**
     * 
     * @type {Finding}
     * @memberof FindingExists
     */
    'finding'?: Finding;
}
/**
 * 
 * @export
 * @interface FindingInfo
 */
export interface FindingInfo {
    /**
     * 
     * @type {string}
     * @memberof FindingInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingInfo
     */
    'version'?: string;
    /**
     * 
     * @type {InfoType}
     * @memberof FindingInfo
     */
    'type'?: InfoType;
    /**
     * 
     * @type {string}
     * @memberof FindingInfo
     */
    'language'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FindingInfo
     */
    'licenses'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof FindingInfo
     */
    'cpes'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof FindingInfo
     */
    'purl'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingInfo
     */
    'objectType': string;
    /**
     * 
     * @type {string}
     * @memberof FindingInfo
     */
    'vulnerabilityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingInfo
     */
    'description'?: string;
    /**
     * 
     * @type {MisconfigurationSeverity}
     * @memberof FindingInfo
     */
    'severity'?: MisconfigurationSeverity;
    /**
     * 
     * @type {Array<string>}
     * @memberof FindingInfo
     */
    'links'?: Array<string> | null;
    /**
     * 
     * @type {VulnerabilityDistro}
     * @memberof FindingInfo
     */
    'distro'?: VulnerabilityDistro;
    /**
     * 
     * @type {Array<VulnerabilityCvss>}
     * @memberof FindingInfo
     */
    'cvss'?: Array<VulnerabilityCvss> | null;
    /**
     * 
     * @type {Package}
     * @memberof FindingInfo
     */
    'package'?: Package;
    /**
     * 
     * @type {VulnerabilityFix}
     * @memberof FindingInfo
     */
    'fix'?: VulnerabilityFix;
    /**
     * 
     * @type {string}
     * @memberof FindingInfo
     */
    'layerId'?: string;
    /**
     * File path containing the info
     * @type {string}
     * @memberof FindingInfo
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingInfo
     */
    'malwareName'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingInfo
     */
    'malwareType'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingInfo
     */
    'ruleName'?: string;
    /**
     * Name of the file containing the secret
     * @type {string}
     * @memberof FindingInfo
     */
    'filePath'?: string;
    /**
     * 
     * @type {number}
     * @memberof FindingInfo
     */
    'startLine'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindingInfo
     */
    'endLine'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindingInfo
     */
    'startColumn'?: number;
    /**
     * 
     * @type {number}
     * @memberof FindingInfo
     */
    'endColumn'?: number;
    /**
     * Note: this is not unique
     * @type {string}
     * @memberof FindingInfo
     */
    'fingerprint'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingInfo
     */
    'scannerName'?: string;
    /**
     * Check or test ID, if applicable (e.g. Lynis TestID, CIS Docker Benchmark checkpoint code, etc)
     * @type {string}
     * @memberof FindingInfo
     */
    'id'?: string;
    /**
     * Location within the asset where the misconfiguration was recorded (e.g. filesystem path)
     * @type {string}
     * @memberof FindingInfo
     */
    'location'?: string;
    /**
     * Specifies misconfiguration impact category
     * @type {string}
     * @memberof FindingInfo
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingInfo
     */
    'message'?: string;
    /**
     * Possible fix for the misconfiguration
     * @type {string}
     * @memberof FindingInfo
     */
    'remediation'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingInfo
     */
    'rootkitName'?: string;
    /**
     * 
     * @type {RootkitType}
     * @memberof FindingInfo
     */
    'rootkitType'?: RootkitType;
    /**
     * 
     * @type {string}
     * @memberof FindingInfo
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingInfo
     */
    'cveID'?: string;
    /**
     * 
     * @type {string}
     * @memberof FindingInfo
     */
    'sourceDB'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FindingInfo
     */
    'urls'?: Array<string> | null;
    /**
     * The data found by the scanner in the specific path for a specific type. See example for SSHKnownHostFingerprint info type
     * @type {string}
     * @memberof FindingInfo
     */
    'data'?: string;
}


/**
 * 
 * @export
 * @interface FindingRelationship
 */
export interface FindingRelationship {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof FindingRelationship
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {string}
     * @memberof FindingRelationship
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof FindingRelationship
     */
    'revision'?: number;
    /**
     * When this finding was first discovered by a scan
     * @type {string}
     * @memberof FindingRelationship
     */
    'firstSeen'?: string;
    /**
     * When this finding was last discovered by a scan
     * @type {string}
     * @memberof FindingRelationship
     */
    'lastSeen'?: string;
    /**
     * 
     * @type {AssetScanRelationship}
     * @memberof FindingRelationship
     */
    'lastSeenBy'?: AssetScanRelationship;
    /**
     * 
     * @type {FindingInfo}
     * @memberof FindingRelationship
     */
    'findingInfo'?: FindingInfo;
}
/**
 * 
 * @export
 * @interface Findings
 */
export interface Findings {
    /**
     * Total findings count according to the given filters
     * @type {number}
     * @memberof Findings
     */
    'count'?: number;
    /**
     * List of findings according to the given filters
     * @type {Array<Finding>}
     * @memberof Findings
     */
    'items'?: Array<Finding>;
}
/**
 * 
 * @export
 * @interface InfoFinderConfig
 */
export interface InfoFinderConfig {
    /**
     * 
     * @type {boolean}
     * @memberof InfoFinderConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof InfoFinderConfig
     */
    'scanners'?: Array<string>;
}
/**
 * 
 * @export
 * @interface InfoFinderFindingInfo
 */
export interface InfoFinderFindingInfo {
    /**
     * 
     * @type {string}
     * @memberof InfoFinderFindingInfo
     */
    'scannerName'?: string;
    /**
     * 
     * @type {InfoType}
     * @memberof InfoFinderFindingInfo
     */
    'type'?: InfoType;
    /**
     * File path containing the info
     * @type {string}
     * @memberof InfoFinderFindingInfo
     */
    'path'?: string;
    /**
     * The data found by the scanner in the specific path for a specific type. See example for SSHKnownHostFingerprint info type
     * @type {string}
     * @memberof InfoFinderFindingInfo
     */
    'data'?: string;
    /**
     * 
     * @type {string}
     * @memberof InfoFinderFindingInfo
     */
    'objectType': string;
}


/**
 * 
 * @export
 * @interface InfoFinderInfo
 */
export interface InfoFinderInfo {
    /**
     * 
     * @type {string}
     * @memberof InfoFinderInfo
     */
    'scannerName'?: string;
    /**
     * 
     * @type {InfoType}
     * @memberof InfoFinderInfo
     */
    'type'?: InfoType;
    /**
     * File path containing the info
     * @type {string}
     * @memberof InfoFinderInfo
     */
    'path'?: string;
    /**
     * The data found by the scanner in the specific path for a specific type. See example for SSHKnownHostFingerprint info type
     * @type {string}
     * @memberof InfoFinderInfo
     */
    'data'?: string;
}


/**
 * 
 * @export
 * @interface InfoFinderScan
 */
export interface InfoFinderScan {
    /**
     * 
     * @type {ScannerStatus}
     * @memberof InfoFinderScan
     */
    'status'?: ScannerStatus;
    /**
     * 
     * @type {Array<string>}
     * @memberof InfoFinderScan
     */
    'scanners'?: Array<string> | null;
    /**
     * 
     * @type {Array<InfoFinderInfo>}
     * @memberof InfoFinderScan
     */
    'infos'?: Array<InfoFinderInfo> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const InfoType = {
    SshKnownHostFingerprint: 'SSHKnownHostFingerprint',
    SshAuthorizedKeyFingerprint: 'SSHAuthorizedKeyFingerprint',
    SshPrivateKeyFingerprint: 'SSHPrivateKeyFingerprint',
    SshDaemonKeyFingerprint: 'SSHDaemonKeyFingerprint',
    Unknown: 'UNKNOWN'
} as const;

export type InfoType = typeof InfoType[keyof typeof InfoType];


/**
 * 
 * @export
 * @interface Malware
 */
export interface Malware {
    /**
     * 
     * @type {string}
     * @memberof Malware
     */
    'malwareName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Malware
     */
    'malwareType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Malware
     */
    'ruleName'?: string;
    /**
     * Path of the file that contains malware
     * @type {string}
     * @memberof Malware
     */
    'path'?: string;
}
/**
 * 
 * @export
 * @interface MalwareConfig
 */
export interface MalwareConfig {
    /**
     * 
     * @type {boolean}
     * @memberof MalwareConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof MalwareConfig
     */
    'scanners'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof MalwareConfig
     */
    'yara_directories_to_scan'?: Array<string>;
}
/**
 * 
 * @export
 * @interface MalwareFindingInfo
 */
export interface MalwareFindingInfo {
    /**
     * 
     * @type {string}
     * @memberof MalwareFindingInfo
     */
    'malwareName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MalwareFindingInfo
     */
    'malwareType'?: string;
    /**
     * 
     * @type {string}
     * @memberof MalwareFindingInfo
     */
    'ruleName'?: string;
    /**
     * Path of the file that contains malware
     * @type {string}
     * @memberof MalwareFindingInfo
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof MalwareFindingInfo
     */
    'objectType': string;
}
/**
 * 
 * @export
 * @interface MalwareScan
 */
export interface MalwareScan {
    /**
     * 
     * @type {ScannerStatus}
     * @memberof MalwareScan
     */
    'status'?: ScannerStatus;
    /**
     * 
     * @type {Array<Malware>}
     * @memberof MalwareScan
     */
    'malware'?: Array<Malware> | null;
    /**
     * 
     * @type {Array<ScannerMetadata>}
     * @memberof MalwareScan
     */
    'metadata'?: Array<ScannerMetadata> | null;
}
/**
 * 
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof Metadata
     */
    'annotations'?: Array<AnnotationsInner>;
}
/**
 * 
 * @export
 * @interface MetadataReadOnly
 */
export interface MetadataReadOnly {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof MetadataReadOnly
     */
    'annotations'?: Array<AnnotationsInner>;
}
/**
 * 
 * @export
 * @interface Misconfiguration
 */
export interface Misconfiguration {
    /**
     * 
     * @type {string}
     * @memberof Misconfiguration
     */
    'scannerName'?: string;
    /**
     * Check or test ID, if applicable (e.g. Lynis TestID, CIS Docker Benchmark checkpoint code, etc)
     * @type {string}
     * @memberof Misconfiguration
     */
    'id'?: string;
    /**
     * Location within the asset where the misconfiguration was recorded (e.g. filesystem path)
     * @type {string}
     * @memberof Misconfiguration
     */
    'location'?: string;
    /**
     * Specifies misconfiguration impact category
     * @type {string}
     * @memberof Misconfiguration
     */
    'category'?: string;
    /**
     * Short info about the misconfiguration
     * @type {string}
     * @memberof Misconfiguration
     */
    'message'?: string;
    /**
     * Additional context such as the potential impact
     * @type {string}
     * @memberof Misconfiguration
     */
    'description'?: string;
    /**
     * Possible fix for the misconfiguration
     * @type {string}
     * @memberof Misconfiguration
     */
    'remediation'?: string;
    /**
     * 
     * @type {MisconfigurationSeverity}
     * @memberof Misconfiguration
     */
    'severity'?: MisconfigurationSeverity;
}


/**
 * 
 * @export
 * @interface MisconfigurationFindingInfo
 */
export interface MisconfigurationFindingInfo {
    /**
     * 
     * @type {string}
     * @memberof MisconfigurationFindingInfo
     */
    'scannerName'?: string;
    /**
     * Check or test ID, if applicable (e.g. Lynis TestID, CIS Docker Benchmark checkpoint code, etc)
     * @type {string}
     * @memberof MisconfigurationFindingInfo
     */
    'id'?: string;
    /**
     * Location within the asset where the misconfiguration was recorded (e.g. filesystem path)
     * @type {string}
     * @memberof MisconfigurationFindingInfo
     */
    'location'?: string;
    /**
     * Specifies misconfiguration impact category
     * @type {string}
     * @memberof MisconfigurationFindingInfo
     */
    'category'?: string;
    /**
     * Short info about the misconfiguration
     * @type {string}
     * @memberof MisconfigurationFindingInfo
     */
    'message'?: string;
    /**
     * Additional context such as the potential impact
     * @type {string}
     * @memberof MisconfigurationFindingInfo
     */
    'description'?: string;
    /**
     * Possible fix for the misconfiguration
     * @type {string}
     * @memberof MisconfigurationFindingInfo
     */
    'remediation'?: string;
    /**
     * 
     * @type {MisconfigurationSeverity}
     * @memberof MisconfigurationFindingInfo
     */
    'severity'?: MisconfigurationSeverity;
    /**
     * 
     * @type {string}
     * @memberof MisconfigurationFindingInfo
     */
    'objectType': string;
}


/**
 * 
 * @export
 * @interface MisconfigurationScan
 */
export interface MisconfigurationScan {
    /**
     * 
     * @type {ScannerStatus}
     * @memberof MisconfigurationScan
     */
    'status'?: ScannerStatus;
    /**
     * 
     * @type {Array<string>}
     * @memberof MisconfigurationScan
     */
    'scanners'?: Array<string> | null;
    /**
     * 
     * @type {Array<Misconfiguration>}
     * @memberof MisconfigurationScan
     */
    'misconfigurations'?: Array<Misconfiguration> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MisconfigurationSeverity = {
    MisconfigurationHighSeverity: 'MisconfigurationHighSeverity',
    MisconfigurationMediumSeverity: 'MisconfigurationMediumSeverity',
    MisconfigurationLowSeverity: 'MisconfigurationLowSeverity',
    MisconfigurationInfoSeverity: 'MisconfigurationInfoSeverity'
} as const;

export type MisconfigurationSeverity = typeof MisconfigurationSeverity[keyof typeof MisconfigurationSeverity];


/**
 * 
 * @export
 * @interface MisconfigurationsConfig
 */
export interface MisconfigurationsConfig {
    /**
     * 
     * @type {boolean}
     * @memberof MisconfigurationsConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof MisconfigurationsConfig
     */
    'scanners'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Package
 */
export interface Package {
    /**
     * 
     * @type {string}
     * @memberof Package
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Package
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof Package
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Package
     */
    'language'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Package
     */
    'licenses'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof Package
     */
    'cpes'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof Package
     */
    'purl'?: string;
}
/**
 * 
 * @export
 * @interface PackageFindingInfo
 */
export interface PackageFindingInfo {
    /**
     * 
     * @type {string}
     * @memberof PackageFindingInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PackageFindingInfo
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof PackageFindingInfo
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof PackageFindingInfo
     */
    'language'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PackageFindingInfo
     */
    'licenses'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PackageFindingInfo
     */
    'cpes'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof PackageFindingInfo
     */
    'purl'?: string;
    /**
     * 
     * @type {string}
     * @memberof PackageFindingInfo
     */
    'objectType': string;
}
/**
 * 
 * @export
 * @interface PluginScan
 */
export interface PluginScan {
    /**
     * 
     * @type {ScannerStatus}
     * @memberof PluginScan
     */
    'status'?: ScannerStatus;
    /**
     * 
     * @type {Array<FindingInfo>}
     * @memberof PluginScan
     */
    'findingInfos'?: Array<FindingInfo> | null;
}
/**
 * 
 * @export
 * @interface PluginScannerConfig
 */
export interface PluginScannerConfig {
    /**
     * 
     * @type {string}
     * @memberof PluginScannerConfig
     */
    'image_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PluginScannerConfig
     */
    'config'?: string;
}
/**
 * 
 * @export
 * @interface PluginsConfig
 */
export interface PluginsConfig {
    /**
     * 
     * @type {boolean}
     * @memberof PluginsConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof PluginsConfig
     */
    'scanners_list'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: PluginScannerConfig; }}
     * @memberof PluginsConfig
     */
    'scanners_config'?: { [key: string]: PluginScannerConfig; };
}
/**
 * 
 * @export
 * @interface PodInfo
 */
export interface PodInfo {
    /**
     * 
     * @type {string}
     * @memberof PodInfo
     */
    'objectType': string;
    /**
     * 
     * @type {string}
     * @memberof PodInfo
     */
    'podName'?: string;
    /**
     * 
     * @type {string}
     * @memberof PodInfo
     */
    'location'?: string;
}
/**
 * Describes a provider object.
 * @export
 * @interface Provider
 */
export interface Provider {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof Provider
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {string}
     * @memberof Provider
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Provider
     */
    'revision'?: number;
    /**
     * Human-readable name for the provider.
     * @type {string}
     * @memberof Provider
     */
    'displayName'?: string;
    /**
     * Timestamp of the last heartbeat from the provider.
     * @type {string}
     * @memberof Provider
     */
    'lastHeartbeatTime'?: string;
    /**
     * 
     * @type {ProviderStatus}
     * @memberof Provider
     */
    'status'?: ProviderStatus;
    /**
     * Version of the provider runtime that the provider was compiled with.
     * @type {string}
     * @memberof Provider
     */
    'providerRuntimeVersion'?: string;
}
/**
 * 
 * @export
 * @interface ProviderExists
 */
export interface ProviderExists {
    /**
     * Describes which unique constraint combination causes the conflict.
     * @type {string}
     * @memberof ProviderExists
     */
    'message'?: string;
    /**
     * 
     * @type {Provider}
     * @memberof ProviderExists
     */
    'provider'?: Provider;
}
/**
 * Describes a relationship to a provider which can be expanded.
 * @export
 * @interface ProviderRelationship
 */
export interface ProviderRelationship {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof ProviderRelationship
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {string}
     * @memberof ProviderRelationship
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProviderRelationship
     */
    'revision'?: number;
    /**
     * Human-readable name for the provider.
     * @type {string}
     * @memberof ProviderRelationship
     */
    'displayName'?: string;
    /**
     * Timestamp of the last heartbeat from the provider.
     * @type {string}
     * @memberof ProviderRelationship
     */
    'lastHeartbeatTime'?: string;
    /**
     * 
     * @type {ProviderStatus}
     * @memberof ProviderRelationship
     */
    'status'?: ProviderStatus;
    /**
     * Version of the provider runtime that the provider was compiled with.
     * @type {string}
     * @memberof ProviderRelationship
     */
    'providerRuntimeVersion'?: string;
}
/**
 * 
 * @export
 * @interface ProviderStatus
 */
export interface ProviderStatus {
    /**
     * Describes the health state of the provider.  | State     | Description                                    | | --------- | ---------------------------------------------- | | Healthy   | Provider is healthy.                           | | Unhealthy | Heartbeat received, but Provider is unhealthy. | | Unknown   | No heartbeat received from Provider.           | 
     * @type {string}
     * @memberof ProviderStatus
     */
    'state': ProviderStatusStateEnum;
    /**
     * Machine-readable, UpperCamelCase text indicating the reason for the condition\'s last transition.
     * @type {string}
     * @memberof ProviderStatus
     */
    'reason': ProviderStatusReasonEnum;
    /**
     * Human-readable message indicating details about the last state transition.
     * @type {string}
     * @memberof ProviderStatus
     */
    'message'?: string;
    /**
     * Last date-time when the status has changed.
     * @type {string}
     * @memberof ProviderStatus
     */
    'lastTransitionTime': string;
}

export const ProviderStatusStateEnum = {
    Healthy: 'Healthy',
    Unhealthy: 'Unhealthy',
    Unknown: 'Unknown'
} as const;

export type ProviderStatusStateEnum = typeof ProviderStatusStateEnum[keyof typeof ProviderStatusStateEnum];
export const ProviderStatusReasonEnum = {
    HeartbeatReceived: 'HeartbeatReceived',
    NoHeartbeatReceived: 'NoHeartbeatReceived'
} as const;

export type ProviderStatusReasonEnum = typeof ProviderStatusReasonEnum[keyof typeof ProviderStatusReasonEnum];

/**
 * 
 * @export
 * @interface Providers
 */
export interface Providers {
    /**
     * Total providers count according the given filters
     * @type {number}
     * @memberof Providers
     */
    'count'?: number;
    /**
     * List of providers in the given filters and page. List length must be lower or equal to pageSize.
     * @type {Array<Provider>}
     * @memberof Providers
     */
    'items'?: Array<Provider>;
}
/**
 * 
 * @export
 * @interface ResourceCleanupStatus
 */
export interface ResourceCleanupStatus {
    /**
     * Describes the state of resource cleanup.  | State   | Description                                                | | ------- | ---------------------------------------------------------- | | Pending | Initial state for cleaning up resources                    | | Skipped | Resource cleanup has been skipped due to Delete Job Policy | | Failed  | Cleaning up resources has been failed                      | | Done    | Resources have been successfully cleaned up                | 
     * @type {string}
     * @memberof ResourceCleanupStatus
     */
    'state': ResourceCleanupStatusStateEnum;
    /**
     * Machine readable reason for state transition.  | State   | Reason          | Description                                                            | | ------- | --------------- | ---------------------------------------------------------------------- | | Pending | AssetScanCreate | AssetScan created                                                      | | Skipped | NotApplicable   | Resource cleanup is not required as it is managed outside of VMClarity | | Skipped | DeletePolicy    | Resource cleanup has been skipped due to Delete Job Policy             | | Failed  | ProviderError   | Failed due to Provider error                                           | | Failed  | InternalError   | Failed due to internal error                                           | | Done    | Success         | Successfully completed                                                 | 
     * @type {string}
     * @memberof ResourceCleanupStatus
     */
    'reason': ResourceCleanupStatusReasonEnum;
    /**
     * Human readable message.
     * @type {string}
     * @memberof ResourceCleanupStatus
     */
    'message'?: string;
    /**
     * Last date time when the status has changed.
     * @type {string}
     * @memberof ResourceCleanupStatus
     */
    'lastTransitionTime': string;
}

export const ResourceCleanupStatusStateEnum = {
    Pending: 'Pending',
    Skipped: 'Skipped',
    Failed: 'Failed',
    Done: 'Done'
} as const;

export type ResourceCleanupStatusStateEnum = typeof ResourceCleanupStatusStateEnum[keyof typeof ResourceCleanupStatusStateEnum];
export const ResourceCleanupStatusReasonEnum = {
    AssetScanCreated: 'AssetScanCreated',
    NotApplicable: 'NotApplicable',
    DeletePolicy: 'DeletePolicy',
    ProviderError: 'ProviderError',
    InternalError: 'InternalError',
    Success: 'Success'
} as const;

export type ResourceCleanupStatusReasonEnum = typeof ResourceCleanupStatusReasonEnum[keyof typeof ResourceCleanupStatusReasonEnum];

/**
 * Information about VM root volume
 * @export
 * @interface RootVolume
 */
export interface RootVolume {
    /**
     * 
     * @type {number}
     * @memberof RootVolume
     */
    'sizeGB': number;
    /**
     * 
     * @type {string}
     * @memberof RootVolume
     */
    'encrypted': RootVolumeEncryptedEnum;
}

export const RootVolumeEncryptedEnum = {
    True: 'true',
    False: 'false',
    Unknown: 'Unknown'
} as const;

export type RootVolumeEncryptedEnum = typeof RootVolumeEncryptedEnum[keyof typeof RootVolumeEncryptedEnum];

/**
 * 
 * @export
 * @interface Rootkit
 */
export interface Rootkit {
    /**
     * 
     * @type {string}
     * @memberof Rootkit
     */
    'rootkitName'?: string;
    /**
     * 
     * @type {RootkitType}
     * @memberof Rootkit
     */
    'rootkitType'?: RootkitType;
    /**
     * 
     * @type {string}
     * @memberof Rootkit
     */
    'message'?: string;
}


/**
 * 
 * @export
 * @interface RootkitFindingInfo
 */
export interface RootkitFindingInfo {
    /**
     * 
     * @type {string}
     * @memberof RootkitFindingInfo
     */
    'rootkitName'?: string;
    /**
     * 
     * @type {RootkitType}
     * @memberof RootkitFindingInfo
     */
    'rootkitType'?: RootkitType;
    /**
     * 
     * @type {string}
     * @memberof RootkitFindingInfo
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof RootkitFindingInfo
     */
    'objectType': string;
}


/**
 * 
 * @export
 * @interface RootkitScan
 */
export interface RootkitScan {
    /**
     * 
     * @type {ScannerStatus}
     * @memberof RootkitScan
     */
    'status'?: ScannerStatus;
    /**
     * 
     * @type {Array<Rootkit>}
     * @memberof RootkitScan
     */
    'rootkits'?: Array<Rootkit> | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RootkitType = {
    Memory: 'MEMORY',
    Kernel: 'KERNEL',
    Application: 'APPLICATION',
    Firmware: 'FIRMWARE',
    Unknown: 'UNKNOWN'
} as const;

export type RootkitType = typeof RootkitType[keyof typeof RootkitType];


/**
 * 
 * @export
 * @interface RootkitsConfig
 */
export interface RootkitsConfig {
    /**
     * 
     * @type {boolean}
     * @memberof RootkitsConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof RootkitsConfig
     */
    'scanners'?: Array<string>;
}
/**
 * Runtime schedule scan configuration. If only operationTime is set, it will be a single scan scheduled for the operationTime. If only cronLine is set, the current time will be the \"from time\" to start the scheduling according to the cronLine. If both operationTime and cronLine are set, the first scan will run at operationTime and the operationTime will be the first time that the cronLine will be effective from.
 * @export
 * @interface RuntimeScheduleScanConfig
 */
export interface RuntimeScheduleScanConfig {
    /**
     * Cron schedule expressions.
     * @type {string}
     * @memberof RuntimeScheduleScanConfig
     */
    'cronLine'?: string;
    /**
     * The next time this ScanConfig should trigger a scan.
     * @type {string}
     * @memberof RuntimeScheduleScanConfig
     */
    'operationTime'?: string;
}
/**
 * 
 * @export
 * @interface SBOMConfig
 */
export interface SBOMConfig {
    /**
     * 
     * @type {boolean}
     * @memberof SBOMConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof SBOMConfig
     */
    'analyzers'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SbomScan
 */
export interface SbomScan {
    /**
     * 
     * @type {ScannerStatus}
     * @memberof SbomScan
     */
    'status'?: ScannerStatus;
    /**
     * 
     * @type {Array<Package>}
     * @memberof SbomScan
     */
    'packages'?: Array<Package> | null;
}
/**
 * Describes a multi-asset scheduled scan.
 * @export
 * @interface Scan
 */
export interface Scan {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof Scan
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * The query used to limit the scope of this scan. It uses the ODATA $filter query language to limit the collection of assets that this scan will operate over. For example `startswith(assetInfo.location, \'eu-west-2\')` will limit this scan to just assets in the eu-west-2 AWS region. 
     * @type {string}
     * @memberof Scan
     */
    'scope'?: string;
    /**
     * The maximum time in seconds that a scan started from this config should run for before being automatically aborted. 
     * @type {number}
     * @memberof Scan
     */
    'timeoutSeconds'?: number;
    /**
     * The maximum number of asset scans that can be scheduled in parallel for this scan
     * @type {number}
     * @memberof Scan
     */
    'maxParallelScanners'?: number;
    /**
     * 
     * @type {AssetScanTemplate}
     * @memberof Scan
     */
    'assetScanTemplate'?: AssetScanTemplate;
    /**
     * 
     * @type {string}
     * @memberof Scan
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Scan
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Scan
     */
    'revision'?: number;
    /**
     * 
     * @type {string}
     * @memberof Scan
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Scan
     */
    'endTime'?: string;
    /**
     * 
     * @type {ScanConfigRelationship}
     * @memberof Scan
     */
    'scanConfig'?: ScanConfigRelationship;
    /**
     * List of asset IDs to be scanned
     * @type {Array<string>}
     * @memberof Scan
     */
    'assetIDs'?: Array<string> | null;
    /**
     * 
     * @type {ScanStatus}
     * @memberof Scan
     */
    'status'?: ScanStatus;
    /**
     * 
     * @type {ScanSummary}
     * @memberof Scan
     */
    'summary'?: ScanSummary;
}
/**
 * Describes a multi-asset scheduled scan config.
 * @export
 * @interface ScanConfig
 */
export interface ScanConfig {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof ScanConfig
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {string}
     * @memberof ScanConfig
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScanConfig
     */
    'revision'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScanConfig
     */
    'name'?: string;
    /**
     * 
     * @type {ScanTemplate}
     * @memberof ScanConfig
     */
    'scanTemplate'?: ScanTemplate;
    /**
     * 
     * @type {RuntimeScheduleScanConfig}
     * @memberof ScanConfig
     */
    'scheduled'?: RuntimeScheduleScanConfig;
    /**
     * if true, the scan config is disabled and no scan should run from it
     * @type {boolean}
     * @memberof ScanConfig
     */
    'disabled'?: boolean;
}
/**
 * 
 * @export
 * @interface ScanConfigExists
 */
export interface ScanConfigExists {
    /**
     * Describes which unique constraint combination causes the conflict.
     * @type {string}
     * @memberof ScanConfigExists
     */
    'message'?: string;
    /**
     * 
     * @type {ScanConfig}
     * @memberof ScanConfigExists
     */
    'scanConfig'?: ScanConfig;
}
/**
 * Describes a relationship to a scan config which can be expanded.
 * @export
 * @interface ScanConfigRelationship
 */
export interface ScanConfigRelationship {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof ScanConfigRelationship
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {string}
     * @memberof ScanConfigRelationship
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof ScanConfigRelationship
     */
    'revision'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScanConfigRelationship
     */
    'name'?: string;
    /**
     * 
     * @type {ScanTemplate}
     * @memberof ScanConfigRelationship
     */
    'scanTemplate'?: ScanTemplate;
    /**
     * 
     * @type {RuntimeScheduleScanConfig}
     * @memberof ScanConfigRelationship
     */
    'scheduled'?: RuntimeScheduleScanConfig;
    /**
     * if true, the scan config is disabled and no scan should run from it
     * @type {boolean}
     * @memberof ScanConfigRelationship
     */
    'disabled'?: boolean;
}
/**
 * 
 * @export
 * @interface ScanConfigs
 */
export interface ScanConfigs {
    /**
     * Total scan config count according to the given filters
     * @type {number}
     * @memberof ScanConfigs
     */
    'count'?: number;
    /**
     * List of scan configs according to the given filters and page. List length must be lower or equal to pageSize.
     * @type {Array<ScanConfig>}
     * @memberof ScanConfigs
     */
    'items'?: Array<ScanConfig>;
}
/**
 * 
 * @export
 * @interface ScanEstimation
 */
export interface ScanEstimation {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof ScanEstimation
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * 
     * @type {string}
     * @memberof ScanEstimation
     */
    'id'?: string;
    /**
     * List of asset IDs to be estimated
     * @type {Array<string>}
     * @memberof ScanEstimation
     */
    'assetIDs'?: Array<string>;
    /**
     * 
     * @type {ScanEstimationStatus}
     * @memberof ScanEstimation
     */
    'status'?: ScanEstimationStatus;
    /**
     * 
     * @type {string}
     * @memberof ScanEstimation
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScanEstimation
     */
    'endTime'?: string;
    /**
     * AssetScanEstimations which make up this ScanEstimation
     * @type {Array<AssetScanEstimationRelationship>}
     * @memberof ScanEstimation
     */
    'assetScanEstimations'?: Array<AssetScanEstimationRelationship>;
    /**
     * 
     * @type {ScanTemplate}
     * @memberof ScanEstimation
     */
    'scanTemplate'?: ScanTemplate;
    /**
     * 
     * @type {ScanEstimationSummary}
     * @memberof ScanEstimation
     */
    'summary'?: ScanEstimationSummary;
    /**
     * 
     * @type {number}
     * @memberof ScanEstimation
     */
    'revision'?: number;
    /**
     * The duration in seconds this resource should last until it is deleted.
     * @type {number}
     * @memberof ScanEstimation
     */
    'ttlSecondsAfterFinished'?: number;
    /**
     * The time this resource should be deleted. This value is calculated by endTime + ttlSecondsAfterFinished. This should not be set by the user, but use ttlSecondsAfterFinished instead.
     * @type {string}
     * @memberof ScanEstimation
     */
    'deleteAfter'?: string;
}
/**
 * 
 * @export
 * @interface ScanEstimationRelationship
 */
export interface ScanEstimationRelationship {
    /**
     * 
     * @type {string}
     * @memberof ScanEstimationRelationship
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface ScanEstimationStatus
 */
export interface ScanEstimationStatus {
    /**
     * Describes the state of scan estimation.  | State      | Description                              | | ---------- | ---------------------------------------- | | Pending    | Initial state for ScanEstimation         | | Discovered | Assets have been discovered              | | InProgress | Scan estimation is in progress           | | Aborted    | ScanEstimation has aborted               | | Failed     | ScanEstimation has failed                | | Done       | ScanEstimation has finished successfully | 
     * @type {string}
     * @memberof ScanEstimationStatus
     */
    'state': ScanEstimationStatusStateEnum;
    /**
     * Machine readable reason for state transition.  | State      | Reason              | Description                                                       | | ---------- | ------------------- | ----------------------------------------------------------------- | | Pending    | Created             | Initial state for ScanEstimation                                  | | Discovered | SuccessfulDiscovery | Assets to estimate successfully discovered                        | | InProgress | Running             | Scan estimation is currently in progress                          | | Aborted    | Cancellation        | ScanEstimation has been cancelled                                 | | Failed     | Aborted             | ScanEstimation has failed due to abort                            | | Failed     | Error               | ScanEstimation has failed due to an error                         | | Failed     | Timeout             | ScanEstimation has failed due to timeout                          | | Done       | NothingToEstimate   | ScanEstimation has finished because there was nothing to estimate | | Done       | Success             | ScanEstimation has finished successfully                          | 
     * @type {string}
     * @memberof ScanEstimationStatus
     */
    'reason': ScanEstimationStatusReasonEnum;
    /**
     * Human readable message.
     * @type {string}
     * @memberof ScanEstimationStatus
     */
    'message'?: string;
    /**
     * Last date time when the status has changed.
     * @type {string}
     * @memberof ScanEstimationStatus
     */
    'lastTransitionTime': string;
}

export const ScanEstimationStatusStateEnum = {
    Pending: 'Pending',
    Discovered: 'Discovered',
    InProgress: 'InProgress',
    Aborted: 'Aborted',
    Failed: 'Failed',
    Done: 'Done'
} as const;

export type ScanEstimationStatusStateEnum = typeof ScanEstimationStatusStateEnum[keyof typeof ScanEstimationStatusStateEnum];
export const ScanEstimationStatusReasonEnum = {
    ScanEstimationStatusReasonCreated: 'Created',
    ScanEstimationStatusReasonSuccessfulDiscovery: 'SuccessfulDiscovery',
    ScanEstimationStatusReasonRunning: 'EstimationsRunning',
    ScanEstimationStatusReasonCancellation: 'Cancellation',
    ScanEstimationStatusReasonAborted: 'Aborted',
    ScanEstimationStatusReasonError: 'Error',
    ScanEstimationStatusReasonTimeout: 'TimeOut',
    ScanEstimationStatusReasonNothingToEstimate: 'NothingToEstimate',
    ScanEstimationStatusReasonSuccess: 'Success'
} as const;

export type ScanEstimationStatusReasonEnum = typeof ScanEstimationStatusReasonEnum[keyof typeof ScanEstimationStatusReasonEnum];

/**
 * A summary of the AssetScanEstimations under this ScanEstimation
 * @export
 * @interface ScanEstimationSummary
 */
export interface ScanEstimationSummary {
    /**
     * 
     * @type {number}
     * @memberof ScanEstimationSummary
     */
    'jobsLeftToRun'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanEstimationSummary
     */
    'jobsCompleted'?: number;
    /**
     * Total estimated time the scan will take (seconds)
     * @type {number}
     * @memberof ScanEstimationSummary
     */
    'totalScanTime'?: number;
    /**
     * Total estimated size of the scan (GB)
     * @type {number}
     * @memberof ScanEstimationSummary
     */
    'totalScanSize'?: number;
    /**
     * Total estimated cost of the scan ($)
     * @type {number}
     * @memberof ScanEstimationSummary
     */
    'totalScanCost'?: number;
}
/**
 * 
 * @export
 * @interface ScanEstimations
 */
export interface ScanEstimations {
    /**
     * Total ScanEstimations count according to the given filters
     * @type {number}
     * @memberof ScanEstimations
     */
    'count'?: number;
    /**
     * List of ScanEstimations according to the given filters
     * @type {Array<ScanEstimation>}
     * @memberof ScanEstimations
     */
    'items'?: Array<ScanEstimation>;
}
/**
 * 
 * @export
 * @interface ScanExists
 */
export interface ScanExists {
    /**
     * Describes which unique constraint combination causes the conflict.
     * @type {string}
     * @memberof ScanExists
     */
    'message'?: string;
    /**
     * 
     * @type {Scan}
     * @memberof ScanExists
     */
    'scan'?: Scan;
}
/**
 * The configuration of the scanner families within a scan config
 * @export
 * @interface ScanFamiliesConfig
 */
export interface ScanFamiliesConfig {
    /**
     * 
     * @type {SBOMConfig}
     * @memberof ScanFamiliesConfig
     */
    'sbom'?: SBOMConfig;
    /**
     * 
     * @type {VulnerabilitiesConfig}
     * @memberof ScanFamiliesConfig
     */
    'vulnerabilities'?: VulnerabilitiesConfig;
    /**
     * 
     * @type {MalwareConfig}
     * @memberof ScanFamiliesConfig
     */
    'malware'?: MalwareConfig;
    /**
     * 
     * @type {RootkitsConfig}
     * @memberof ScanFamiliesConfig
     */
    'rootkits'?: RootkitsConfig;
    /**
     * 
     * @type {SecretsConfig}
     * @memberof ScanFamiliesConfig
     */
    'secrets'?: SecretsConfig;
    /**
     * 
     * @type {MisconfigurationsConfig}
     * @memberof ScanFamiliesConfig
     */
    'misconfigurations'?: MisconfigurationsConfig;
    /**
     * 
     * @type {ExploitsConfig}
     * @memberof ScanFamiliesConfig
     */
    'exploits'?: ExploitsConfig;
    /**
     * 
     * @type {InfoFinderConfig}
     * @memberof ScanFamiliesConfig
     */
    'infoFinder'?: InfoFinderConfig;
    /**
     * 
     * @type {PluginsConfig}
     * @memberof ScanFamiliesConfig
     */
    'plugins'?: PluginsConfig;
}
/**
 * A summary of the scan findings.
 * @export
 * @interface ScanFindingsSummary
 */
export interface ScanFindingsSummary {
    /**
     * 
     * @type {number}
     * @memberof ScanFindingsSummary
     */
    'totalPackages'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanFindingsSummary
     */
    'totalExploits'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanFindingsSummary
     */
    'totalMalware'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanFindingsSummary
     */
    'totalMisconfigurations'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanFindingsSummary
     */
    'totalRootkits'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanFindingsSummary
     */
    'totalSecrets'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanFindingsSummary
     */
    'totalInfoFinder'?: number;
    /**
     * 
     * @type {VulnerabilityScanSummary}
     * @memberof ScanFindingsSummary
     */
    'totalVulnerabilities'?: VulnerabilityScanSummary;
    /**
     * 
     * @type {number}
     * @memberof ScanFindingsSummary
     */
    'totalPlugins'?: number;
}
/**
 * Describes an expandable relationship to Scan object
 * @export
 * @interface ScanRelationship
 */
export interface ScanRelationship {
    /**
     * Generic map of string keys and string values to attach arbitrary non-identifying metadata to objects.
     * @type {Array<AnnotationsInner>}
     * @memberof ScanRelationship
     */
    'annotations'?: Array<AnnotationsInner>;
    /**
     * The query used to limit the scope of this scan. It uses the ODATA $filter query language to limit the collection of assets that this scan will operate over. For example `startswith(assetInfo.location, \'eu-west-2\')` will limit this scan to just assets in the eu-west-2 AWS region. 
     * @type {string}
     * @memberof ScanRelationship
     */
    'scope'?: string;
    /**
     * The maximum time in seconds that a scan started from this config should run for before being automatically aborted. 
     * @type {number}
     * @memberof ScanRelationship
     */
    'timeoutSeconds'?: number;
    /**
     * The maximum number of asset scans that can be scheduled in parallel for this scan
     * @type {number}
     * @memberof ScanRelationship
     */
    'maxParallelScanners'?: number;
    /**
     * 
     * @type {AssetScanTemplate}
     * @memberof ScanRelationship
     */
    'assetScanTemplate'?: AssetScanTemplate;
    /**
     * 
     * @type {string}
     * @memberof ScanRelationship
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ScanRelationship
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScanRelationship
     */
    'revision'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScanRelationship
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScanRelationship
     */
    'endTime'?: string;
    /**
     * 
     * @type {ScanConfigRelationship}
     * @memberof ScanRelationship
     */
    'scanConfig'?: ScanConfigRelationship;
    /**
     * List of asset IDs to be scanned
     * @type {Array<string>}
     * @memberof ScanRelationship
     */
    'assetIDs'?: Array<string> | null;
    /**
     * 
     * @type {ScanStatus}
     * @memberof ScanRelationship
     */
    'status'?: ScanStatus;
    /**
     * 
     * @type {ScanSummary}
     * @memberof ScanRelationship
     */
    'summary'?: ScanSummary;
}
/**
 * 
 * @export
 * @interface ScanStatus
 */
export interface ScanStatus {
    /**
     * Describes the state of Scan.  | State      | Description                                                                   | | ---------- | ----------------------------------------------------------------------------- | | Pending    | The initial state when the scan is created, and is working to discover assets | | Discovered | The asset scans have been discovered and are waiting to be scheduled          | | InProgress | The asset scans have been scheduled and the assets are being scanned          | | Aborted    | The scan has been aborted                                                     | | Failed     | One or more assets could not be successfully scanned                          | | Done       | All assets have been scanned successfully                                     | 
     * @type {string}
     * @memberof ScanStatus
     */
    'state': ScanStatusStateEnum;
    /**
     * Machine readable reason for state transition.  | State      | Reason            | Description                                                | | ---------- | ----------------- | ---------------------------------------------------------- | | Pending    | Created           | Scan is pending as it has been newly created               | | Discovered | AssetsDiscovered  | Assets that fall into the scope of the Scan are discovered | | InProgress | AssetScansRunning | AssetScans are currently running                           | | Aborted    | Cancellation      | AssetScans are being moved to Aborted state                | | Failed     | Cancellation      | AssetScans are in Aborted state                            | | Failed     | Error             | At least one AssetScan has ended with an error             | | Failed     | Timeout           | Scan has been timed out                                    | | Done       | NothingToScan     | There are no assets that need to be scanned                | | Done       | Success           | Scan ended successfully without any errors                 | 
     * @type {string}
     * @memberof ScanStatus
     */
    'reason': ScanStatusReasonEnum;
    /**
     * Human readable message.
     * @type {string}
     * @memberof ScanStatus
     */
    'message'?: string;
    /**
     * Last date time when the status has changed.
     * @type {string}
     * @memberof ScanStatus
     */
    'lastTransitionTime': string;
}

export const ScanStatusStateEnum = {
    ScanStatusStatePending: 'Pending',
    ScanStatusStateDiscovered: 'Discovered',
    ScanStatusStateInProgress: 'InProgress',
    ScanStatusStateAborted: 'Aborted',
    ScanStatusStateFailed: 'Failed',
    ScanStatusStateDone: 'Done'
} as const;

export type ScanStatusStateEnum = typeof ScanStatusStateEnum[keyof typeof ScanStatusStateEnum];
export const ScanStatusReasonEnum = {
    ScanStatusReasonCreated: 'Created',
    ScanStatusReasonAssetsDiscovered: 'AssetsDiscovered',
    ScanStatusReasonAssetScansRunning: 'AssetScansRunning',
    ScanStatusReasonCancellation: 'Cancellation',
    ScanStatusReasonError: 'Error',
    ScanStatusReasonTimeout: 'Timeout',
    ScanStatusReasonNothingToScan: 'NothingToScan',
    ScanStatusReasonSuccess: 'Success'
} as const;

export type ScanStatusReasonEnum = typeof ScanStatusReasonEnum[keyof typeof ScanStatusReasonEnum];

/**
 * A summary of the progress of a scan for informational purposes.
 * @export
 * @interface ScanSummary
 */
export interface ScanSummary {
    /**
     * 
     * @type {number}
     * @memberof ScanSummary
     */
    'totalPackages'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanSummary
     */
    'totalExploits'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanSummary
     */
    'totalMalware'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanSummary
     */
    'totalMisconfigurations'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanSummary
     */
    'totalRootkits'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanSummary
     */
    'totalSecrets'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanSummary
     */
    'totalInfoFinder'?: number;
    /**
     * 
     * @type {VulnerabilityScanSummary}
     * @memberof ScanSummary
     */
    'totalVulnerabilities'?: VulnerabilityScanSummary;
    /**
     * 
     * @type {number}
     * @memberof ScanSummary
     */
    'totalPlugins'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanSummary
     */
    'jobsLeftToRun'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScanSummary
     */
    'jobsCompleted'?: number;
}
/**
 * 
 * @export
 * @interface ScanTemplate
 */
export interface ScanTemplate {
    /**
     * The query used to limit the scope of this scan. It uses the ODATA $filter query language to limit the collection of assets that this scan will operate over. For example `startswith(assetInfo.location, \'eu-west-2\')` will limit this scan to just assets in the eu-west-2 AWS region. 
     * @type {string}
     * @memberof ScanTemplate
     */
    'scope'?: string;
    /**
     * The maximum time in seconds that a scan started from this config should run for before being automatically aborted. 
     * @type {number}
     * @memberof ScanTemplate
     */
    'timeoutSeconds'?: number;
    /**
     * The maximum number of asset scans that can be scheduled in parallel for this scan
     * @type {number}
     * @memberof ScanTemplate
     */
    'maxParallelScanners'?: number;
    /**
     * 
     * @type {AssetScanTemplate}
     * @memberof ScanTemplate
     */
    'assetScanTemplate'?: AssetScanTemplate;
}
/**
 * 
 * @export
 * @interface ScanTemplateReadOnly
 */
export interface ScanTemplateReadOnly {
    /**
     * The query used to limit the scope of this scan. It uses the ODATA $filter query language to limit the collection of assets that this scan will operate over. For example `startswith(assetInfo.location, \'eu-west-2\')` will limit this scan to just assets in the eu-west-2 AWS region. 
     * @type {string}
     * @memberof ScanTemplateReadOnly
     */
    'scope'?: string;
    /**
     * The maximum time in seconds that a scan started from this config should run for before being automatically aborted. 
     * @type {number}
     * @memberof ScanTemplateReadOnly
     */
    'timeoutSeconds'?: number;
    /**
     * The maximum number of asset scans that can be scheduled in parallel for this scan
     * @type {number}
     * @memberof ScanTemplateReadOnly
     */
    'maxParallelScanners'?: number;
    /**
     * 
     * @type {AssetScanTemplate}
     * @memberof ScanTemplateReadOnly
     */
    'assetScanTemplate'?: AssetScanTemplate;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ScanType = {
    Sbom: 'SBOM',
    Vulnerability: 'VULNERABILITY',
    Malware: 'MALWARE',
    Secret: 'SECRET',
    Misconfiguration: 'MISCONFIGURATION',
    Rootkit: 'ROOTKIT',
    Exploit: 'EXPLOIT',
    Infofinder: 'INFOFINDER'
} as const;

export type ScanType = typeof ScanType[keyof typeof ScanType];


/**
 * Configuration of scanner instance
 * @export
 * @interface ScannerInstanceCreationConfig
 */
export interface ScannerInstanceCreationConfig {
    /**
     * 
     * @type {boolean}
     * @memberof ScannerInstanceCreationConfig
     */
    'useSpotInstances': boolean;
    /**
     * 
     * @type {number}
     * @memberof ScannerInstanceCreationConfig
     */
    'retryMaxAttempts'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScannerInstanceCreationConfig
     */
    'maxPrice'?: string;
}
/**
 * 
 * @export
 * @interface ScannerMetadata
 */
export interface ScannerMetadata {
    /**
     * 
     * @type {string}
     * @memberof ScannerMetadata
     */
    'scannerName'?: string;
    /**
     * 
     * @type {ScannerSummary}
     * @memberof ScannerMetadata
     */
    'scannerSummary'?: ScannerSummary;
}
/**
 * 
 * @export
 * @interface ScannerStatus
 */
export interface ScannerStatus {
    /**
     * Describes the state of a scanner on the asset.  | State       | Description                                                              | | ----------- | ------------------------------------------------------------------------ | | Pending     | Scanner is pending and waits for state transition to InProgress state    | | InProgress  | Scanning is being performed                                              | | Skipped     | Scanner is **not** scheduled                                             | | Failed      | Scanner has failed, check *reason* and *message* fields for the details  | | Done        | Scanner has finished scanning with no errors                             | 
     * @type {string}
     * @memberof ScannerStatus
     */
    'state': ScannerStatusStateEnum;
    /**
     * Machine readable reason for state transition.  | State      | Reason            | Description                                 | | ---------- | ----------------- | ------------------------------------------- | | Pending    | Scheduled         | Scanner has been enabled in ScanConfig      | | InProgress | Scanning          | Scanner is currently running                | | Skipped    | NotScheduled      | Scanner hasn\'t been enabled in ScanConfig   | | Failed     | Error             | Scanner finished with an error              | | Done       | Success           | Scanner finished successfully               | 
     * @type {string}
     * @memberof ScannerStatus
     */
    'reason': ScannerStatusReasonEnum;
    /**
     * Human readable message.
     * @type {string}
     * @memberof ScannerStatus
     */
    'message'?: string;
    /**
     * Last date time when the status has changed.
     * @type {string}
     * @memberof ScannerStatus
     */
    'lastTransitionTime': string;
}

export const ScannerStatusStateEnum = {
    ScannerStatusStatePending: 'Pending',
    ScannerStatusStateInProgress: 'InProgress',
    ScannerStatusStateSkipped: 'Skipped',
    ScannerStatusStateFailed: 'Failed',
    ScannerStatusStateDone: 'Done'
} as const;

export type ScannerStatusStateEnum = typeof ScannerStatusStateEnum[keyof typeof ScannerStatusStateEnum];
export const ScannerStatusReasonEnum = {
    Scheduled: 'Scheduled',
    Scanning: 'Scanning',
    NotScheduled: 'NotScheduled',
    Error: 'Error',
    Success: 'Success'
} as const;

export type ScannerStatusReasonEnum = typeof ScannerStatusReasonEnum[keyof typeof ScannerStatusReasonEnum];

/**
 * 
 * @export
 * @interface ScannerSummary
 */
export interface ScannerSummary {
    /**
     * 
     * @type {number}
     * @memberof ScannerSummary
     */
    'KnownViruses'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScannerSummary
     */
    'EngineVersion'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScannerSummary
     */
    'ScannedDirectories'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScannerSummary
     */
    'ScannedFiles'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScannerSummary
     */
    'InfectedFiles'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScannerSummary
     */
    'SuspectedFiles'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScannerSummary
     */
    'DataScanned'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScannerSummary
     */
    'DataRead'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScannerSummary
     */
    'TimeTaken'?: string;
}
/**
 * 
 * @export
 * @interface Scans
 */
export interface Scans {
    /**
     * Total scans count according to the given filters
     * @type {number}
     * @memberof Scans
     */
    'count'?: number;
    /**
     * List of scans according to the given filters and page. List length must be lower or equal to pageSize.
     * @type {Array<Scan>}
     * @memberof Scans
     */
    'items'?: Array<Scan>;
}
/**
 * 
 * @export
 * @interface Secret
 */
export interface Secret {
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    'description'?: string;
    /**
     * Name of the file containing the secret
     * @type {string}
     * @memberof Secret
     */
    'filePath'?: string;
    /**
     * 
     * @type {number}
     * @memberof Secret
     */
    'startLine'?: number;
    /**
     * 
     * @type {number}
     * @memberof Secret
     */
    'endLine'?: number;
    /**
     * 
     * @type {number}
     * @memberof Secret
     */
    'startColumn'?: number;
    /**
     * 
     * @type {number}
     * @memberof Secret
     */
    'endColumn'?: number;
    /**
     * Note: this is not unique
     * @type {string}
     * @memberof Secret
     */
    'fingerprint'?: string;
}
/**
 * 
 * @export
 * @interface SecretFindingInfo
 */
export interface SecretFindingInfo {
    /**
     * 
     * @type {string}
     * @memberof SecretFindingInfo
     */
    'description'?: string;
    /**
     * Name of the file containing the secret
     * @type {string}
     * @memberof SecretFindingInfo
     */
    'filePath'?: string;
    /**
     * 
     * @type {number}
     * @memberof SecretFindingInfo
     */
    'startLine'?: number;
    /**
     * 
     * @type {number}
     * @memberof SecretFindingInfo
     */
    'endLine'?: number;
    /**
     * 
     * @type {number}
     * @memberof SecretFindingInfo
     */
    'startColumn'?: number;
    /**
     * 
     * @type {number}
     * @memberof SecretFindingInfo
     */
    'endColumn'?: number;
    /**
     * Note: this is not unique
     * @type {string}
     * @memberof SecretFindingInfo
     */
    'fingerprint'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecretFindingInfo
     */
    'objectType': string;
}
/**
 * 
 * @export
 * @interface SecretScan
 */
export interface SecretScan {
    /**
     * 
     * @type {ScannerStatus}
     * @memberof SecretScan
     */
    'status'?: ScannerStatus;
    /**
     * 
     * @type {Array<Secret>}
     * @memberof SecretScan
     */
    'secrets'?: Array<Secret> | null;
}
/**
 * 
 * @export
 * @interface SecretsConfig
 */
export interface SecretsConfig {
    /**
     * 
     * @type {boolean}
     * @memberof SecretsConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof SecretsConfig
     */
    'scanners'?: Array<string>;
}
/**
 * general cloud security group
 * @export
 * @interface SecurityGroup
 */
export interface SecurityGroup {
    /**
     * 
     * @type {string}
     * @memberof SecurityGroup
     */
    'id': string;
}
/**
 * An object that is returned in cases of success that returns nothing.
 * @export
 * @interface SuccessResponse
 */
export interface SuccessResponse {
    /**
     * 
     * @type {string}
     * @memberof SuccessResponse
     */
    'message'?: string;
}
/**
 * general cloud tag / label
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface VMInfo
 */
export interface VMInfo {
    /**
     * 
     * @type {string}
     * @memberof VMInfo
     */
    'objectType': string;
    /**
     * 
     * @type {string}
     * @memberof VMInfo
     */
    'instanceID': string;
    /**
     * 
     * @type {CloudProvider}
     * @memberof VMInfo
     */
    'instanceProvider'?: CloudProvider;
    /**
     * 
     * @type {string}
     * @memberof VMInfo
     */
    'location': string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof VMInfo
     */
    'tags'?: Array<Tag> | null;
    /**
     * 
     * @type {Array<SecurityGroup>}
     * @memberof VMInfo
     */
    'securityGroups'?: Array<SecurityGroup> | null;
    /**
     * 
     * @type {string}
     * @memberof VMInfo
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof VMInfo
     */
    'instanceType': string;
    /**
     * 
     * @type {string}
     * @memberof VMInfo
     */
    'platform': string;
    /**
     * 
     * @type {string}
     * @memberof VMInfo
     */
    'launchTime': string;
    /**
     * 
     * @type {RootVolume}
     * @memberof VMInfo
     */
    'rootVolume': RootVolume;
}


/**
 * 
 * @export
 * @interface VulnerabilitiesConfig
 */
export interface VulnerabilitiesConfig {
    /**
     * 
     * @type {boolean}
     * @memberof VulnerabilitiesConfig
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof VulnerabilitiesConfig
     */
    'scanners'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Vulnerability
 */
export interface Vulnerability {
    /**
     * 
     * @type {string}
     * @memberof Vulnerability
     */
    'vulnerabilityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Vulnerability
     */
    'description'?: string;
    /**
     * 
     * @type {VulnerabilitySeverity}
     * @memberof Vulnerability
     */
    'severity'?: VulnerabilitySeverity;
    /**
     * 
     * @type {Array<string>}
     * @memberof Vulnerability
     */
    'links'?: Array<string> | null;
    /**
     * 
     * @type {VulnerabilityDistro}
     * @memberof Vulnerability
     */
    'distro'?: VulnerabilityDistro;
    /**
     * 
     * @type {Array<VulnerabilityCvss>}
     * @memberof Vulnerability
     */
    'cvss'?: Array<VulnerabilityCvss> | null;
    /**
     * 
     * @type {Package}
     * @memberof Vulnerability
     */
    'package'?: Package;
    /**
     * 
     * @type {VulnerabilityFix}
     * @memberof Vulnerability
     */
    'fix'?: VulnerabilityFix;
    /**
     * 
     * @type {string}
     * @memberof Vulnerability
     */
    'layerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Vulnerability
     */
    'path'?: string;
}


/**
 * 
 * @export
 * @interface VulnerabilityCvss
 */
export interface VulnerabilityCvss {
    /**
     * 
     * @type {string}
     * @memberof VulnerabilityCvss
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof VulnerabilityCvss
     */
    'vector'?: string;
    /**
     * 
     * @type {VulnerabilityCvssMetrics}
     * @memberof VulnerabilityCvss
     */
    'metrics'?: VulnerabilityCvssMetrics;
}
/**
 * 
 * @export
 * @interface VulnerabilityCvssMetrics
 */
export interface VulnerabilityCvssMetrics {
    /**
     * 
     * @type {number}
     * @memberof VulnerabilityCvssMetrics
     */
    'baseScore'?: number;
    /**
     * 
     * @type {number}
     * @memberof VulnerabilityCvssMetrics
     */
    'exploitabilityScore'?: number;
    /**
     * 
     * @type {number}
     * @memberof VulnerabilityCvssMetrics
     */
    'impactScore'?: number;
}
/**
 * Distro provides information about a detected Linux distribution.
 * @export
 * @interface VulnerabilityDistro
 */
export interface VulnerabilityDistro {
    /**
     * Name of the Linux distribution
     * @type {string}
     * @memberof VulnerabilityDistro
     */
    'name'?: string;
    /**
     * Version of the Linux distribution (major or major.minor version)
     * @type {string}
     * @memberof VulnerabilityDistro
     */
    'version'?: string;
    /**
     * the ID_LIKE field found within the /etc/os-release file
     * @type {Array<string>}
     * @memberof VulnerabilityDistro
     */
    'IDLike'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface VulnerabilityFindingInfo
 */
export interface VulnerabilityFindingInfo {
    /**
     * 
     * @type {string}
     * @memberof VulnerabilityFindingInfo
     */
    'vulnerabilityName'?: string;
    /**
     * 
     * @type {string}
     * @memberof VulnerabilityFindingInfo
     */
    'description'?: string;
    /**
     * 
     * @type {VulnerabilitySeverity}
     * @memberof VulnerabilityFindingInfo
     */
    'severity'?: VulnerabilitySeverity;
    /**
     * 
     * @type {Array<string>}
     * @memberof VulnerabilityFindingInfo
     */
    'links'?: Array<string> | null;
    /**
     * 
     * @type {VulnerabilityDistro}
     * @memberof VulnerabilityFindingInfo
     */
    'distro'?: VulnerabilityDistro;
    /**
     * 
     * @type {Array<VulnerabilityCvss>}
     * @memberof VulnerabilityFindingInfo
     */
    'cvss'?: Array<VulnerabilityCvss> | null;
    /**
     * 
     * @type {Package}
     * @memberof VulnerabilityFindingInfo
     */
    'package'?: Package;
    /**
     * 
     * @type {VulnerabilityFix}
     * @memberof VulnerabilityFindingInfo
     */
    'fix'?: VulnerabilityFix;
    /**
     * 
     * @type {string}
     * @memberof VulnerabilityFindingInfo
     */
    'layerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof VulnerabilityFindingInfo
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof VulnerabilityFindingInfo
     */
    'objectType': string;
}


/**
 * 
 * @export
 * @interface VulnerabilityFix
 */
export interface VulnerabilityFix {
    /**
     * 
     * @type {Array<string>}
     * @memberof VulnerabilityFix
     */
    'versions'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof VulnerabilityFix
     */
    'state'?: string;
}
/**
 * 
 * @export
 * @interface VulnerabilityScan
 */
export interface VulnerabilityScan {
    /**
     * 
     * @type {ScannerStatus}
     * @memberof VulnerabilityScan
     */
    'status'?: ScannerStatus;
    /**
     * 
     * @type {Array<Vulnerability>}
     * @memberof VulnerabilityScan
     */
    'vulnerabilities'?: Array<Vulnerability> | null;
}
/**
 * A summary of number of vulnerabilities found per severity.
 * @export
 * @interface VulnerabilityScanSummary
 */
export interface VulnerabilityScanSummary {
    /**
     * 
     * @type {number}
     * @memberof VulnerabilityScanSummary
     */
    'totalCriticalVulnerabilities'?: number;
    /**
     * 
     * @type {number}
     * @memberof VulnerabilityScanSummary
     */
    'totalHighVulnerabilities'?: number;
    /**
     * 
     * @type {number}
     * @memberof VulnerabilityScanSummary
     */
    'totalMediumVulnerabilities'?: number;
    /**
     * 
     * @type {number}
     * @memberof VulnerabilityScanSummary
     */
    'totalLowVulnerabilities'?: number;
    /**
     * 
     * @type {number}
     * @memberof VulnerabilityScanSummary
     */
    'totalNegligibleVulnerabilities'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const VulnerabilitySeverity = {
    Critical: 'CRITICAL',
    High: 'HIGH',
    Medium: 'MEDIUM',
    Low: 'LOW',
    Negligible: 'NEGLIGIBLE'
} as const;

export type VulnerabilitySeverity = typeof VulnerabilitySeverity[keyof typeof VulnerabilitySeverity];



/**
 * VMClarityApi - axios parameter creator
 * @export
 */
export const VMClarityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an asset finding.
         * @param {string} assetFindingID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetFindingsAssetFindingID: async (assetFindingID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetFindingID' is not null or undefined
            assertParamExists('deleteAssetFindingsAssetFindingID', 'assetFindingID', assetFindingID)
            const localVarPath = `/assetFindings/{assetFindingID}`
                .replace(`{${"assetFindingID"}}`, encodeURIComponent(String(assetFindingID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an asset scan estimation.
         * @param {string} assetScanEstimationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetScanEstimationsAssetScanEstimationID: async (assetScanEstimationID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetScanEstimationID' is not null or undefined
            assertParamExists('deleteAssetScanEstimationsAssetScanEstimationID', 'assetScanEstimationID', assetScanEstimationID)
            const localVarPath = `/assetScanEstimations/{assetScanEstimationID}`
                .replace(`{${"assetScanEstimationID"}}`, encodeURIComponent(String(assetScanEstimationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete asset.
         * @param {string} assetID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetsAssetID: async (assetID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetID' is not null or undefined
            assertParamExists('deleteAssetsAssetID', 'assetID', assetID)
            const localVarPath = `/assets/{assetID}`
                .replace(`{${"assetID"}}`, encodeURIComponent(String(assetID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a finding.
         * @param {string} findingID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFindingsFindingID: async (findingID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findingID' is not null or undefined
            assertParamExists('deleteFindingsFindingID', 'findingID', findingID)
            const localVarPath = `/findings/{findingID}`
                .replace(`{${"findingID"}}`, encodeURIComponent(String(findingID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete provider.
         * @param {string} providerID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvidersProviderID: async (providerID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerID' is not null or undefined
            assertParamExists('deleteProvidersProviderID', 'providerID', providerID)
            const localVarPath = `/providers/{providerID}`
                .replace(`{${"providerID"}}`, encodeURIComponent(String(providerID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a scan config.
         * @param {string} scanConfigID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScanConfigsScanConfigID: async (scanConfigID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanConfigID' is not null or undefined
            assertParamExists('deleteScanConfigsScanConfigID', 'scanConfigID', scanConfigID)
            const localVarPath = `/scanConfigs/{scanConfigID}`
                .replace(`{${"scanConfigID"}}`, encodeURIComponent(String(scanConfigID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a scan estimation.
         * @param {string} scanEstimationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScanEstimationsScanEstimationID: async (scanEstimationID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanEstimationID' is not null or undefined
            assertParamExists('deleteScanEstimationsScanEstimationID', 'scanEstimationID', scanEstimationID)
            const localVarPath = `/scanEstimations/{scanEstimationID}`
                .replace(`{${"scanEstimationID"}}`, encodeURIComponent(String(scanEstimationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a scan.
         * @param {string} scanID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScansScanID: async (scanID: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanID' is not null or undefined
            assertParamExists('deleteScansScanID', 'scanID', scanID)
            const localVarPath = `/scans/{scanID}`
                .replace(`{${"scanID"}}`, encodeURIComponent(String(scanID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all asset findings.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetFindings: async ($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/assetFindings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details for an asset finding.
         * @param {string} assetFindingID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetFindingsAssetFindingID: async (assetFindingID: string, $select?: string, $expand?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetFindingID' is not null or undefined
            assertParamExists('getAssetFindingsAssetFindingID', 'assetFindingID', assetFindingID)
            const localVarPath = `/assetFindings/{assetFindingID}`
                .replace(`{${"assetFindingID"}}`, encodeURIComponent(String(assetFindingID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get asset scan estimations according to the given filters
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetScanEstimations: async ($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/assetScanEstimations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an asset scan estimation.
         * @param {string} assetScanEstimationID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetScanEstimationsAssetScanEstimationID: async (assetScanEstimationID: string, $select?: string, $expand?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetScanEstimationID' is not null or undefined
            assertParamExists('getAssetScanEstimationsAssetScanEstimationID', 'assetScanEstimationID', assetScanEstimationID)
            const localVarPath = `/assetScanEstimations/{assetScanEstimationID}`
                .replace(`{${"assetScanEstimationID"}}`, encodeURIComponent(String(assetScanEstimationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get asset scans according to the given filters
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetScans: async ($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/assetScans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an asset scan.
         * @param {string} assetScanID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetScansAssetScanID: async (assetScanID: string, $select?: string, $expand?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetScanID' is not null or undefined
            assertParamExists('getAssetScansAssetScanID', 'assetScanID', assetScanID)
            const localVarPath = `/assetScans/{assetScanID}`
                .replace(`{${"assetScanID"}}`, encodeURIComponent(String(assetScanID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get assets
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssets: async ($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get asset.
         * @param {string} assetID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsAssetID: async (assetID: string, $select?: string, $expand?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetID' is not null or undefined
            assertParamExists('getAssetsAssetID', 'assetID', assetID)
            const localVarPath = `/assets/{assetID}`
                .replace(`{${"assetID"}}`, encodeURIComponent(String(assetID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all findings.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFindings: async ($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/findings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details for a finding.
         * @param {string} findingID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFindingsFindingID: async (findingID: string, $select?: string, $expand?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findingID' is not null or undefined
            assertParamExists('getFindingsFindingID', 'findingID', findingID)
            const localVarPath = `/findings/{findingID}`
                .replace(`{${"findingID"}}`, encodeURIComponent(String(findingID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get this OpenAPI spec
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenAPISpec: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/openapi.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get providers
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders: async ($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get provider.
         * @param {string} providerID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvidersProviderID: async (providerID: string, $select?: string, $expand?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerID' is not null or undefined
            assertParamExists('getProvidersProviderID', 'providerID', providerID)
            const localVarPath = `/providers/{providerID}`
                .replace(`{${"providerID"}}`, encodeURIComponent(String(providerID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all scan configs.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScanConfigs: async ($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scanConfigs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details for a scan config.
         * @param {string} scanConfigID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScanConfigsScanConfigID: async (scanConfigID: string, $select?: string, $expand?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanConfigID' is not null or undefined
            assertParamExists('getScanConfigsScanConfigID', 'scanConfigID', scanConfigID)
            const localVarPath = `/scanConfigs/{scanConfigID}`
                .replace(`{${"scanConfigID"}}`, encodeURIComponent(String(scanConfigID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all scan estimations. Each scan estimation contains details about a multi-asset scan estimation.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScanEstimations: async ($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scanEstimations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details for a given multi-asset scan estimation.
         * @param {string} scanEstimationID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScanEstimationsScanEstimationID: async (scanEstimationID: string, $select?: string, $expand?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanEstimationID' is not null or undefined
            assertParamExists('getScanEstimationsScanEstimationID', 'scanEstimationID', scanEstimationID)
            const localVarPath = `/scanEstimations/{scanEstimationID}`
                .replace(`{${"scanEstimationID"}}`, encodeURIComponent(String(scanEstimationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all scans. Each scan contains details about a multi-asset scheduled scan.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScans: async ($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/scans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($filter !== undefined) {
                localVarQueryParameter['$filter'] = $filter;
            }

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($count !== undefined) {
                localVarQueryParameter['$count'] = $count;
            }

            if ($top !== undefined) {
                localVarQueryParameter['$top'] = $top;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }

            if ($orderby !== undefined) {
                localVarQueryParameter['$orderby'] = $orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the details for a given multi-asset scheduled scan.
         * @param {string} scanID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScansScanID: async (scanID: string, $select?: string, $expand?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanID' is not null or undefined
            assertParamExists('getScansScanID', 'scanID', scanID)
            const localVarPath = `/scans/{scanID}`
                .replace(`{${"scanID"}}`, encodeURIComponent(String(scanID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if ($select !== undefined) {
                localVarQueryParameter['$select'] = $select;
            }

            if ($expand !== undefined) {
                localVarQueryParameter['$expand'] = $expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch an asset finding.
         * @param {string} assetFindingID 
         * @param {AssetFinding} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAssetFindingsAssetFindingID: async (assetFindingID: string, body: AssetFinding, ifMatch?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetFindingID' is not null or undefined
            assertParamExists('patchAssetFindingsAssetFindingID', 'assetFindingID', assetFindingID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchAssetFindingsAssetFindingID', 'body', body)
            const localVarPath = `/assetFindings/{assetFindingID}`
                .replace(`{${"assetFindingID"}}`, encodeURIComponent(String(assetFindingID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch an asset scan estimation
         * @param {string} assetScanEstimationID 
         * @param {AssetScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAssetScanEstimationsAssetScanEstimationID: async (assetScanEstimationID: string, body: AssetScanEstimation, ifMatch?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetScanEstimationID' is not null or undefined
            assertParamExists('patchAssetScanEstimationsAssetScanEstimationID', 'assetScanEstimationID', assetScanEstimationID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchAssetScanEstimationsAssetScanEstimationID', 'body', body)
            const localVarPath = `/assetScanEstimations/{assetScanEstimationID}`
                .replace(`{${"assetScanEstimationID"}}`, encodeURIComponent(String(assetScanEstimationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch an asset scan
         * @param {string} assetScanID 
         * @param {AssetScan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAssetScansAssetScanID: async (assetScanID: string, body: AssetScan, ifMatch?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetScanID' is not null or undefined
            assertParamExists('patchAssetScansAssetScanID', 'assetScanID', assetScanID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchAssetScansAssetScanID', 'body', body)
            const localVarPath = `/assetScans/{assetScanID}`
                .replace(`{${"assetScanID"}}`, encodeURIComponent(String(assetScanID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update asset.
         * @param {string} assetID 
         * @param {Asset} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAssetsAssetID: async (assetID: string, body: Asset, ifMatch?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetID' is not null or undefined
            assertParamExists('patchAssetsAssetID', 'assetID', assetID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchAssetsAssetID', 'body', body)
            const localVarPath = `/assets/{assetID}`
                .replace(`{${"assetID"}}`, encodeURIComponent(String(assetID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch a finding.
         * @param {string} findingID 
         * @param {Finding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchFindingsFindingID: async (findingID: string, body: Finding, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findingID' is not null or undefined
            assertParamExists('patchFindingsFindingID', 'findingID', findingID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchFindingsFindingID', 'body', body)
            const localVarPath = `/findings/{findingID}`
                .replace(`{${"findingID"}}`, encodeURIComponent(String(findingID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update provider.
         * @param {string} providerID 
         * @param {Provider} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProvidersProviderID: async (providerID: string, body: Provider, ifMatch?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerID' is not null or undefined
            assertParamExists('patchProvidersProviderID', 'providerID', providerID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchProvidersProviderID', 'body', body)
            const localVarPath = `/providers/{providerID}`
                .replace(`{${"providerID"}}`, encodeURIComponent(String(providerID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch a scan config.
         * @param {string} scanConfigID 
         * @param {ScanConfig} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScanConfigsScanConfigID: async (scanConfigID: string, body: ScanConfig, ifMatch?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanConfigID' is not null or undefined
            assertParamExists('patchScanConfigsScanConfigID', 'scanConfigID', scanConfigID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchScanConfigsScanConfigID', 'body', body)
            const localVarPath = `/scanConfigs/{scanConfigID}`
                .replace(`{${"scanConfigID"}}`, encodeURIComponent(String(scanConfigID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch a scan estimation.
         * @param {string} scanEstimationID 
         * @param {ScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScanEstimationsScanEstimationID: async (scanEstimationID: string, body: ScanEstimation, ifMatch?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanEstimationID' is not null or undefined
            assertParamExists('patchScanEstimationsScanEstimationID', 'scanEstimationID', scanEstimationID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchScanEstimationsScanEstimationID', 'body', body)
            const localVarPath = `/scanEstimations/{scanEstimationID}`
                .replace(`{${"scanEstimationID"}}`, encodeURIComponent(String(scanEstimationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Patch a scan.
         * @param {string} scanID 
         * @param {Scan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScansScanID: async (scanID: string, body: Scan, ifMatch?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanID' is not null or undefined
            assertParamExists('patchScansScanID', 'scanID', scanID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('patchScansScanID', 'body', body)
            const localVarPath = `/scans/{scanID}`
                .replace(`{${"scanID"}}`, encodeURIComponent(String(scanID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an asset finding
         * @param {AssetFinding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetFindings: async (body: AssetFinding, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postAssetFindings', 'body', body)
            const localVarPath = `/assetFindings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an asset scan estimation for a specified asset
         * @param {AssetScanEstimation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetScanEstimations: async (body: AssetScanEstimation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postAssetScanEstimations', 'body', body)
            const localVarPath = `/assetScanEstimations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an asset scan for a specified asset
         * @param {AssetScan} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetScans: async (body: AssetScan, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postAssetScans', 'body', body)
            const localVarPath = `/assetScans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create asset
         * @param {Asset} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssets: async (body: Asset, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postAssets', 'body', body)
            const localVarPath = `/assets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a finding
         * @param {Finding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFindings: async (body: Finding, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postFindings', 'body', body)
            const localVarPath = `/findings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create provider
         * @param {Provider} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProviders: async (body: Provider, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postProviders', 'body', body)
            const localVarPath = `/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a scan config
         * @param {ScanConfig} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScanConfigs: async (body: ScanConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postScanConfigs', 'body', body)
            const localVarPath = `/scanConfigs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a multi-asset scan estimation
         * @param {ScanEstimation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScanEstimations: async (body: ScanEstimation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postScanEstimations', 'body', body)
            const localVarPath = `/scanEstimations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a multi-asset scheduled scan
         * @param {Scan} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScans: async (body: Scan, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('postScans', 'body', body)
            const localVarPath = `/scans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an asset finding.
         * @param {string} assetFindingID 
         * @param {AssetFinding} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetFindingsAssetFindingID: async (assetFindingID: string, body: AssetFinding, ifMatch?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetFindingID' is not null or undefined
            assertParamExists('putAssetFindingsAssetFindingID', 'assetFindingID', assetFindingID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putAssetFindingsAssetFindingID', 'body', body)
            const localVarPath = `/assetFindings/{assetFindingID}`
                .replace(`{${"assetFindingID"}}`, encodeURIComponent(String(assetFindingID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an asset scan estimation.
         * @param {string} assetScanEstimationID 
         * @param {AssetScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetScanEstimationsAssetScanEstimationID: async (assetScanEstimationID: string, body: AssetScanEstimation, ifMatch?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetScanEstimationID' is not null or undefined
            assertParamExists('putAssetScanEstimationsAssetScanEstimationID', 'assetScanEstimationID', assetScanEstimationID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putAssetScanEstimationsAssetScanEstimationID', 'body', body)
            const localVarPath = `/assetScanEstimations/{assetScanEstimationID}`
                .replace(`{${"assetScanEstimationID"}}`, encodeURIComponent(String(assetScanEstimationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an asset scan.
         * @param {string} assetScanID 
         * @param {AssetScan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetScansAssetScanID: async (assetScanID: string, body: AssetScan, ifMatch?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetScanID' is not null or undefined
            assertParamExists('putAssetScansAssetScanID', 'assetScanID', assetScanID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putAssetScansAssetScanID', 'body', body)
            const localVarPath = `/assetScans/{assetScanID}`
                .replace(`{${"assetScanID"}}`, encodeURIComponent(String(assetScanID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update asset.
         * @param {string} assetID 
         * @param {Asset} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetsAssetID: async (assetID: string, body: Asset, ifMatch?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assetID' is not null or undefined
            assertParamExists('putAssetsAssetID', 'assetID', assetID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putAssetsAssetID', 'body', body)
            const localVarPath = `/assets/{assetID}`
                .replace(`{${"assetID"}}`, encodeURIComponent(String(assetID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a finding.
         * @param {string} findingID 
         * @param {Finding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFindingsFindingID: async (findingID: string, body: Finding, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'findingID' is not null or undefined
            assertParamExists('putFindingsFindingID', 'findingID', findingID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putFindingsFindingID', 'body', body)
            const localVarPath = `/findings/{findingID}`
                .replace(`{${"findingID"}}`, encodeURIComponent(String(findingID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update provider.
         * @param {string} providerID 
         * @param {Provider} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProvidersProviderID: async (providerID: string, body: Provider, ifMatch?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerID' is not null or undefined
            assertParamExists('putProvidersProviderID', 'providerID', providerID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putProvidersProviderID', 'body', body)
            const localVarPath = `/providers/{providerID}`
                .replace(`{${"providerID"}}`, encodeURIComponent(String(providerID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a scan config.
         * @param {string} scanConfigID 
         * @param {ScanConfig} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putScanConfigsScanConfigID: async (scanConfigID: string, body: ScanConfig, ifMatch?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanConfigID' is not null or undefined
            assertParamExists('putScanConfigsScanConfigID', 'scanConfigID', scanConfigID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putScanConfigsScanConfigID', 'body', body)
            const localVarPath = `/scanConfigs/{scanConfigID}`
                .replace(`{${"scanConfigID"}}`, encodeURIComponent(String(scanConfigID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a scan estimation.
         * @param {string} scanEstimationID 
         * @param {ScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putScanEstimationsScanEstimationID: async (scanEstimationID: string, body: ScanEstimation, ifMatch?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanEstimationID' is not null or undefined
            assertParamExists('putScanEstimationsScanEstimationID', 'scanEstimationID', scanEstimationID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putScanEstimationsScanEstimationID', 'body', body)
            const localVarPath = `/scanEstimations/{scanEstimationID}`
                .replace(`{${"scanEstimationID"}}`, encodeURIComponent(String(scanEstimationID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a scan.
         * @param {string} scanID 
         * @param {Scan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putScansScanID: async (scanID: string, body: Scan, ifMatch?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scanID' is not null or undefined
            assertParamExists('putScansScanID', 'scanID', scanID)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('putScansScanID', 'body', body)
            const localVarPath = `/scans/{scanID}`
                .replace(`{${"scanID"}}`, encodeURIComponent(String(scanID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifMatch != null) {
                localVarHeaderParameter['If-Match'] = typeof ifMatch === 'string'
                    ? ifMatch
                    : JSON.stringify(ifMatch);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VMClarityApi - functional programming interface
 * @export
 */
export const VMClarityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VMClarityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete an asset finding.
         * @param {string} assetFindingID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAssetFindingsAssetFindingID(assetFindingID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAssetFindingsAssetFindingID(assetFindingID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.deleteAssetFindingsAssetFindingID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an asset scan estimation.
         * @param {string} assetScanEstimationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.deleteAssetScanEstimationsAssetScanEstimationID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete asset.
         * @param {string} assetID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAssetsAssetID(assetID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAssetsAssetID(assetID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.deleteAssetsAssetID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a finding.
         * @param {string} findingID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFindingsFindingID(findingID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFindingsFindingID(findingID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.deleteFindingsFindingID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete provider.
         * @param {string} providerID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProvidersProviderID(providerID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProvidersProviderID(providerID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.deleteProvidersProviderID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a scan config.
         * @param {string} scanConfigID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScanConfigsScanConfigID(scanConfigID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScanConfigsScanConfigID(scanConfigID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.deleteScanConfigsScanConfigID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a scan estimation.
         * @param {string} scanEstimationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScanEstimationsScanEstimationID(scanEstimationID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScanEstimationsScanEstimationID(scanEstimationID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.deleteScanEstimationsScanEstimationID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a scan.
         * @param {string} scanID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScansScanID(scanID: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScansScanID(scanID, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.deleteScansScanID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all asset findings.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetFindings($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetFindings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetFindings($filter, $select, $count, $top, $skip, $expand, $orderby, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.getAssetFindings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details for an asset finding.
         * @param {string} assetFindingID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetFindingsAssetFindingID(assetFindingID: string, $select?: string, $expand?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetFindingsAssetFindingID(assetFindingID, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.getAssetFindingsAssetFindingID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get asset scan estimations according to the given filters
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetScanEstimations($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetScanEstimations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetScanEstimations($filter, $select, $count, $top, $skip, $expand, $orderby, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.getAssetScanEstimations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get an asset scan estimation.
         * @param {string} assetScanEstimationID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, $select?: string, $expand?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetScanEstimation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.getAssetScanEstimationsAssetScanEstimationID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get asset scans according to the given filters
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetScans($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetScans>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetScans($filter, $select, $count, $top, $skip, $expand, $orderby, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.getAssetScans']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get an asset scan.
         * @param {string} assetScanID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetScansAssetScanID(assetScanID: string, $select?: string, $expand?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetScan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetScansAssetScanID(assetScanID, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.getAssetScansAssetScanID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get assets
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssets($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Assets>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssets($filter, $select, $count, $top, $skip, $expand, $orderby, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.getAssets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get asset.
         * @param {string} assetID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssetsAssetID(assetID: string, $select?: string, $expand?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssetsAssetID(assetID, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.getAssetsAssetID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all findings.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFindings($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Findings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFindings($filter, $select, $count, $top, $skip, $expand, $orderby, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.getFindings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details for a finding.
         * @param {string} findingID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFindingsFindingID(findingID: string, $select?: string, $expand?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Finding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFindingsFindingID(findingID, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.getFindingsFindingID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get this OpenAPI spec
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenAPISpec(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenAPISpec(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.getOpenAPISpec']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get providers
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProviders($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Providers>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProviders($filter, $select, $count, $top, $skip, $expand, $orderby, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.getProviders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get provider.
         * @param {string} providerID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProvidersProviderID(providerID: string, $select?: string, $expand?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProvidersProviderID(providerID, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.getProvidersProviderID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all scan configs.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScanConfigs($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanConfigs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScanConfigs($filter, $select, $count, $top, $skip, $expand, $orderby, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.getScanConfigs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details for a scan config.
         * @param {string} scanConfigID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScanConfigsScanConfigID(scanConfigID: string, $select?: string, $expand?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScanConfigsScanConfigID(scanConfigID, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.getScanConfigsScanConfigID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all scan estimations. Each scan estimation contains details about a multi-asset scan estimation.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScanEstimations($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanEstimations>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScanEstimations($filter, $select, $count, $top, $skip, $expand, $orderby, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.getScanEstimations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details for a given multi-asset scan estimation.
         * @param {string} scanEstimationID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScanEstimationsScanEstimationID(scanEstimationID: string, $select?: string, $expand?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanEstimation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScanEstimationsScanEstimationID(scanEstimationID, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.getScanEstimationsScanEstimationID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all scans. Each scan contains details about a multi-asset scheduled scan.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScans($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scans>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScans($filter, $select, $count, $top, $skip, $expand, $orderby, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.getScans']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the details for a given multi-asset scheduled scan.
         * @param {string} scanID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScansScanID(scanID: string, $select?: string, $expand?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScansScanID(scanID, $select, $expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.getScansScanID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Patch an asset finding.
         * @param {string} assetFindingID 
         * @param {AssetFinding} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAssetFindingsAssetFindingID(assetFindingID: string, body: AssetFinding, ifMatch?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAssetFindingsAssetFindingID(assetFindingID, body, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.patchAssetFindingsAssetFindingID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Patch an asset scan estimation
         * @param {string} assetScanEstimationID 
         * @param {AssetScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, body: AssetScanEstimation, ifMatch?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetScanEstimation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, body, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.patchAssetScanEstimationsAssetScanEstimationID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Patch an asset scan
         * @param {string} assetScanID 
         * @param {AssetScan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAssetScansAssetScanID(assetScanID: string, body: AssetScan, ifMatch?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetScan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAssetScansAssetScanID(assetScanID, body, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.patchAssetScansAssetScanID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update asset.
         * @param {string} assetID 
         * @param {Asset} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAssetsAssetID(assetID: string, body: Asset, ifMatch?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAssetsAssetID(assetID, body, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.patchAssetsAssetID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Patch a finding.
         * @param {string} findingID 
         * @param {Finding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchFindingsFindingID(findingID: string, body: Finding, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Finding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchFindingsFindingID(findingID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.patchFindingsFindingID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update provider.
         * @param {string} providerID 
         * @param {Provider} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchProvidersProviderID(providerID: string, body: Provider, ifMatch?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchProvidersProviderID(providerID, body, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.patchProvidersProviderID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Patch a scan config.
         * @param {string} scanConfigID 
         * @param {ScanConfig} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchScanConfigsScanConfigID(scanConfigID: string, body: ScanConfig, ifMatch?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchScanConfigsScanConfigID(scanConfigID, body, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.patchScanConfigsScanConfigID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Patch a scan estimation.
         * @param {string} scanEstimationID 
         * @param {ScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchScanEstimationsScanEstimationID(scanEstimationID: string, body: ScanEstimation, ifMatch?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanEstimation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchScanEstimationsScanEstimationID(scanEstimationID, body, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.patchScanEstimationsScanEstimationID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Patch a scan.
         * @param {string} scanID 
         * @param {Scan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchScansScanID(scanID: string, body: Scan, ifMatch?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchScansScanID(scanID, body, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.patchScansScanID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create an asset finding
         * @param {AssetFinding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAssetFindings(body: AssetFinding, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAssetFindings(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.postAssetFindings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create an asset scan estimation for a specified asset
         * @param {AssetScanEstimation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAssetScanEstimations(body: AssetScanEstimation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetScanEstimation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAssetScanEstimations(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.postAssetScanEstimations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create an asset scan for a specified asset
         * @param {AssetScan} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAssetScans(body: AssetScan, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetScan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAssetScans(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.postAssetScans']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create asset
         * @param {Asset} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAssets(body: Asset, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAssets(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.postAssets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a finding
         * @param {Finding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postFindings(body: Finding, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Finding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postFindings(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.postFindings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create provider
         * @param {Provider} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postProviders(body: Provider, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postProviders(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.postProviders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a scan config
         * @param {ScanConfig} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postScanConfigs(body: ScanConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postScanConfigs(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.postScanConfigs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a multi-asset scan estimation
         * @param {ScanEstimation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postScanEstimations(body: ScanEstimation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanEstimation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postScanEstimations(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.postScanEstimations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a multi-asset scheduled scan
         * @param {Scan} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postScans(body: Scan, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postScans(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.postScans']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an asset finding.
         * @param {string} assetFindingID 
         * @param {AssetFinding} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAssetFindingsAssetFindingID(assetFindingID: string, body: AssetFinding, ifMatch?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetFinding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAssetFindingsAssetFindingID(assetFindingID, body, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.putAssetFindingsAssetFindingID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an asset scan estimation.
         * @param {string} assetScanEstimationID 
         * @param {AssetScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, body: AssetScanEstimation, ifMatch?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetScanEstimation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, body, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.putAssetScanEstimationsAssetScanEstimationID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an asset scan.
         * @param {string} assetScanID 
         * @param {AssetScan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAssetScansAssetScanID(assetScanID: string, body: AssetScan, ifMatch?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetScan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAssetScansAssetScanID(assetScanID, body, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.putAssetScansAssetScanID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update asset.
         * @param {string} assetID 
         * @param {Asset} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAssetsAssetID(assetID: string, body: Asset, ifMatch?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Asset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAssetsAssetID(assetID, body, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.putAssetsAssetID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a finding.
         * @param {string} findingID 
         * @param {Finding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putFindingsFindingID(findingID: string, body: Finding, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Finding>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putFindingsFindingID(findingID, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.putFindingsFindingID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update provider.
         * @param {string} providerID 
         * @param {Provider} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putProvidersProviderID(providerID: string, body: Provider, ifMatch?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putProvidersProviderID(providerID, body, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.putProvidersProviderID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a scan config.
         * @param {string} scanConfigID 
         * @param {ScanConfig} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putScanConfigsScanConfigID(scanConfigID: string, body: ScanConfig, ifMatch?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putScanConfigsScanConfigID(scanConfigID, body, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.putScanConfigsScanConfigID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a scan estimation.
         * @param {string} scanEstimationID 
         * @param {ScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putScanEstimationsScanEstimationID(scanEstimationID: string, body: ScanEstimation, ifMatch?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScanEstimation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putScanEstimationsScanEstimationID(scanEstimationID, body, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.putScanEstimationsScanEstimationID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a scan.
         * @param {string} scanID 
         * @param {Scan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putScansScanID(scanID: string, body: Scan, ifMatch?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putScansScanID(scanID, body, ifMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VMClarityApi.putScansScanID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VMClarityApi - factory interface
 * @export
 */
export const VMClarityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VMClarityApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete an asset finding.
         * @param {string} assetFindingID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetFindingsAssetFindingID(assetFindingID: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteAssetFindingsAssetFindingID(assetFindingID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an asset scan estimation.
         * @param {string} assetScanEstimationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete asset.
         * @param {string} assetID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetsAssetID(assetID: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteAssetsAssetID(assetID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a finding.
         * @param {string} findingID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFindingsFindingID(findingID: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteFindingsFindingID(findingID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete provider.
         * @param {string} providerID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProvidersProviderID(providerID: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteProvidersProviderID(providerID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a scan config.
         * @param {string} scanConfigID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScanConfigsScanConfigID(scanConfigID: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteScanConfigsScanConfigID(scanConfigID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a scan estimation.
         * @param {string} scanEstimationID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScanEstimationsScanEstimationID(scanEstimationID: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteScanEstimationsScanEstimationID(scanEstimationID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a scan.
         * @param {string} scanID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScansScanID(scanID: string, options?: any): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteScansScanID(scanID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all asset findings.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetFindings($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: any): AxiosPromise<AssetFindings> {
            return localVarFp.getAssetFindings($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details for an asset finding.
         * @param {string} assetFindingID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetFindingsAssetFindingID(assetFindingID: string, $select?: string, $expand?: string, options?: any): AxiosPromise<AssetFinding> {
            return localVarFp.getAssetFindingsAssetFindingID(assetFindingID, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get asset scan estimations according to the given filters
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetScanEstimations($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: any): AxiosPromise<AssetScanEstimations> {
            return localVarFp.getAssetScanEstimations($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an asset scan estimation.
         * @param {string} assetScanEstimationID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, $select?: string, $expand?: string, options?: any): AxiosPromise<AssetScanEstimation> {
            return localVarFp.getAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get asset scans according to the given filters
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetScans($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: any): AxiosPromise<AssetScans> {
            return localVarFp.getAssetScans($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an asset scan.
         * @param {string} assetScanID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetScansAssetScanID(assetScanID: string, $select?: string, $expand?: string, options?: any): AxiosPromise<AssetScan> {
            return localVarFp.getAssetScansAssetScanID(assetScanID, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get assets
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssets($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: any): AxiosPromise<Assets> {
            return localVarFp.getAssets($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get asset.
         * @param {string} assetID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetsAssetID(assetID: string, $select?: string, $expand?: string, options?: any): AxiosPromise<Asset> {
            return localVarFp.getAssetsAssetID(assetID, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all findings.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFindings($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: any): AxiosPromise<Findings> {
            return localVarFp.getFindings($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details for a finding.
         * @param {string} findingID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFindingsFindingID(findingID: string, $select?: string, $expand?: string, options?: any): AxiosPromise<Finding> {
            return localVarFp.getFindingsFindingID(findingID, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get this OpenAPI spec
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenAPISpec(options?: any): AxiosPromise<string> {
            return localVarFp.getOpenAPISpec(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get providers
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProviders($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: any): AxiosPromise<Providers> {
            return localVarFp.getProviders($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get provider.
         * @param {string} providerID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProvidersProviderID(providerID: string, $select?: string, $expand?: string, options?: any): AxiosPromise<Provider> {
            return localVarFp.getProvidersProviderID(providerID, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all scan configs.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScanConfigs($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: any): AxiosPromise<ScanConfigs> {
            return localVarFp.getScanConfigs($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details for a scan config.
         * @param {string} scanConfigID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScanConfigsScanConfigID(scanConfigID: string, $select?: string, $expand?: string, options?: any): AxiosPromise<ScanConfig> {
            return localVarFp.getScanConfigsScanConfigID(scanConfigID, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all scan estimations. Each scan estimation contains details about a multi-asset scan estimation.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScanEstimations($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: any): AxiosPromise<ScanEstimations> {
            return localVarFp.getScanEstimations($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details for a given multi-asset scan estimation.
         * @param {string} scanEstimationID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScanEstimationsScanEstimationID(scanEstimationID: string, $select?: string, $expand?: string, options?: any): AxiosPromise<ScanEstimation> {
            return localVarFp.getScanEstimationsScanEstimationID(scanEstimationID, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all scans. Each scan contains details about a multi-asset scheduled scan.
         * @param {string} [$filter] 
         * @param {string} [$select] 
         * @param {boolean} [$count] 
         * @param {number} [$top] 
         * @param {number} [$skip] 
         * @param {string} [$expand] 
         * @param {string} [$orderby] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScans($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: any): AxiosPromise<Scans> {
            return localVarFp.getScans($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the details for a given multi-asset scheduled scan.
         * @param {string} scanID 
         * @param {string} [$select] 
         * @param {string} [$expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScansScanID(scanID: string, $select?: string, $expand?: string, options?: any): AxiosPromise<Scan> {
            return localVarFp.getScansScanID(scanID, $select, $expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch an asset finding.
         * @param {string} assetFindingID 
         * @param {AssetFinding} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAssetFindingsAssetFindingID(assetFindingID: string, body: AssetFinding, ifMatch?: number, options?: any): AxiosPromise<AssetFinding> {
            return localVarFp.patchAssetFindingsAssetFindingID(assetFindingID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch an asset scan estimation
         * @param {string} assetScanEstimationID 
         * @param {AssetScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, body: AssetScanEstimation, ifMatch?: number, options?: any): AxiosPromise<AssetScanEstimation> {
            return localVarFp.patchAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch an asset scan
         * @param {string} assetScanID 
         * @param {AssetScan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAssetScansAssetScanID(assetScanID: string, body: AssetScan, ifMatch?: number, options?: any): AxiosPromise<AssetScan> {
            return localVarFp.patchAssetScansAssetScanID(assetScanID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update asset.
         * @param {string} assetID 
         * @param {Asset} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAssetsAssetID(assetID: string, body: Asset, ifMatch?: number, options?: any): AxiosPromise<Asset> {
            return localVarFp.patchAssetsAssetID(assetID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch a finding.
         * @param {string} findingID 
         * @param {Finding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchFindingsFindingID(findingID: string, body: Finding, options?: any): AxiosPromise<Finding> {
            return localVarFp.patchFindingsFindingID(findingID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update provider.
         * @param {string} providerID 
         * @param {Provider} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchProvidersProviderID(providerID: string, body: Provider, ifMatch?: number, options?: any): AxiosPromise<Provider> {
            return localVarFp.patchProvidersProviderID(providerID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch a scan config.
         * @param {string} scanConfigID 
         * @param {ScanConfig} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScanConfigsScanConfigID(scanConfigID: string, body: ScanConfig, ifMatch?: number, options?: any): AxiosPromise<ScanConfig> {
            return localVarFp.patchScanConfigsScanConfigID(scanConfigID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch a scan estimation.
         * @param {string} scanEstimationID 
         * @param {ScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScanEstimationsScanEstimationID(scanEstimationID: string, body: ScanEstimation, ifMatch?: number, options?: any): AxiosPromise<ScanEstimation> {
            return localVarFp.patchScanEstimationsScanEstimationID(scanEstimationID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Patch a scan.
         * @param {string} scanID 
         * @param {Scan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchScansScanID(scanID: string, body: Scan, ifMatch?: number, options?: any): AxiosPromise<Scan> {
            return localVarFp.patchScansScanID(scanID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an asset finding
         * @param {AssetFinding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetFindings(body: AssetFinding, options?: any): AxiosPromise<AssetFinding> {
            return localVarFp.postAssetFindings(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an asset scan estimation for a specified asset
         * @param {AssetScanEstimation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetScanEstimations(body: AssetScanEstimation, options?: any): AxiosPromise<AssetScanEstimation> {
            return localVarFp.postAssetScanEstimations(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an asset scan for a specified asset
         * @param {AssetScan} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssetScans(body: AssetScan, options?: any): AxiosPromise<AssetScan> {
            return localVarFp.postAssetScans(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create asset
         * @param {Asset} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAssets(body: Asset, options?: any): AxiosPromise<Asset> {
            return localVarFp.postAssets(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a finding
         * @param {Finding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFindings(body: Finding, options?: any): AxiosPromise<Finding> {
            return localVarFp.postFindings(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create provider
         * @param {Provider} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postProviders(body: Provider, options?: any): AxiosPromise<Provider> {
            return localVarFp.postProviders(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a scan config
         * @param {ScanConfig} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScanConfigs(body: ScanConfig, options?: any): AxiosPromise<ScanConfig> {
            return localVarFp.postScanConfigs(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a multi-asset scan estimation
         * @param {ScanEstimation} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScanEstimations(body: ScanEstimation, options?: any): AxiosPromise<ScanEstimation> {
            return localVarFp.postScanEstimations(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a multi-asset scheduled scan
         * @param {Scan} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postScans(body: Scan, options?: any): AxiosPromise<Scan> {
            return localVarFp.postScans(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an asset finding.
         * @param {string} assetFindingID 
         * @param {AssetFinding} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetFindingsAssetFindingID(assetFindingID: string, body: AssetFinding, ifMatch?: number, options?: any): AxiosPromise<AssetFinding> {
            return localVarFp.putAssetFindingsAssetFindingID(assetFindingID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an asset scan estimation.
         * @param {string} assetScanEstimationID 
         * @param {AssetScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, body: AssetScanEstimation, ifMatch?: number, options?: any): AxiosPromise<AssetScanEstimation> {
            return localVarFp.putAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an asset scan.
         * @param {string} assetScanID 
         * @param {AssetScan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetScansAssetScanID(assetScanID: string, body: AssetScan, ifMatch?: number, options?: any): AxiosPromise<AssetScan> {
            return localVarFp.putAssetScansAssetScanID(assetScanID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update asset.
         * @param {string} assetID 
         * @param {Asset} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAssetsAssetID(assetID: string, body: Asset, ifMatch?: number, options?: any): AxiosPromise<Asset> {
            return localVarFp.putAssetsAssetID(assetID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a finding.
         * @param {string} findingID 
         * @param {Finding} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putFindingsFindingID(findingID: string, body: Finding, options?: any): AxiosPromise<Finding> {
            return localVarFp.putFindingsFindingID(findingID, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update provider.
         * @param {string} providerID 
         * @param {Provider} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putProvidersProviderID(providerID: string, body: Provider, ifMatch?: number, options?: any): AxiosPromise<Provider> {
            return localVarFp.putProvidersProviderID(providerID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a scan config.
         * @param {string} scanConfigID 
         * @param {ScanConfig} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putScanConfigsScanConfigID(scanConfigID: string, body: ScanConfig, ifMatch?: number, options?: any): AxiosPromise<ScanConfig> {
            return localVarFp.putScanConfigsScanConfigID(scanConfigID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a scan estimation.
         * @param {string} scanEstimationID 
         * @param {ScanEstimation} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putScanEstimationsScanEstimationID(scanEstimationID: string, body: ScanEstimation, ifMatch?: number, options?: any): AxiosPromise<ScanEstimation> {
            return localVarFp.putScanEstimationsScanEstimationID(scanEstimationID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a scan.
         * @param {string} scanID 
         * @param {Scan} body 
         * @param {number} [ifMatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putScansScanID(scanID: string, body: Scan, ifMatch?: number, options?: any): AxiosPromise<Scan> {
            return localVarFp.putScansScanID(scanID, body, ifMatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VMClarityApi - object-oriented interface
 * @export
 * @class VMClarityApi
 * @extends {BaseAPI}
 */
export class VMClarityApi extends BaseAPI {
    /**
     * 
     * @summary Delete an asset finding.
     * @param {string} assetFindingID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public deleteAssetFindingsAssetFindingID(assetFindingID: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).deleteAssetFindingsAssetFindingID(assetFindingID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an asset scan estimation.
     * @param {string} assetScanEstimationID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public deleteAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).deleteAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete asset.
     * @param {string} assetID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public deleteAssetsAssetID(assetID: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).deleteAssetsAssetID(assetID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a finding.
     * @param {string} findingID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public deleteFindingsFindingID(findingID: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).deleteFindingsFindingID(findingID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete provider.
     * @param {string} providerID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public deleteProvidersProviderID(providerID: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).deleteProvidersProviderID(providerID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a scan config.
     * @param {string} scanConfigID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public deleteScanConfigsScanConfigID(scanConfigID: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).deleteScanConfigsScanConfigID(scanConfigID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a scan estimation.
     * @param {string} scanEstimationID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public deleteScanEstimationsScanEstimationID(scanEstimationID: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).deleteScanEstimationsScanEstimationID(scanEstimationID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a scan.
     * @param {string} scanID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public deleteScansScanID(scanID: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).deleteScansScanID(scanID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all asset findings.
     * @param {string} [$filter] 
     * @param {string} [$select] 
     * @param {boolean} [$count] 
     * @param {number} [$top] 
     * @param {number} [$skip] 
     * @param {string} [$expand] 
     * @param {string} [$orderby] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getAssetFindings($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getAssetFindings($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details for an asset finding.
     * @param {string} assetFindingID 
     * @param {string} [$select] 
     * @param {string} [$expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getAssetFindingsAssetFindingID(assetFindingID: string, $select?: string, $expand?: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getAssetFindingsAssetFindingID(assetFindingID, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get asset scan estimations according to the given filters
     * @param {string} [$filter] 
     * @param {string} [$select] 
     * @param {boolean} [$count] 
     * @param {number} [$top] 
     * @param {number} [$skip] 
     * @param {string} [$expand] 
     * @param {string} [$orderby] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getAssetScanEstimations($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getAssetScanEstimations($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an asset scan estimation.
     * @param {string} assetScanEstimationID 
     * @param {string} [$select] 
     * @param {string} [$expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, $select?: string, $expand?: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get asset scans according to the given filters
     * @param {string} [$filter] 
     * @param {string} [$select] 
     * @param {boolean} [$count] 
     * @param {number} [$top] 
     * @param {number} [$skip] 
     * @param {string} [$expand] 
     * @param {string} [$orderby] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getAssetScans($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getAssetScans($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an asset scan.
     * @param {string} assetScanID 
     * @param {string} [$select] 
     * @param {string} [$expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getAssetScansAssetScanID(assetScanID: string, $select?: string, $expand?: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getAssetScansAssetScanID(assetScanID, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get assets
     * @param {string} [$filter] 
     * @param {string} [$select] 
     * @param {boolean} [$count] 
     * @param {number} [$top] 
     * @param {number} [$skip] 
     * @param {string} [$expand] 
     * @param {string} [$orderby] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getAssets($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getAssets($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get asset.
     * @param {string} assetID 
     * @param {string} [$select] 
     * @param {string} [$expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getAssetsAssetID(assetID: string, $select?: string, $expand?: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getAssetsAssetID(assetID, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all findings.
     * @param {string} [$filter] 
     * @param {string} [$select] 
     * @param {boolean} [$count] 
     * @param {number} [$top] 
     * @param {number} [$skip] 
     * @param {string} [$expand] 
     * @param {string} [$orderby] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getFindings($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getFindings($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details for a finding.
     * @param {string} findingID 
     * @param {string} [$select] 
     * @param {string} [$expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getFindingsFindingID(findingID: string, $select?: string, $expand?: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getFindingsFindingID(findingID, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get this OpenAPI spec
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getOpenAPISpec(options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getOpenAPISpec(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get providers
     * @param {string} [$filter] 
     * @param {string} [$select] 
     * @param {boolean} [$count] 
     * @param {number} [$top] 
     * @param {number} [$skip] 
     * @param {string} [$expand] 
     * @param {string} [$orderby] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getProviders($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getProviders($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get provider.
     * @param {string} providerID 
     * @param {string} [$select] 
     * @param {string} [$expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getProvidersProviderID(providerID: string, $select?: string, $expand?: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getProvidersProviderID(providerID, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all scan configs.
     * @param {string} [$filter] 
     * @param {string} [$select] 
     * @param {boolean} [$count] 
     * @param {number} [$top] 
     * @param {number} [$skip] 
     * @param {string} [$expand] 
     * @param {string} [$orderby] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getScanConfigs($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getScanConfigs($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details for a scan config.
     * @param {string} scanConfigID 
     * @param {string} [$select] 
     * @param {string} [$expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getScanConfigsScanConfigID(scanConfigID: string, $select?: string, $expand?: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getScanConfigsScanConfigID(scanConfigID, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all scan estimations. Each scan estimation contains details about a multi-asset scan estimation.
     * @param {string} [$filter] 
     * @param {string} [$select] 
     * @param {boolean} [$count] 
     * @param {number} [$top] 
     * @param {number} [$skip] 
     * @param {string} [$expand] 
     * @param {string} [$orderby] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getScanEstimations($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getScanEstimations($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details for a given multi-asset scan estimation.
     * @param {string} scanEstimationID 
     * @param {string} [$select] 
     * @param {string} [$expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getScanEstimationsScanEstimationID(scanEstimationID: string, $select?: string, $expand?: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getScanEstimationsScanEstimationID(scanEstimationID, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all scans. Each scan contains details about a multi-asset scheduled scan.
     * @param {string} [$filter] 
     * @param {string} [$select] 
     * @param {boolean} [$count] 
     * @param {number} [$top] 
     * @param {number} [$skip] 
     * @param {string} [$expand] 
     * @param {string} [$orderby] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getScans($filter?: string, $select?: string, $count?: boolean, $top?: number, $skip?: number, $expand?: string, $orderby?: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getScans($filter, $select, $count, $top, $skip, $expand, $orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the details for a given multi-asset scheduled scan.
     * @param {string} scanID 
     * @param {string} [$select] 
     * @param {string} [$expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public getScansScanID(scanID: string, $select?: string, $expand?: string, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).getScansScanID(scanID, $select, $expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch an asset finding.
     * @param {string} assetFindingID 
     * @param {AssetFinding} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public patchAssetFindingsAssetFindingID(assetFindingID: string, body: AssetFinding, ifMatch?: number, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).patchAssetFindingsAssetFindingID(assetFindingID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch an asset scan estimation
     * @param {string} assetScanEstimationID 
     * @param {AssetScanEstimation} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public patchAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, body: AssetScanEstimation, ifMatch?: number, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).patchAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch an asset scan
     * @param {string} assetScanID 
     * @param {AssetScan} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public patchAssetScansAssetScanID(assetScanID: string, body: AssetScan, ifMatch?: number, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).patchAssetScansAssetScanID(assetScanID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update asset.
     * @param {string} assetID 
     * @param {Asset} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public patchAssetsAssetID(assetID: string, body: Asset, ifMatch?: number, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).patchAssetsAssetID(assetID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch a finding.
     * @param {string} findingID 
     * @param {Finding} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public patchFindingsFindingID(findingID: string, body: Finding, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).patchFindingsFindingID(findingID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update provider.
     * @param {string} providerID 
     * @param {Provider} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public patchProvidersProviderID(providerID: string, body: Provider, ifMatch?: number, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).patchProvidersProviderID(providerID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch a scan config.
     * @param {string} scanConfigID 
     * @param {ScanConfig} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public patchScanConfigsScanConfigID(scanConfigID: string, body: ScanConfig, ifMatch?: number, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).patchScanConfigsScanConfigID(scanConfigID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch a scan estimation.
     * @param {string} scanEstimationID 
     * @param {ScanEstimation} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public patchScanEstimationsScanEstimationID(scanEstimationID: string, body: ScanEstimation, ifMatch?: number, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).patchScanEstimationsScanEstimationID(scanEstimationID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Patch a scan.
     * @param {string} scanID 
     * @param {Scan} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public patchScansScanID(scanID: string, body: Scan, ifMatch?: number, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).patchScansScanID(scanID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an asset finding
     * @param {AssetFinding} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public postAssetFindings(body: AssetFinding, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).postAssetFindings(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an asset scan estimation for a specified asset
     * @param {AssetScanEstimation} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public postAssetScanEstimations(body: AssetScanEstimation, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).postAssetScanEstimations(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an asset scan for a specified asset
     * @param {AssetScan} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public postAssetScans(body: AssetScan, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).postAssetScans(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create asset
     * @param {Asset} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public postAssets(body: Asset, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).postAssets(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a finding
     * @param {Finding} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public postFindings(body: Finding, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).postFindings(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create provider
     * @param {Provider} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public postProviders(body: Provider, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).postProviders(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a scan config
     * @param {ScanConfig} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public postScanConfigs(body: ScanConfig, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).postScanConfigs(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a multi-asset scan estimation
     * @param {ScanEstimation} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public postScanEstimations(body: ScanEstimation, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).postScanEstimations(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a multi-asset scheduled scan
     * @param {Scan} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public postScans(body: Scan, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).postScans(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an asset finding.
     * @param {string} assetFindingID 
     * @param {AssetFinding} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public putAssetFindingsAssetFindingID(assetFindingID: string, body: AssetFinding, ifMatch?: number, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).putAssetFindingsAssetFindingID(assetFindingID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an asset scan estimation.
     * @param {string} assetScanEstimationID 
     * @param {AssetScanEstimation} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public putAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID: string, body: AssetScanEstimation, ifMatch?: number, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).putAssetScanEstimationsAssetScanEstimationID(assetScanEstimationID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an asset scan.
     * @param {string} assetScanID 
     * @param {AssetScan} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public putAssetScansAssetScanID(assetScanID: string, body: AssetScan, ifMatch?: number, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).putAssetScansAssetScanID(assetScanID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update asset.
     * @param {string} assetID 
     * @param {Asset} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public putAssetsAssetID(assetID: string, body: Asset, ifMatch?: number, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).putAssetsAssetID(assetID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a finding.
     * @param {string} findingID 
     * @param {Finding} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public putFindingsFindingID(findingID: string, body: Finding, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).putFindingsFindingID(findingID, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update provider.
     * @param {string} providerID 
     * @param {Provider} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public putProvidersProviderID(providerID: string, body: Provider, ifMatch?: number, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).putProvidersProviderID(providerID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a scan config.
     * @param {string} scanConfigID 
     * @param {ScanConfig} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public putScanConfigsScanConfigID(scanConfigID: string, body: ScanConfig, ifMatch?: number, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).putScanConfigsScanConfigID(scanConfigID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a scan estimation.
     * @param {string} scanEstimationID 
     * @param {ScanEstimation} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public putScanEstimationsScanEstimationID(scanEstimationID: string, body: ScanEstimation, ifMatch?: number, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).putScanEstimationsScanEstimationID(scanEstimationID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a scan.
     * @param {string} scanID 
     * @param {Scan} body 
     * @param {number} [ifMatch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VMClarityApi
     */
    public putScansScanID(scanID: string, body: Scan, ifMatch?: number, options?: RawAxiosRequestConfig) {
        return VMClarityApiFp(this.configuration).putScansScanID(scanID, body, ifMatch, options).then((request) => request(this.axios, this.basePath));
    }
}



